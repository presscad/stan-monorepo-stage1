STAN V1.0
======================================================================

* debug potential issue with NUTS II (Matt)

* distribution engineering (Daniel)
  download:  tarballs, doc
  tarball:  Stan repository (+ binaries?)

* speed tests relative to JAGS

* revise home page (see below)


HOME PAGE
======================================================================
Why does someone show up on the home page?

* Find out what Stan is
 - short description right up top
 - link to manual

* Download latest
 - clear license link
 - big link to latest code tarball:
     stan-src-1.0.0.tgz
 - link to latest Git repository

* Find/join User Group
 - big link to gorups

* Contact / issue tracker
 - big link up top

* Maybe they also want:
- executables
   + bin/stanc
   + pre-built versions for certain OS/compilers
- browse Git source archive
 - API doc online
 - How to cite Stan
   now: Arxiv/JMLR paper NUTS, manual/web site for Stan
 - older versions



CODE CLEANUP
======================================================================

* const declarations wherever possible

* more care with size_t, etc.

* API doc for doxygen

* privatize API parts not needed

* stan::math and stan::agrad configurable error handling
  - how to configure std::log(), etc. for error handling?
    need our own versions?

* remove unnecessary dependencies/includes

* convert for loops with size bounds to appropriate iterators



Stan-R
======================================================================

* break out into own project with its own license (GPL)
  - still include on Stan page, just flag license, or
  - break out into own project

* use Rcpp to call C from R and vice-versa

* Example call:

   fit <- rstan(model_file,inits, ....);

   + compile model
   + read dump data OR from R
   + read dump inits OR from R
   + run model
   + load results to file OR R

* access data from samples object in C++

* Run pre-built analyses on fit:
  + attach.stan(fit)
  + print(fit)
  + traceplot(fit)
  + plot.stan(fit)
  + dump.stan(fit)
  + read.stan(file_path)

* Get data from fit 
  - structured
  - chains optionally merged w. permutation
  - individual chains



EXTENSIONS
======================================================================

Sampling
----------------------------------------------------------------------

* discrete samplers (Matt)
  - Gibbs for small outcome sets
  - slice for larger outcome sets
  - what about multinomial with constraints?

* more general built-in initializations
  -  normal or student-t w. params
  -  or even set uniform boundaries
  -  e.g., uniform(-1,1), normal(0,1), t(0,2.5)

* stop NUTS from running away without coming back
  - limit number of steps
    + command-line param
    + instrumenting NUTS loops (adaptation, leapfrog)
  - limit time
    + start recording time at beginning, check loops inside
  - bomb with report if exceed these steps

* print more info during adaptation
  - adapted step size


Modeling Language
----------------------------------------------------------------------

* triangular matrix type
  - how to implement in Eigen?
    + triangular view?

* symmetric matrix type 
 - how to implement in Eigen?  
 - what ops to allow? 
   + sets are symmetric
   + but this'll get products wrong as
     everything but diagonal will get set twice

* Cholesky factor type

* special positive-definiteness-preserving operations
  - basic data type (or trait)
  - operations that preserve well-formedness, perhaps
    by fudging boundary conditions

* add a parameter initialization block
  - fill in values not given randomly or report error?
  - needs randomization

* syntactic sugar sampling notation
  - blocks where sampling not allowed (all but model)
  - generated quantities, parameter init block:
      beta[n] ~ normal(0,10);
    means 
      beta[n] <- random_normal(0,10);
  - right-hand side must all be defined here

* matrix power operations
  -  matrix power:    A^n
  - matrix elementwise power:  A.^x

* add printf statement for debugging purposes
  - really format or just list params?

* Allow normal_log<true> and normal_log<false> to be accessed
  directly

* Allow normal_log(y|0,1) as parser synonym for normal_log(y,0,1)

* warnings
  - a <- foo(theta) if LHS contains variable: overwrite var
  - a ~ foo(theta)  if LHS is complex expression: need Jacobian

* integer subtypes
  - integer(-inf,inf), count(1,inf), natural(0,inf)
  - boolean(0,1), categorical(1,K), ordinal(1,K),

* double subtypes
  - probability(0,1), correlation(-1,1)
  - positive(0,inf), negative(-inf,0)

* matrix slice and assign
  - index m
  - range-indexes :, a:, :b, a:b
  - e.g., matrix(M,N) m; vector(M) v;  m[,1] = v;

* conditionals
  - conditional expression
  - ternary op: cond ? x : y
  - if (cond) statement else if (cond) statement ... else statement;
  - while (cond) statement;
  - repeat statement until cond;
  
* multi-returns and array literals
  - (a,b,c) = foo();  // function returns array
  - (m,n,p) = (1,2,3);   // (1,2,3) is array literal

* multiple declarations
  - e.g., double a, b, c[N];

* declare and assign
  - e.g., double x = 5.0;
    double b[5];
    double a[5] <- b; // odd, eh?
    simplex(5)[2] c <- ... // even odder

* extensions
  - declare file paths to #include
  - declare namespace usings
  - declare function sigs for parser

* ragged arrays
  - ready to use with vec<...<vec<x>...> pattern
  - not clear how to declare (follow C?)

* subroutines
  - user-defined functions in StanGM
  - user-defined densities (how much to require?)

* compound op-assigns in StanGM
  - +=, *=, etc.

* check each parameter shows up on LHS of ~
  - true check is run-time based on data, etc.







Stanc Compiler
----------------------------------------------------------------------

* generate templated log_prob function so that you don't
  need to evaluate auto-dif when just evaluating function

* Stan safe mode to compile BUGS/JAGS-compliant models



Command-line
----------------------------------------------------------------------

* control significant digits in output through command line

* restart from where command left off a la R2jags
  - this will require writing dump output or a converter
    for the CSV output to dump output

* auto convergence monitoring -- just keep doubling (or other ratio)

  


C++ API
----------------------------------------------------------------------

* as much partial eval for gradients as possible
  - matrices
  - probability functions

* cut out last derivative step in leapfrog if not nec.
  - only saves if very small number of leapfrog steps

* threading
  - rewrite memory arena as thread-local object
  - merging and monitoring several threads/processes

* could multi-thread agrad by copying all code; use var<1>, var<2>,
  etc., with var typedefed to var<1>.  Each would then have its
  own memory pool to read from.  How to specify by client?  Could
  generate templated code

* figure out way to have vari elements that are NOT on the stack
  - useful for numeric_limits<var>
  - stack_vari ==> vari ==> chainable
    local_vari ==^
    (stack_vari has operator new; local_vari uses dtor)

* convert memory for vari to singleton & allow thread locality
  for thread safety

* make sure std::less<T*> and std::swap<T*> 
 does right thing for our types (like var and vari), as
 these are used in "algorithms".

* use our arena-based alloc as STL allocator for auto-dif
  - already doing this for dot products
  - http://www.cplusplus.com/reference/std/memory/allocator/
  - what do we need to do for dtor to work?

* Watanabe's WAIC: Widely applicable information criterion

* Ben's implicit function idea -- iterative solver,
 analytic derivative

* refactor finite diff derivative calcs to functor
      template <class F, typename S>
      bool finite_diffs(const vector<S>& x,
                        const F& f,
                        vector<S>& df_dx);

* Speed test pass-by-const-ref and pass-by-val for stan::agrad::var

* Convergence monitoring of higher moments



Special Functions, Probability Functions and Distributions
----------------------------------------------------------------------

* alternative distribution parameterizations
  - e.g., precision for (multi) normal
  - inverse_sqrt_gamma(...)

* random generation functions
  - rnorm(),...

* special functions
  - inv(x) = 1/x
  - inv_square(x) = 1/(x * x)
  - dot_self(vector v);  dot_self(row_vector v);  
  - log_sum_exp_ratio(vector<double> log_ratios, 
                      vector<double> log_probs);
  - rank(v,s): number of components of v less than v[s]
  - ranked(v,s): s-th smallest component of v
  - interp_ln(e,v1,v2) from BUGS (whatever for?)

* dot_self(x) == x' * x operation

* wrap_multiply(u,v) = u' * v * u

* More matrix functions from Eigen:
  - norm()
  - squaredNorm()
  - lpNorm<1>
  - lpNorm<Eigen::Infinity>

* z-score function
  - normalize sample to zero sample mean, unit sample variance

* cumulative distribution functions
  - to add:
     + calculation of cdf
     + two functions: 1) with templated policy, 2) with no policy,
        calling templated function with stan::math::default_policy()
     + TODO: test derivatives?
     + dox: add doxygen.
     + add to Stan Modeling Language Reference Manual function list
  - uni/cont/inv_chi_square
  - uni/cont/inv_gamma
  - uni/cont/logisitic
  - uni/cont/pareto
  - uni/cont/scaled_inv_chi_square
  - uni/cont/student_t
  - uni/cont/uniform
  - uni/disc/bernoulli
  - uni/disc/beta_binomial
  - uni/disc/binomial
  - uni/disc/hypergeometric
  - uni/disc/neg_binomial
  - uni/disc/ordered_logisitic
  - uni/disc/poisson
  - multi/cont/dirichlet
  - multi/cont/inv_wishart
  - multi/cont/lkj_corr
  - multi/cont/lkj_cov
  - multi/cont/multi_normal
  - multi/cont/multi_student_t
  - multi/cont/wishart
  - multi/disc/categorical
  - multi/disc/multinomial


Error Handling
----------------------------------------------------------------------

* some kind of error handling for std lib functions
  like log(double).  


Testing
----------------------------------------------------------------------

* build unit tests from the BUGS models that just check
  the gradients are right (this'll also cover parsing and
  being able to fire up the models)

* auto testing of sampler
  - Cook/Gelman/Rubin-style interval tests
  - needs effective sample size calc to bound intervals
  - needs simulated parameters to test estimators
  - push ESS "measurement error" through the interval tests

* more matrix tests (for all ops w. gradients)

* benchmarks
  - agrad vs. RAD/Sacado, CppAD, ... ?
  - stan vs. MCMCpack, R, BUGS, JAGS, OpenBUGS, ...

* profile running models w. various operations

* complete math robustness and limits review
  - want domain boundaries to be right (usually
    -inf, 0 and inf, etc.)

* more diagnostics during warmup of where epsilon is going

* speed measurement
  - to converge
  - time per effective sample once converged
  - time to 4 chains at 25 ESS/chain, rHat < 1.1 for all
    parameters theta[k] and theta[k]*theta[k]
  - discarding first half of samples too many if fast to converge




Models
----------------------------------------------------------------------

* unit K-hyperball complement for stationary AR(K) parameters
  - what should the prior be?

* user model library
  - something we don't have to get too involved vetting
  - ideally things hard to do with other systems
  - or illustrate the unusual parts of our modeling language
 

New Stuff
----------------------------------------------------------------------

* forward mode auto-dif
  - last revision 548: 
  - src/stan/agrad/ad.hpp

* optimization
  - functor-based concept design with templates 
  - easily pluggable with log prob in model for MAP 

* compiler for R's linear model notation

* interface to Python

* interface to MATLAB

* Riemannian manifold sampling
 - Girolami's method with auto-diff Hessians

* multiple imputation
  - when to run it?
  - how to model it?

* mapped distributions
  - foo(x|theta) ==> foo(xs|theta)
  - C style: x*, int size
  - iterator concept: (x.start(),x.end())
  - array concept: (x[n], x.size())

* monitor/sampler interface
  - sampler, filter, aggregator, buffer
  - online means and variances
  - rHat, and split rHat
  - run in second process as we go?

* whole new auto-dif.  stack consists of entries per expression
  containing
  - adjoint for expression
  - for each argument
    + partial 
    + ptr to subexpression  
  - less space for constants, equal for unary, more for binary+
  - no virtual ops


* code gen auto-dif
  - just for Stan GM models

* lazy init for var
  - if vari* is accessed and empty, return new var(0) equiv.
  - can't afford test to see if it's defined

* elim stan/maths/matrix lib by adding implicit ctor
  for Matrix<var,...> based on Matrix<double,...>

* some notion of momentum for discrete variables a la HMC
  for continuous variables (at least accelerate metropolis-hastings)
  some densities generalize 

* blocking updates
  - only update subset of parameters
  - specify blocks in program?
  - allow Gibbs on some variables
  - split HMC into blocks (aka batches)
  - in the limit do conditional with HMC!



MODELS
======================================================================

* Online book with models based on BUGS:
  http://stat-athens.aueb.gr/~jbn/winbugs_book/

* deal with autocorrelation model params where require
  all roots of 1 - SUM_i rho[i]**i to be within unit
  complex circle


BUGS Models
----------------------------------------------------------------------
All of the vol1 -- vol3 models are implemented except
for the following, categorized by issue.

* Sampler too slow
  - vol2/schools/schools.stan.0
  - vol3/fire/fire.stan.0

* Sampler hangs
  - vol3/funshapes/hsquare.stan.0
  - vol3/funshapes/ring.stan.0
  - vol3/funshapes/squaremc.stan.0

* Zero Poisson, 0 ~ Poisson(0 * parameters) hangs the following:
  Isn't this one fixed?
  - vol1/leuk/leuk.stan.0
  - vol1/leukfr/leukfr.stan.0

* Cyclic DAGs
  Can probably do these in Stan (not supported in JAGS).
  - vol2/ice/pineapple_ice.stan.0
  - vol2/ice/vanilla_ice.stan.0
  - vol3/jama/jama.stan.0

* Discrete parameters
  - vol2/asia/asia.stan.0
  - vol2/biopsies/biopsies.stan.0
  - vol2/stagnant/stagnant.stan.0
  - vol2/t_df/estdof2.stan.0

* Binary parameters
  Other versions of model working integrating out discretes.
  - vol2/cervix/cervix.stan.0 
  - vol2/hearts/hearts.stan.0

* Works, but data structure difficult to deal with
  - vol1/bones/bones.stan.0



MODELING LANGUAGE MANUAL
======================================================================

* add example calculating log likelihood for DIC

* add example on individual log likelihoods for WAIC

   generated quantities {
    for (i in 1:I) 
      for (j in 1:J) 
        ll_y[i,j] <- normal_log(y[i,j]...)

* C++ model class

* Index



C++ API MANUAL
======================================================================

* Enough doc to use agrad w. matrices and probability functions

* Goes along with cleaning up API doc and privatizing





