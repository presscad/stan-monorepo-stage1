// Code generated by Stan version alpha.0

#include <cmath>
#include <vector>
#include <fstream>
#include <sstream>
#include <Eigen/Dense>
#include <stan/agrad/agrad.hpp>
#include <stan/agrad/special_functions.hpp>
#include <stan/agrad/matrix.hpp>
#include <stan/io/cmd_line.hpp>
#include <stan/io/dump.hpp>
#include <stan/io/reader.hpp>
#include <stan/io/csv_writer.hpp>
#include <stan/maths/matrix.hpp>
#include <stan/maths/special_functions.hpp>
#include <stan/mcmc/hmc.hpp>
#include <stan/mcmc/sampler.hpp>
#include <stan/mcmc/prob_grad_ad.hpp>
#include <stan/prob/distributions.hpp>

namespace test_model_namespace {

using std::vector;
using std::string;
using std::stringstream;
using stan::agrad::var;
using stan::mcmc::prob_grad_ad;
using stan::io::dump;
using std::istream;

typedef Eigen::Matrix<double,1,Eigen::Dynamic> vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,1> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;
typedef Eigen::Matrix<stan::agrad::var,1,Eigen::Dynamic> vector_v;
typedef Eigen::Matrix<stan::agrad::var,Eigen::Dynamic,1> row_vector_v;
typedef Eigen::Matrix<stan::agrad::var,Eigen::Dynamic,Eigen::Dynamic> matrix_v;

class test_model : public prob_grad_ad {
private:
    double mu;
    double sigma;
public:
    test_model(std::istream& in__)
        : prob_grad_ad::prob_grad_ad(0) {
        dump dump__(in__);
        int pos;
        std::vector<int> vals_i;
        std::vector<double> vals_r;
        assert(dump__.contains_r("mu"));
        vals_r = dump__.var_r_vals("mu");
        pos = 0;
        mu = vals_r[pos++];
        assert(dump__.contains_r("sigma"));
        vals_r = dump__.var_r_vals("sigma");
        pos = 0;
        sigma = vals_r[pos++];
        set_param_ranges();
    } // dump ctor

    void set_param_ranges() {
        _num_params_r = 0U;
        _param_ranges_i.clear();
        ++_num_params_r;
    }


    var log_prob(vector<var>& params_r__,
                 vector<int>& params_i__) {

        var lp(0.0);
        // model parameters
        stan::io::reader<var> in__(params_r__,params_i__);

        var y = in__.scalar_constrain(lp);

        // derived variables

        // model body
        lp += stan::prob::normal_log(y, mu, sigma);

        return lp;

    } // log_prob()

    void write_csv(std::vector<double>& params_r__,
                   std::vector<int>& params_i__,
                   std::ostream& o__) {
        stan::io::reader<double> in__(params_r__,params_i__);
        stan::io::csv_writer writer__(o__);
        double y = in__.scalar_constrain();
        writer__.write(y);
    }

}; // model

} // namespace

int main(int argc__, const char* argv__[]) {
    stan::io::cmd_line cmd(argc__,argv__);
    std::string data_file_path__ = cmd.val("data_file");
    std::fstream data_file__(data_file_path__.c_str(),std::fstream::in);
    test_model_namespace::test_model model(data_file__);
    data_file__.close();
}

