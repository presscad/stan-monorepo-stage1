##
# Build test executables
##

test/%$(EXE) : CXXFLAGS += $(CXXFLAGS_GTEST)
test/%$(EXE) : CPPFLAGS += $(CPPFLAGS_GTEST)
test/%$(EXE) : INC_FIRST += -I $(if $(STAN),$(STAN),.)
test/%$(EXE) : INC += $(INC_GTEST)

test/%$(EXE) : test/%.o $(GTEST)/src/gtest_main.cc $(GTEST)/src/gtest-all.o $(LIBSUNDIALS) $(MPI_TARGETS)
	$(LINK.cpp) $^ $(LDLIBS) $(OUTPUT_OPTION)

test/%.o : src/test/%.cpp
	@mkdir -p $(dir $@)
	$(COMPILE.cpp) $< $(OUTPUT_OPTION)

##
# Rule for generating dependencies.
##
DEPFLAGS = -MT $(patsubst src/test/%.d,test/%.o,$@) -MT $@ -MM -E -MG -MP -MF $@
src/test/%.d : CXXFLAGS += $(CXXFLAGS_GTEST)
src/test/%.d : CPPFLAGS += $(CPPFLAGS_GTEST)
src/test/%.d : INC += $(INC_GTEST)
src/test/%.d: src/test/%.cpp
	$(COMPILE.cpp) $(DEPFLAGS) $<

ifneq ($(filter test/%,$(MAKECMDGOALS)),)
-include $(patsubst test/%$(EXE),src/test/%.d,$(filter test/%,$(MAKECMDGOALS)))
endif

##
# static rule to link in libstanc.
# needed by subset of unit tests that test stan compiler
# all these tests are under stan/test/unit/lang
##
STANC_TESTS_HEADERS := $(shell find src/test/unit/lang -type f -name '*_test.cpp')
STANC_TESTS_O := $(patsubst src/%.cpp,%.o,$(STANC_TESTS_HEADERS))
STANC_TESTS := $(patsubst src/%.cpp,%$(EXE),$(STANC_TESTS_HEADERS))

# add additional dependency to libstanc.a
$(STANC_TESTS_O) : bin/libstanc.a
$(STANC_TESTS) : LDLIBS += $(LDLIBS_STANC)

# add additional dependency for function_signatures.h
stan/lang/ast/sigs/function_signatures_def.hpp : stan/lang/function_signatures.h


############################################################
##
# Target to verify header files within Stan has
# enough include calls
##
HEADER_TESTS := $(addsuffix -test,$(shell find src/stan -name '*.hpp' -type f))

ifeq ($(OS),Windows_NT)
  DEV_NULL = nul
else
  DEV_NULL = /dev/null
endif

.PHONY: HEADER_TESTS
%.hpp-test : %.hpp test/dummy.cpp
	$(COMPILE.cpp) -O0 -include $^ -o $(DEV_NULL)

test/dummy.cpp:
	@mkdir -p test
	@touch $@
	@echo "int main() {return 0;}" >> $@

.PHONY: test-headers
test-headers: $(HEADER_TESTS)

##
# Target to verify code generated Stan programs
# (.stan -> .hpp) are compilable
#
# Running:
# > make test/integration/compile_models
# will make sure everything in src/test/test-models/good/
# compiles
##
.PHONY: %.hpp-test
src/test/test-models/good/%.hpp-test : O = 0
src/test/test-models/good/%.hpp-test : src/test/test-models/good/%.hpp test/test-model-main.cpp
	$(COMPILE.cpp) -o $(DEV_NULL) -include $^

test/test-model-main.cpp:
	@mkdir -p test
	@touch $@
	@echo "int main() {" >> $@
	@echo "  stan::io::var_context *data = NULL;" >> $@
	@echo "  stan_model model(*data);" >> $@
	@echo >> $@
	@echo "  std::vector<stan::math::var> params;" >> $@
	@echo "  std::vector<double> x_r;" >> $@
	@echo "  std::vector<int> x_i;" >> $@
	@echo >> $@
	@echo "  model.log_prob<false, false>(params, x_i);" >> $@
	@echo "  model.log_prob<false, true>(params, x_i);" >> $@
	@echo "  model.log_prob<true, false>(params, x_i);" >> $@
	@echo "  model.log_prob<true, true>(params, x_i);" >> $@
	@echo "  model.log_prob<false, false>(x_r, x_i);" >> $@
	@echo "  model.log_prob<false, true>(x_r, x_i);" >> $@
	@echo "  model.log_prob<true, false>(x_r, x_i);" >> $@
	@echo "  model.log_prob<true, true>(x_r, x_i);" >> $@
	@echo >> $@
	@echo "  return 0;" >> $@
	@echo "}" >> $@
	@echo >> $@

##
# Adding a test for multiple translation units. If this fails,
# a new function is probably missing an inline
##

test/unit/multiple_translation_units%.o : CXX += -pipe
test/unit/libmultiple.so : LDFLAGS += -shared -fPIC

test/unit/libmultiple.so : test/unit/multiple_translation_units1.o test/unit/multiple_translation_units2.o $(MPI_TARGETS)
	$(LINK.cpp) $^ $(LDLIBS) $(OUTPUT_OPTION)

test/unit/multiple_translation_units_test$(EXE) : test/unit/libmultiple.so


############################################################
##
# Use the stanc compiler to generate C++ from Stan programs
##

.PRECIOUS: test/test-models/stanc$(EXE)
test/test-models/stanc$(EXE) : O = $(O_STANC)
test/test-models/stanc$(EXE) : LDLIBS += $(LDLIBS_STANC)
test/test-models/stanc$(EXE) : bin/libstanc.a

test/test-models/stanc$(EXE) : src/test/test-models/stanc.cpp bin/libstanc.a
	@mkdir -p $(dir $@)
	$(LINK.cpp) $^ $(LDLIBS) $(OUTPUT_OPTION)

TEST_MODELS := $(shell find src/test/test-models -type f -name '*.stan')
$(patsubst src/%.stan,%.hpp,$(TEST_MODELS)) : %.hpp : src/%.stan test/test-models/stanc$(EXE)
	@mkdir -p $(dir $@)
	$(WINE) test/test-models/stanc$(EXE) --o=$@ $<


##
# Generate C++ from Stan standalone functions
##
TEST_FUNCTIONS := $(shell find src/test/test-models -type f -name '*.stanfuncs')
$(patsubst src/%.stanfuncs,%.hpp,$(TEST_FUNCTIONS)) : %.hpp : src/%.stanfuncs test/test-models/stanc$(EXE)
	@mkdir -p $(dir $@)
	$(WINE) test/test-models/stanc$(EXE) --o=$@ $<

##
# src/test/unit/lang/stanc_helper_test.cpp requires files to be read-only.
##
.PHONY: change-file-permissions
change-file-permissions:
ifeq ($(OS),Windows_NT)
	attrib +r src\\test\\test-models\\good\\stanc_helper.stan
	attrib +r src\\test\\test-models\\bad\\stanc_helper.stan
	attrib +r src\\test\\test-models\\bad\\read_only
else
	chmod 444 src/test/test-models/*/stanc_helper.stan
	chmod 555 src/test/test-models/bad/read_only
endif

src/test/unit/lang/stanc_helper_test.cpp: change-file-permissions


##
# Add additional dependencies for tests that should translate Stan to hpp, but
# isn't included in the source using `#include`.
##
src/test/unit/lang/parser_generator_test.cpp: $(patsubst src/%.stan,%.hpp,$(shell find src/test/test-models/good/parser-generator -type f -name '*.stan'))
# src/test/unit/lang/reject/reject_func_call_generated_quantities_test.cpp: src/test/test-models/good/lang/reject_func_call_generated_quantities.hpp
# src/test/unit/lang/reject/reject_func_call_model_test.cpp: src/test/test-models/good/lang/reject_func_call_model.hpp
# src/test/unit/lang/reject/reject_func_call_transformed_data_test.cpp: src/test/test-models/good/lang/reject_func_call_transformed_data.hpp
# src/test/unit/lang/reject/reject_func_call_transformed_parameters_test.cpp: src/test/test-models/good/lang/reject_func_call_transformed_parameters.hpp
# src/test/unit/lang/reject/reject_generated_quantities_test.cpp: src/test/test-models/good/lang/reject_generated_quantities.hpp
# src/test/unit/lang/reject/reject_model_test.cpp: src/test/test-models/good/lang/reject_model.hpp
# src/test/unit/lang/reject/reject_mult_args_test.cpp: src/test/test-models/good/lang/reject_mult_args.hpp
# src/test/unit/lang/reject/reject_transformed_data_test.cpp: src/test/test-models/good/lang/reject_transformed_data.hpp
# src/test/unit/lang/reject/reject_transformed_parameters_test.cpp: src/test/test-models/good/lang/reject_transformed_parameters.hpp
# src/test/unit/lang/reject/print_reject_function_gq_test.cpp: src/test/test-models/good/lang/print_reject_function_gq.hpp
# src/test/unit/lang/reject/print_reject_function_model_test.cpp: src/test/test-models/good/lang/print_reject_function_model.hpp
# src/test/unit/lang/reject/print_reject_function_tparams_test.cpp: src/test/test-models/good/lang/print_reject_function_tparams.hpp
# src/test/unit/lang/reject/print_reject_function_tdata_test.cpp: src/test/test-models/good/lang/print_reject_function_tdata.hpp
# src/test/unit/lang/reject/print_reject_gq_test.cpp: src/test/test-models/good/lang/print_reject_gq_block.hpp
# src/test/unit/lang/reject/print_reject_model_test.cpp: src/test/test-models/good/lang/print_reject_model_block.hpp
# src/test/unit/lang/reject/print_reject_tparams_test.cpp: src/test/test-models/good/lang/print_reject_tparams_block.hpp
# src/test/unit/lang/reject/print_reject_tdata_test.cpp: src/test/test-models/good/lang/print_reject_tdata_block.hpp
# src/test/unit/mcmc/hmc/hamiltonians/base_hamiltonian_test.cpp: src/test/test-models/good/mcmc/hmc/hamiltonians/funnel.hpp
# src/test/unit/mcmc/hmc/hamiltonians/dense_e_metric_test.cpp: src/test/test-models/good/mcmc/hmc/hamiltonians/funnel.hpp
# src/test/unit/mcmc/hmc/hamiltonians/diag_e_metric_test.cpp: src/test/test-models/good/mcmc/hmc/hamiltonians/funnel.hpp
# src/test/unit/mcmc/hmc/hamiltonians/unit_e_metric_test.cpp: src/test/test-models/good/mcmc/hmc/hamiltonians/funnel.hpp
# src/test/unit/mcmc/hmc/hamiltonians/softabs_metric_test.cpp: src/test/test-models/good/mcmc/hmc/hamiltonians/funnel.hpp
# src/test/unit/mcmc/hmc/integrators/expl_leapfrog_test.cpp: src/test/test-models/good/mcmc/hmc/integrators/command.hpp
# src/test/unit/mcmc/hmc/integrators/expl_leapfrog2_test.cpp: src/test/test-models/good/mcmc/hmc/integrators/gauss.hpp
# src/test/unit/mcmc/hmc/integrators/impl_leapfrog_test.cpp: src/test/test-models/good/mcmc/hmc/integrators/command.hpp
# src/test/unit/mcmc/hmc/integrators/impl_leapfrog2_test.cpp: src/test/test-models/good/mcmc/hmc/integrators/gauss.hpp
# src/test/unit/mcmc/hmc/nuts/unit_e_nuts_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/nuts/softabs_nuts_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/nuts/instantiation_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/nuts_classic/instantiation_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/xhmc/unit_e_xhmc_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/xhmc/softabs_xhmc_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/mcmc/hmc/static_uniform/derived_static_uniform_test.cpp: src/test/test-models/good/mcmc/hmc/common/gauss.hpp
# src/test/unit/model/finite_diff_grad_test.cpp src/test/unit/model/grad_hess_log_prob_test.cpp src/test/unit/model/grad_tr_mat_times_hessian_test.cpp src/test/unit/model/gradient_dot_vector_test.cpp src/test/unit/model/gradient_test.cpp src/test/unit/model/hessian_test.cpp src/test/unit/model/hessian_times_vector_test.cpp src/test/unit/model/log_prob_grad_test.cpp src/test/unit/model/log_prob_propto_test.cpp src/test/unit/model/model_functional_test.cpp src/test/unit/model/test_gradients_test.cpp : src/test/test-models/good/model/valid.hpp
# src/test/unit/optimization/bfgs_linesearch_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/optimization/bfgs_minimizer_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/optimization/bfgs_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/optimization/bfgs_update_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/optimization/lbfgs_update_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/old_services/init/command_init_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/old_services/io/write_iteration_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/old_services/mcmc/sample_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/old_services/mcmc/warmup_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/old_services/optimize/do_bfgs_optimize_test.cpp: src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/diagnose/diagnose_test.cpp : src/test/test-models/good/services/test_lp.hpp
# src/test/unit/services/optimize/bfgs_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/optimize/lbfgs_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/optimize/newton_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/experimental/advi/fullrank_test.cpp src/test/unit/services/experimental/advi/meanfield_test.cpp : src/test/test-models/good/services/test_lp.hpp
# src/test/unit/services/sample/fixed_param_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_dense_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_dense_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_diag_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_diag_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_unit_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_unit_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_dense_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_dense_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_diag_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_diag_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_unit_e_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_static_unit_e_adapt_test.cpp : src/test/test-models/good/optimization/rosenbrock.hpp
# src/test/unit/services/sample/hmc_nuts_dense_inv_metric_test.cpp : src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/services/sample/hmc_nuts_diag_inv_metric_test.cpp : src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/services/sample/hmc_static_dense_inv_metric_test.cpp : src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/services/sample/hmc_static_diag_inv_metric_test.cpp : src/test/test-models/good/mcmc/hmc/common/gauss3D.hpp
# src/test/unit/services/sample/standalone_gqs_test.cpp : src/test/test-models/good/services/test_gq.hpp
# src/test/unit/services/sample/standalone_gqs_bad_test.cpp : src/test/test-models/good/services/test_gq2.hpp
# src/test/unit/services/sample/standalone_gqs_big_test.cpp : src/test/test-models/good/services/bym2_offset_only.hpp
# src/test/unit/services/util/generate_transitions_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/services/util/gq_writer_test.cpp : src/test/test-models/good/services/test_gq.hpp
# src/test/unit/services/util/initialize_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/services/util/run_adaptive_sampler_test.cpp src/test/unit/services/util/run_sampler_test.cpp: src/test/test-models/good/services/test_lp.hpp
# src/test/unit/services/util/mcmc_writer_test.cpp : src/test/test-models/good/services/test_lp.hpp
# src/test/unit/old_services/sample/mcmc_writer_test.cpp: src/test/test-models/good/io_example.hpp
# src/test/unit/variational/advi_univar_no_constraint_test.cpp: src/test/test-models/good/variational/univariate_no_constraint.hpp
# src/test/unit/variational/advi_univar_with_constraint_test.cpp: src/test/test-models/good/variational/univariate_with_constraint.hpp
# src/test/unit/variational/advi_multivar_no_constraint_test.cpp: src/test/test-models/good/variational/multivariate_no_constraint.hpp
# src/test/unit/variational/advi_multivar_with_constraint_test.cpp: src/test/test-models/good/variational/multivariate_with_constraint.hpp
# src/test/unit/variational/gradient_warn_test.cpp: src/test/test-models/good/variational/gradient_warn.hpp
# src/test/unit/variational/hier_logistic_test.cpp: src/test/test-models/good/variational/hier_logistic.hpp
# src/test/unit/variational/hier_logistic_cp_test.cpp: src/test/test-models/good/variational/hier_logistic_cp.hpp
# src/test/unit/variational/advi_messages_test.cpp:src/test/test-models/good/variational/univariate_no_constraint.hpp
# src/test/unit/variational/eta_adapt_fail_test.cpp:src/test/test-models/good/variational/eta_should_fail.hpp
# src/test/unit/variational/eta_adapt_big_test.cpp:src/test/test-models/good/variational/eta_should_be_big.hpp
# src/test/unit/variational/eta_adapt_small_test.cpp:src/test/test-models/good/variational/eta_should_be_small.hpp

# ##
# # Compile models depends on every model within
# # src/test/test-models/good/*.stan being able to
# # be code-generated to a *.hpp, then passed through
# # the compiler using the -fsyntax-only flag
# ##
# test/integration/compile_models$(EXE) : $(patsubst %.stan,%.hpp-test,$(shell find src/test/test-models/good -type f -name '*.stan'))

# ##
# # Same trick as above for models, but for standalone functions, using
# # "src/test/test-models/good-standalone-functions/*.stanfuncs"
# ##
# test/integration/compile_standalone_functions$(EXE) : $(patsubst %.stanfuncs,%.hpp-test,$(shell find src/test/test-models/good-standalone-functions -type f -name '*.stanfuncs'))


# test_name = $(shell echo $(1) | sed 's,_[0-9]\{5\},_test.hpp,g')

# ifneq (,$(filter test/% src/test/test-models/%.hpp,$(MAKECMDGOALS)))
#   -include test/test-models/stanc.d
# endif

# ifneq (,$(filter $(STANC_TESTS),$(MAKECMDGOALS)))
#   -include $(patsubst src/%.cpp,bin/%.d,$(TEMPLATE_INSTANTIATION_CPP))
# endif
