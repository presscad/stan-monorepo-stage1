TO DO FOR V1
=================================================

* discrete samplers (Matt)
  - Gibbs for small outcome sets
  - slice for larger outcome sets
  - what about multinomial with constraints?

* remaining doc
  - reference manual (Bob)
 - API doc (Daniel, Bob)
    + stan/gm
    + stan/math
    + stan/mcmc
    + stan/memory
    + stan/meta
    + stan/model
    + stan/prob
  - add acknowledgements section
    + Michael Betancourt

* distribution engineering (Daniel)
  - eliminate tabs from code
 - basic distro site

* speed tests relative to BUGS/JAGS

* disallow variable declarations ending with "__"
 

HOME PAGE
=================================================

* Download:
  - latest code tarball (named as such)
    (no git info, but everything else)
   + stan-src-1.0.0.tgz
   + created by 'make dist'

  - latest doc pdf (ditto)

    *stan-doc-1.0.pdf

  - older versions (with numbers)

  - executables
    + 
    + bin/stanc

* API doc online


* How to Cite Stan
  now: Arxiv paper NUTS, doc for Stan
  
* Groups




CLEANUP (ONGOING)
=================================================

* g++ 4.7 compiling bin/stanc, balking on some models

* get rid of (double,double) -> var functions

* make sure -a[x] parses as (-(a[x])) (old note to self)
  -- add example to doc, because (-a) is legal if a vector

* math/error_handling
  - generalize vector checks.

* const declarations wherever possible
  - very very painful at this late date
  - be careful that compiled code matches const declarations

* clean up dependencies
  - only include as much as necessary per file

* convert for loops with size bounds to appropriate iterators


Convergence Diagnostics, CODA-like object: mcmc_output
=================================================

* Object for collection of chains
  - like CODA object
  - store the samples
  - names of variables (dimensionalities?)

* Effective Sample Size (ESS)
  - variogram "second estimator" n_{eff}^{(2)}

* Smallest Posterior INtervals (SPIN)

* Split R-hat

* WAIC (?? wait until dust settles)
  - need p(y[i]|theta) for all "data" y[i]
  - just generate in "generated quantities" block; have all params
  - multivariate can be single point
  - binomial one or more points depending on interp


Stan-R
=================================================

* break out into own project with its own license
  - leave top of Stan BSD and flag this one w/o new project?

* Example call:
   fit <- rstan(model_file,inits, ....);

* simple process-level calls
  + compile model
  + dump data
  + dump inits
  + run model
  + load results

* built-in from Rcpp

* functions from Coda object

* attach.stan(fit)
  + print(fit)
  + traceplot(fit)
  + plot.stan(fit)
  + dump.stan(fit)
  + read.stan(file_path)

* access things from Convergence Diagnostics object



EXTENSIONS
=================================================

* build unit tests from the BUGS models that just check
  the gradients are right (this'll also cover parsing and
  being able to fire up the models)

* figure out way to have vari elements that are NOT on the stack
  - useful for numeric_limits<var>
  - stack_vari ==> vari ==> chainable
    local_vari ==^
    (stack_vari has operator new; local_vari uses dtor)

* convert memory for vari to singleton & allow thread locality
  for thread safety

* unit K-hyperball complement for stationary AR(K) parameters
  - what should the prior be?

* generate templated log_prob function so that you don't
  need to evaluate auto-dif when just evaluating function

* user model library
  - something we don't have to get too involved vetting
  - ideally things hard to do with other systems
  - or illustrate the unusual parts of our modeling language

* more matrix ops:
    left residuals:  A\b = inv(A) * b
    right residual:  b/A  = b * inv(A)
    matrix power:    A^n
    matrix elementwise power:  A.^x

* more functions
  - z_score()
  - 
  
* precompiled headers for model compilation speed

* auto testing of sampler
  - Cook/Gelman/Rubin-style interval tests
  - needs effective sample size calc to bound intervals
  - needs simulated parameters to test estimators
  - push ESS "measurement error" through the interval tests

* error/exception policy throughout
  - math

* add printf statement for debugging purposes
  - really format or just list params?

* control significant digits in output through command line

* stop NUTS from running away without coming back
 -- limit number of steps
    + command-line param
    + instrumenting NUTS loops (adaptation, leapfrog)
 -- limit time
    + start recording time at beginning, check loops inside
 -- bomb with report if exceed these steps
 -- print out adaptation phase step size 
 -- print out number of steps (average and sd?)
    (bring in Boost accumulator package)

* control decimal places in output 
  - set a variable on the writer or stream

* add special op for multivariate norm:
  -  wrapped_multiply(y,Sigma) 
     = y' * Sigma * y
     = SUM_{m in 1:K} SUM_{n in 1:K} y[m] * y[n] * Sigma[m,n]
  - check that my algebra's right
  - specialize to Cholesky factor instead of Sigma

* deal with autocorrelation model params where require
  all roots of 1 - SUM_i rho[i]**i to be within unit
  complex circle

* make sure std::less<T*> and std::swap<T*> 
  does right thing for our types (like var and vari), as
  these are used in "algorithms".

* use our arena-based alloc as STL allocator
  - http://www.cplusplus.com/reference/std/memory/allocator/
  - what do we need to do for dtor to work?

* Allow normal_log<true> and normal_log<false> to be accessed
  directly;

* Allow normal_log(y|0,1) as parser synonym for normal_log(y,0,1)

* Add matrix/vector/scalar operators to compiler
  - binary (*,/,+,-), unary (+,-)
  - translate down to our overloaded promotion-based lib
  - find operator for transpose? 

* more matrix tests (for all ops w. gradients)

* More matrix functions from Eigen:
  - norm()
  - squaredNorm()
  - lpNorm<1>
  - lpNorm<Eigen::Infinity>

* Watanabe's WAIC: Widely applicable information criterion

* Ben's implicit function idea -- iterative solver,
  analytic derivative

* smallest posterior interval (SPIn) as default, also central intervals

* triangular matrix type
  - how to implement in Eigen?
    + triangular view?

* symmetric matrix type 
  - how to implement in Eigen?  
  - what ops to allow? 
    + sets are symmetric
    + but this'll get products wrong as
      everything but diagonal will get set twice
 
* Cholesky factor type

* dot_self(x) == x' * x operation
  wrap_multiply(u,v) = u' * v * u

* special positive-definiteness-preserving operations
  - basic data type (or trait)
  - operations that preserve well-formedness, perhaps
    by fudging boundary conditions

* optimization
  - functor-based concept design with templates 
  - easily pluggable with log prob in model for MAP 

* convergence monitoring
  - R-hat
  - n.eff (variogram, at least)
  - mean and variance of samples (per chain & across)

* forward-mode simulation
  - use when nodes can be ordered and sampled with
    all parents in graphical model defined

* benchmarks
  - agrad vs. RAD/Sacado, CppAD, ... ?
  - stan vs. MCMCpack, R, BUGS, JAGS, OpenBUGS, ...

* compiler for R's linear model notation

* threading
  - rewrite memory arena as thread-local object
  - merging and monitoring several threads/processes

* interface to Python

* interface to MATLAB

* Riemannian manifold sampling
 - Girolami's method with auto-diff Hessians

* mapped distributions
  - foo(x|theta) ==> foo(xs|theta)
  - C style: x*, int size
  - iterator concept: (x.start(),x.end())
  - array concept: (x[n], x.size())

* special functions
  - inv(x) = 1/x
  - inv_square(x) = 1/(x * x)
  - dot_self(vector v);  dot_self(row_vector v);  
  - log_sum_exp_ratio(vector<double> log_ratios, 
                      vector<double> log_probs);
  - rank(v,s): number of components of v less than v[s]
  - ranked(v,s): s-th smallest component of v
  - interp_ln(e,v1,v2) from BUGS (whatever for?)
  
* random generation functions
  - rnorm(),...

* type inference & propagation
  - variable vs. constant
  - local/nuisance vs. written

* multiple imputation
  - can't do each leapfrog step
  - generated quantitities before leapfrogs

* warnings
  - a <- foo(theta) if LHS contains variable: overwrite var
  - a ~ foo(theta)  if LHS is complex expression: need Jacobian

* integer subtypes
  - integer(-inf,inf), count(1,inf), natural(0,inf)
  - boolean(0,1), categorical(1,K), ordinal(1,K),

* double subtypes
  - probability(0,1), correlation(-1,1)
  - positive(0,inf), negative(-inf,0)

* vector subtypes
  - ordered (vs. positive ordered)

* monitor/sampler interface
  - sampler, filter, aggregator, buffer
  - online means and variances
  - rHat, and split rHat
  - run in second process as we go?

* matrix slice and assign
  - index m
  - range-indexes :, a:, :b, a:b
  - e.g., matrix(M,N) m; vector(M) v;  m[,1] = v;
  
* conditionals
  - conditional expression
  - ternary op: cond ? x : y
  - if (cond) statement else if (cond) statement ... else statement;
  - while (cond) statement;
  - repeat statement until cond;
  
* multi-returns and array literals
  - (a,b,c) = foo();  // function returns array
  - (m,n,p) = (1,2,3);   // (1,2,3) is array literal

* multiple declarations
  - e.g., double a, b, c[N];

* declare and assign
  - e.g., double x = 5.0;
    double b[5];
    double a[5] = b; // odd, eh?
   
* full type prefix notation   
  - e.g.,  double[5] b;
           double[5] a;
           double[5] c <- a;
  - ugly with simplex, etc.
           simplex(5)[2] c <- ...

* extensions
  - declare file paths to #include
  - declare namespace usings
  - declare function sigs for parser

* ragged arrays
  - ready to use with vec<...<vec<x>...> pattern
  - not clear how to declare (follow C?)

* constant vari values
  - avoid placing on stack
  - how to deal with adjoints?
  - use for numeric traits
  - units 0 and 1 (scalar, vector, matrix)

* alternative distribution parameterizations
  - e.g., precision for (multi) normal
  - inverse_sqrt_gamma(...)

* subroutines
  - user-defined functions in StanGM
  - user-defined densities (how much to require?)

* compound op-assigns in StanGM
  - +=, *=, etc.

* complete math robustness and limits review
  - want domain boundaries to be right (usually
    -inf, 0 and inf, etc.)

* more diagnostics during warmup of where epsilon is going

* refactor finite diff derivative calcs to functor
 template <class F, typename S>
 bool finite_diffs(const vector<S>& x,
                   const F& f,
                   vector<S>& df_dx);

* restart from where command left off a la R2jags

* auto convergence monitoring -- just keep doubling (or other ratio)

* cut out last derivative step in leapfrog if not nec.
  - only saves if very small number of leapfrog steps

* precompiled headers to speed up model compiles
  - doesn't seem to help much

* speed measurement
  - to converge
  - time per effective sample once converged
  - time to 4 chains at 25 ESS/chain, rHat < 1.1 for all
    parameters theta[k] and theta[k]*theta[k]
  - discarding first half of samples too many if fast to converge

* 

* check each parameter shows up on LHS of ~
  - true check is run-time based on data, etc.

* allow +/- propto flag in densities in Stan-GM

* forward mode auto-dif
  - last revision 548: 
  - src/stan/agrad/ad.hpp

* bring back specialized auto-dif for densities
  - bring up to speed with new templates for densities & propto
  - last revision 549:  ag_distributions.hpp & test 

* whole new auto-dif.  stack consists of entries per expression
  containing
  - adjoint for expression
  - for each argument
    + partial 
    + ptr to subexpression  
  - less space for constants, equal for unary, more for binary+
  - no virtual ops

* Stan safe mode to compile BUGS/JAGS-compliant models

* Speed test pass-by-const-ref and pass-by-val for stan::agrad::var

* could multi-thread agrad by copying all code; use var<1>, var<2>,
  etc., with var typedefed to var<1>.  Each would then have its
  own memory pool to read from.  How to specify by client?  Could
  generate templated code
  

Longer-Term Ideas
=================================================

* code gen auto-dif
  - just for Stan GM models

* lazy init for var
  - if vari* is accessed and empty, return new var(0) equiv.
  - can't afford test to see if it's defined

* elim stan/maths/matrix lib by adding implicit ctor
  for Matrix<var,...> based on Matrix<double,...>

* could template stan::agrad::var with <unsigned int n>
  indicating thread.  typedef var to var<0>
  - runs in multiple threads with no speed overhead
  - code bloat multiples code size by # of threads
    + may in turn slow down everything due to mem traffic

* some notion of momentum for discrete variables a la HMC
  for continuous variables (at least accelerate metropolis-hastings)
  some densities generalize 

* blocking updates
  - only update subset of parameters
  - specify blocks in program?
  - allow Gibbs on some variables
  - split HMC into blocks (aka batches)
  - in the limit do conditional with HMC!

Stan GM MANUAL
=================================================

1.  Intro
2.  Modeling Language
    a.  basic organization
    b.  variable types
    c.  expressions: operator precedence, associativity
    d.  statements: precedence, associativity
    e.  programs
    f.  full BNF
3.  Reference
    a.  special functions
    b.  distributions
    c.  built-in variable transforms
4.  Stan Command Line 
5.  Extending Stan
6.  C++ Code Generated
    a.  auto-dif
A.  Examples 
    References

++ doc how to do WAIC for RATS
   generated quantities {
   for (i in 1:I) for (j in 1:J) ll_y[i,j] <- normal_log(y[i,j]...)


MODELS
=================================================

http://stat-athens.aueb.gr/~jbn/winbugs_book/
