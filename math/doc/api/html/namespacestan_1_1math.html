<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Stan: stan::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stan
   &#160;<span id="projectnumber">2.6.1</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stan::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrices and templated mathematical functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1math_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math_1_1policies"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1policies.html">policies</a></td></tr>
<tr class="memdesc:namespacestan_1_1math_1_1policies"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extending boost functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01stan_1_1agrad_1_1var_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; stan::agrad::var, R, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization of <a class="el" href="math_2matrix_2_l_d_l_t__factor_8hpp.html">src/stan/math/matrix/LDLT_factor.hpp</a> for <a class="el" href="classstan_1_1agrad_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::agrad::var</a> which can be used with all the *_ldlt functions.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01stan_1_1agrad_1_1var_00_01_r_00_01_c_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01stan_1_1agrad_1_1var_01_4.html">coupled_ode_system&lt; F, double, stan::agrad::var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ODE system for known initial values and unknown parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01stan_1_1agrad_1_1var_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1agrad_1_1var_00_01double_01_4.html">coupled_ode_system&lt; F, stan::agrad::var, double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ODE system for unknown initial values and known parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1agrad_1_1var_00_01double_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1agrad_1_1var_00_01stan_1_1agrad_1_1var_01_4.html">coupled_ode_system&lt; F, stan::agrad::var, stan::agrad::var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ode system for unknown intial values and unknown parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1agrad_1_1var_00_01stan_1_1agrad_1_1var_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct.html">promote_scalar_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_t_01_4.html">promote_scalar_struct&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_struct&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for converting a convertible type.  <a href="structstan_1_1math_1_1promote__scalar__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a container whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1array__builder.html">array_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for building up arrays in an expression (rather than in statements) using an argumentchaining <a class="el" href="structstan_1_1math_1_1array__builder.html#a085e0190d7a41c4e33bfa9f542b1d62a">add()</a> method and a getter method <a class="el" href="structstan_1_1math_1_1array__builder.html#a725410c59aa282c6b23c52fd252aa1a3">array()</a> to return the result.  <a href="structstan_1_1math_1_1array__builder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">common_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_00_01_eiged8accfa00e73f240c58ad02ac582ba93.html">common_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; T, R, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> is a thin wrapper on Eigen::LDLT to allow for reusing factorizations and efficient autodiff of things like log determinants and solutions to linear systems.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01_r_00_01_c_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html">index_type&lt; Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1index__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html">value_type&lt; Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1value__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00-1_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S,-1,-1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00-1_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00-1_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S, 1,-1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00-1_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00_011_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S,-1, 1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00_011_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1e90c042d64d8c3a6b9383f570932df58.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a matrix whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1e90c042d64d8c3a6b9383f570932df58.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a vector whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a row vector whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter.html">promoter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_t_00_01_t_01_4.html">promoter&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_f_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; F &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_f_00_01_r_00_01_c_01_4_00_01_eigen_1_142b48fda94601374e41a81325f3f7b84.html">promoter&lt; Eigen::Matrix&lt; F, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_eigen_1_12d7fadf0560f1f2f3abc5388b7666f9c.html">promoter&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute child type of T.  <a href="structstan_1_1math_1_1child__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html">child_type&lt; T_struct&lt; T_child &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for template classes / structs.  <a href="structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="structstan_1_1math_1_1index__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01const_01_t_01_4.html">index_type&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for metaprogram to compute the type of indexes used in a constant container type.  <a href="structstan_1_1math_1_1index__type_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01std_1_1vector_3_01_t_01_4_01_4.html">index_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="structstan_1_1math_1_1index__type_3_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type.html">value_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="structstan_1_1math_1_1value__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01const_01_t_01_4.html">value_type&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for metaprogram to compute the type of values stored in a constant container.  <a href="structstan_1_1math_1_1value__type_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01std_1_1vector_3_01_t_01_4_01_4.html">value_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of values stored in a standard vector.  <a href="structstan_1_1math_1_1value__type_3_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__observer.html">coupled_ode_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer for the coupled states.  <a href="structstan_1_1math_1_1coupled__ode__observer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system.html">coupled_ode_system</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for a coupled ordinary differential equation system, which adds sensitivities to the base system.  <a href="structstan_1_1math_1_1coupled__ode__system.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01double_01_4.html">coupled_ode_system&lt; F, double, double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ode system for known initial values and known parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01double_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type.html">store_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01double_01_4.html">store_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01int_01_4.html">store_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type.html">pass_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01double_01_4.html">pass_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01int_01_4.html">pass_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view.html">seq_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">seq_view&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_t_01_4_01_4.html">seq_view&lt; T, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01std_1_1vector_3_01_t_01_4_01_4_01_4.html">seq_view&lt; T, std::vector&lt; std::vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01double_00_01std_1_1vector_3_01int_01_4_01_4.html">seq_view&lt; double, std::vector&lt; int &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae7989b1f96eb2793fa94b0f373ee29a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a><br class="typebreak"/>
&lt; Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae7989b1f96eb2793fa94b0f373ee29a8">size_type</a></td></tr>
<tr class="memdesc:ae7989b1f96eb2793fa94b0f373ee29a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for sizes and indexes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with double e.  <a href="#ae7989b1f96eb2793fa94b0f373ee29a8">More...</a><br/></td></tr>
<tr class="separator:ae7989b1f96eb2793fa94b0f373ee29a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a24821b475ee296830ebac12f70460"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a></td></tr>
<tr class="memdesc:ac1a24821b475ee296830ebac12f70460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for matrix of double values.  <a href="#ac1a24821b475ee296830ebac12f70460">More...</a><br/></td></tr>
<tr class="separator:ac1a24821b475ee296830ebac12f70460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7ab54df86be3a3d61e58623c210d86"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c7ab54df86be3a3d61e58623c210d86">vector_d</a></td></tr>
<tr class="memdesc:a0c7ab54df86be3a3d61e58623c210d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (column) vector of double values.  <a href="#a0c7ab54df86be3a3d61e58623c210d86">More...</a><br/></td></tr>
<tr class="separator:a0c7ab54df86be3a3d61e58623c210d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105e584e4ed2d24a5c3a40df4d94697"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac105e584e4ed2d24a5c3a40df4d94697">row_vector_d</a></td></tr>
<tr class="memdesc:ac105e584e4ed2d24a5c3a40df4d94697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (row) vector of double values.  <a href="#ac105e584e4ed2d24a5c3a40df4d94697">More...</a><br/></td></tr>
<tr class="separator:ac105e584e4ed2d24a5c3a40df4d94697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae16452cc0da4c7b77be53de0fcf3eed9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae16452cc0da4c7b77be53de0fcf3eed9">add_initial_values</a> (const std::vector&lt; <a class="el" href="classstan_1_1agrad_1_1var.html">stan::agrad::var</a> &gt; &amp;y0, std::vector&lt; std::vector&lt; <a class="el" href="classstan_1_1agrad_1_1var.html">stan::agrad::var</a> &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:ae16452cc0da4c7b77be53de0fcf3eed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the state derived from the coupled system in the with the original initial state.  <a href="#ae16452cc0da4c7b77be53de0fcf3eed9">More...</a><br/></td></tr>
<tr class="separator:ae16452cc0da4c7b77be53de0fcf3eed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeebafad688145fc64353e4f455d014bd">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aeebafad688145fc64353e4f455d014bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#aeebafad688145fc64353e4f455d014bd">More...</a><br/></td></tr>
<tr class="separator:aeebafad688145fc64353e4f455d014bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a108d489a4a749c8e429b519d9e26c157">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:a108d489a4a749c8e429b519d9e26c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#a108d489a4a749c8e429b519d9e26c157">More...</a><br/></td></tr>
<tr class="separator:a108d489a4a749c8e429b519d9e26c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c23bfe9ebcb5747ed175a59b2182072">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a7c23bfe9ebcb5747ed175a59b2182072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#a7c23bfe9ebcb5747ed175a59b2182072">More...</a><br/></td></tr>
<tr class="separator:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f55be80da8ff729d5850c653d2b28d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3f55be80da8ff729d5850c653d2b28d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3f55be80da8ff729d5850c653d2b28d">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg)</td></tr>
<tr class="memdesc:ae3f55be80da8ff729d5850c653d2b28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#ae3f55be80da8ff729d5850c653d2b28d">More...</a><br/></td></tr>
<tr class="separator:ae3f55be80da8ff729d5850c653d2b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9bcb1af5657f92ccadf5204fc43377fd">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a9bcb1af5657f92ccadf5204fc43377fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="#a9bcb1af5657f92ccadf5204fc43377fd">More...</a><br/></td></tr>
<tr class="separator:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aacf5709c614035ef60053a348e18554c">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:aacf5709c614035ef60053a348e18554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="#aacf5709c614035ef60053a348e18554c">More...</a><br/></td></tr>
<tr class="separator:aacf5709c614035ef60053a348e18554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b2630385b99ef7045818ba8fe2a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add7b2630385b99ef7045818ba8fe2a97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add7b2630385b99ef7045818ba8fe2a97">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:add7b2630385b99ef7045818ba8fe2a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="#add7b2630385b99ef7045818ba8fe2a97">More...</a><br/></td></tr>
<tr class="separator:add7b2630385b99ef7045818ba8fe2a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a8690ee903eea7e5847e4d93483f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a309a8690ee903eea7e5847e4d93483f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a309a8690ee903eea7e5847e4d93483f4">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg)</td></tr>
<tr class="memdesc:a309a8690ee903eea7e5847e4d93483f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="#a309a8690ee903eea7e5847e4d93483f4">More...</a><br/></td></tr>
<tr class="separator:a309a8690ee903eea7e5847e4d93483f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b3c1ad17fc5567f1599fa9d0a218620">check_cholesky_factor</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor.  <a href="#a2b3c1ad17fc5567f1599fa9d0a218620">More...</a><br/></td></tr>
<tr class="separator:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f24b6f8e2a52523ae37a7ff2664e9b5">check_cholesky_factor_corr</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor of a correlation matrix.  <a href="#a3f24b6f8e2a52523ae37a7ff2664e9b5">More...</a><br/></td></tr>
<tr class="separator:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0a60f741f97efac53254839f24ff8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , int R, int C&gt; </td></tr>
<tr class="memitem:a16b0a60f741f97efac53254839f24ff8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16b0a60f741f97efac53254839f24ff8">check_column_index</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, R, C &gt; &amp;y, const size_t i)</td></tr>
<tr class="memdesc:a16b0a60f741f97efac53254839f24ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is a valid column of the matrix.  <a href="#a16b0a60f741f97efac53254839f24ff8">More...</a><br/></td></tr>
<tr class="separator:a16b0a60f741f97efac53254839f24ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41204c48d930b46e81329d8b00a0793e"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a41204c48d930b46e81329d8b00a0793e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a41204c48d930b46e81329d8b00a0793e">check_corr_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a41204c48d930b46e81329d8b00a0793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid correlation matrix.  <a href="#a41204c48d930b46e81329d8b00a0793e">More...</a><br/></td></tr>
<tr class="separator:a41204c48d930b46e81329d8b00a0793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb915b09e2e60dd76885b6d68655790c"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aeb915b09e2e60dd76885b6d68655790c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeb915b09e2e60dd76885b6d68655790c">check_cov_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:aeb915b09e2e60dd76885b6d68655790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid covariance matrix.  <a href="#aeb915b09e2e60dd76885b6d68655790c">More...</a><br/></td></tr>
<tr class="separator:aeb915b09e2e60dd76885b6d68655790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7547b05717280b1cc041309803ec797d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a7547b05717280b1cc041309803ec797d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7547b05717280b1cc041309803ec797d">check_ldlt_factor</a> (const char *function, const char *name, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;A)</td></tr>
<tr class="memdesc:a7547b05717280b1cc041309803ec797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the argument is a valid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code>.  <a href="#a7547b05717280b1cc041309803ec797d">More...</a><br/></td></tr>
<tr class="separator:a7547b05717280b1cc041309803ec797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe34ba3113cc8f10f179873edb9b60ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:afe34ba3113cc8f10f179873edb9b60ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afe34ba3113cc8f10f179873edb9b60ed">check_lower_triangular</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:afe34ba3113cc8f10f179873edb9b60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is lower triangular.  <a href="#afe34ba3113cc8f10f179873edb9b60ed">More...</a><br/></td></tr>
<tr class="separator:afe34ba3113cc8f10f179873edb9b60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1149504bbf29d464f23508ca5eccc0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa1149504bbf29d464f23508ca5eccc0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1149504bbf29d464f23508ca5eccc0a">check_matching_dims</a> (const char *function, const char *name1, const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;y1, const char *name2, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;y2)</td></tr>
<tr class="memdesc:aa1149504bbf29d464f23508ca5eccc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <a href="#aa1149504bbf29d464f23508ca5eccc0a">More...</a><br/></td></tr>
<tr class="separator:aa1149504bbf29d464f23508ca5eccc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a52ba893fcf6fc650e992c13d41fbc3ae">check_matching_sizes</a> (const char *function, const char *name1, const T_y1 &amp;y1, const char *name2, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if two structures at the same size.  <a href="#a52ba893fcf6fc650e992c13d41fbc3ae">More...</a><br/></td></tr>
<tr class="separator:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3cfbb4f09fe34b9ece32be051f16ce66">check_multiplicable</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrices can be multiplied.  <a href="#a3cfbb4f09fe34b9ece32be051f16ce66">More...</a><br/></td></tr>
<tr class="separator:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a97c3c23033e47a923ed5ce26a4deeba5">check_nonzero_size</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a97c3c23033e47a923ed5ce26a4deeba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix/vector is of non-zero size.  <a href="#a97c3c23033e47a923ed5ce26a4deeba5">More...</a><br/></td></tr>
<tr class="separator:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7b212a4431aeedca59b2e94c84f788"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2a7b212a4431aeedca59b2e94c84f788"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2a7b212a4431aeedca59b2e94c84f788">check_ordered</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a2a7b212a4431aeedca59b2e94c84f788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is sorted into strictly increasing order.  <a href="#a2a7b212a4431aeedca59b2e94c84f788">More...</a><br/></td></tr>
<tr class="separator:a2a7b212a4431aeedca59b2e94c84f788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e7669a804e68bc9d39ecd06318b23"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af55e7669a804e68bc9d39ecd06318b23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af55e7669a804e68bc9d39ecd06318b23">check_ordered</a> (const char *function, const char *name, const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:af55e7669a804e68bc9d39ecd06318b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is sorted into strictly increasing order.  <a href="#af55e7669a804e68bc9d39ecd06318b23">More...</a><br/></td></tr>
<tr class="separator:af55e7669a804e68bc9d39ecd06318b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0133fd07702f5253126a385703b7d73"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ac0133fd07702f5253126a385703b7d73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0133fd07702f5253126a385703b7d73">check_pos_definite</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:ac0133fd07702f5253126a385703b7d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified square, symmetric matrix is positive definite.  <a href="#ac0133fd07702f5253126a385703b7d73">More...</a><br/></td></tr>
<tr class="separator:ac0133fd07702f5253126a385703b7d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa26244f58d5a4dfd49181b39d9b4569b">check_pos_semidefinite</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:aa26244f58d5a4dfd49181b39d9b4569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is positive definite.  <a href="#aa26244f58d5a4dfd49181b39d9b4569b">More...</a><br/></td></tr>
<tr class="separator:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f00a8c0f07c5a82145a14712437673"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a87f00a8c0f07c5a82145a14712437673"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87f00a8c0f07c5a82145a14712437673">check_positive_ordered</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a87f00a8c0f07c5a82145a14712437673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector contains non-negative values and is sorted into strictly increasing order.  <a href="#a87f00a8c0f07c5a82145a14712437673">More...</a><br/></td></tr>
<tr class="separator:a87f00a8c0f07c5a82145a14712437673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4dcac328824f71f31d6861b8610ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adcd4dcac328824f71f31d6861b8610ee">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a>, const int index, const int nested_level, const char *error_msg)</td></tr>
<tr class="memdesc:adcd4dcac328824f71f31d6861b8610ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#adcd4dcac328824f71f31d6861b8610ee">More...</a><br/></td></tr>
<tr class="separator:adcd4dcac328824f71f31d6861b8610ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8822ad6a9b8706465e8e1f90c336e3c2">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a>, const int index, const char *error_msg)</td></tr>
<tr class="memdesc:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#a8822ad6a9b8706465e8e1f90c336e3c2">More...</a><br/></td></tr>
<tr class="separator:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7e76ffb67d3c6c6c225b0ba7b991f449">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a>, const int index)</td></tr>
<tr class="memdesc:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#a7e76ffb67d3c6c6c225b0ba7b991f449">More...</a><br/></td></tr>
<tr class="separator:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb080867499e68f688b0dcb5c8f4e061"><td class="memTemplParams" colspan="2">template&lt;typename T_y , int R, int C&gt; </td></tr>
<tr class="memitem:acb080867499e68f688b0dcb5c8f4e061"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acb080867499e68f688b0dcb5c8f4e061">check_row_index</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, R, C &gt; &amp;y, size_t i)</td></tr>
<tr class="memdesc:acb080867499e68f688b0dcb5c8f4e061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is a valid row of the matrix.  <a href="#acb080867499e68f688b0dcb5c8f4e061">More...</a><br/></td></tr>
<tr class="separator:acb080867499e68f688b0dcb5c8f4e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6affd19d4999c427291a2bbb07bce304"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a6affd19d4999c427291a2bbb07bce304"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6affd19d4999c427291a2bbb07bce304">check_simplex</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="memdesc:a6affd19d4999c427291a2bbb07bce304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is simplex.  <a href="#a6affd19d4999c427291a2bbb07bce304">More...</a><br/></td></tr>
<tr class="separator:a6affd19d4999c427291a2bbb07bce304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa547146eaac690e79a611e50a6dffb4d"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:aa547146eaac690e79a611e50a6dffb4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa547146eaac690e79a611e50a6dffb4d">check_size_match</a> (const char *function, const char *name_i, T_size1 i, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:aa547146eaac690e79a611e50a6dffb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <a href="#aa547146eaac690e79a611e50a6dffb4d">More...</a><br/></td></tr>
<tr class="separator:aa547146eaac690e79a611e50a6dffb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c66b22fce7bd878b687d550299eb248"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a0c66b22fce7bd878b687d550299eb248"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c66b22fce7bd878b687d550299eb248">check_size_match</a> (const char *function, const char *expr_i, const char *name_i, T_size1 i, const char *expr_j, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:a0c66b22fce7bd878b687d550299eb248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <a href="#a0c66b22fce7bd878b687d550299eb248">More...</a><br/></td></tr>
<tr class="separator:a0c66b22fce7bd878b687d550299eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d5ef4f11dbce1a670766034b416339"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a30d5ef4f11dbce1a670766034b416339"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a30d5ef4f11dbce1a670766034b416339">check_spsd_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a30d5ef4f11dbce1a670766034b416339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite.  <a href="#a30d5ef4f11dbce1a670766034b416339">More...</a><br/></td></tr>
<tr class="separator:a30d5ef4f11dbce1a670766034b416339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a94cfaa76ca5bc3f0ea5ad1d5b9f80727">check_square</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is square.  <a href="#a94cfaa76ca5bc3f0ea5ad1d5b9f80727">More...</a><br/></td></tr>
<tr class="separator:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed873db07e833c14413c319a5bb9837"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed873db07e833c14413c319a5bb9837"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7ed873db07e833c14413c319a5bb9837">check_std_vector_index</a> (const char *function, const char *name, const std::vector&lt; T &gt; &amp;y, int i)</td></tr>
<tr class="memdesc:a7ed873db07e833c14413c319a5bb9837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is valid in std vector.  <a href="#a7ed873db07e833c14413c319a5bb9837">More...</a><br/></td></tr>
<tr class="separator:a7ed873db07e833c14413c319a5bb9837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57384e961806a959d95a5444fd8d7190"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a57384e961806a959d95a5444fd8d7190"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57384e961806a959d95a5444fd8d7190">check_symmetric</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a57384e961806a959d95a5444fd8d7190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is symmetric.  <a href="#a57384e961806a959d95a5444fd8d7190">More...</a><br/></td></tr>
<tr class="separator:a57384e961806a959d95a5444fd8d7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e15ece9efbe2751549da6a598964c9"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a14e15ece9efbe2751549da6a598964c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a14e15ece9efbe2751549da6a598964c9">check_unit_vector</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_prob, Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="memdesc:a14e15ece9efbe2751549da6a598964c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is unit vector.  <a href="#a14e15ece9efbe2751549da6a598964c9">More...</a><br/></td></tr>
<tr class="separator:a14e15ece9efbe2751549da6a598964c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b78e5ddf65db13aaa65a6c58205fbf2">check_vector</a> (const char *function, const char *name, const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is either a row vector or column vector.  <a href="#a5b78e5ddf65db13aaa65a6c58205fbf2">More...</a><br/></td></tr>
<tr class="separator:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abb591fca3d88d2a5d587ce6172b62bf4">validate_non_negative_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="separator:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34583d3983ee4d61d09004ce3e278250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34583d3983ee4d61d09004ce3e278250">out_of_range</a> (const char *function, const int <a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a>, const int index, const char *msg1=&quot;&quot;, const char *msg2=&quot;&quot;)</td></tr>
<tr class="memdesc:a34583d3983ee4d61d09004ce3e278250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an out_of_range exception with a consistently formatted message.  <a href="#a34583d3983ee4d61d09004ce3e278250">More...</a><br/></td></tr>
<tr class="separator:a34583d3983ee4d61d09004ce3e278250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d53b31b377bc3fc120d6469af3d99e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a16d53b31b377bc3fc120d6469af3d99e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16d53b31b377bc3fc120d6469af3d99e">check_bounded</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high)</td></tr>
<tr class="memdesc:a16d53b31b377bc3fc120d6469af3d99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the value is between the low and high values, inclusively.  <a href="#a16d53b31b377bc3fc120d6469af3d99e">More...</a><br/></td></tr>
<tr class="separator:a16d53b31b377bc3fc120d6469af3d99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6b6ab798e2f2a2ffad6b244efab0a58f">check_consistent_size</a> (const char *function, const char *name, const T &amp;x, size_t expected_size)</td></tr>
<tr class="memdesc:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x is consistent, which is defined to be <code>expected_size</code> if x is a vector or 1 if x is not a vector.  <a href="#a6b6ab798e2f2a2ffad6b244efab0a58f">More...</a><br/></td></tr>
<tr class="separator:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e8b8fb2cc649fc1f34e75d0b1fe2ca3">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2)</td></tr>
<tr class="memdesc:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1 is consistent with x2.  <a href="#a8e8b8fb2cc649fc1f34e75d0b1fe2ca3">More...</a><br/></td></tr>
<tr class="separator:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fa5d10851fe1307ed7a0ffb768ff861">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const char *name3, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1, x2, and x3 are consistent.  <a href="#a2fa5d10851fe1307ed7a0ffb768ff861">More...</a><br/></td></tr>
<tr class="separator:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a817ff4687b2d9d98f7f7bf82e9286266">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const char *name3, const T3 &amp;x3, const char *name4, const T4 &amp;x4)</td></tr>
<tr class="memdesc:a817ff4687b2d9d98f7f7bf82e9286266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1, x2, x3, and x4 are consistent.  <a href="#a817ff4687b2d9d98f7f7bf82e9286266">More...</a><br/></td></tr>
<tr class="separator:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_eq &gt; </td></tr>
<tr class="memitem:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1d8cfae284cdae1bb7e83d2a136f9a04">check_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_eq &amp;eq)</td></tr>
<tr class="memdesc:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is equal to <code>eq</code>.  <a href="#a1d8cfae284cdae1bb7e83d2a136f9a04">More...</a><br/></td></tr>
<tr class="separator:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf014e7733b17748049ccc5f3565de3"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a5bf014e7733b17748049ccc5f3565de3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5bf014e7733b17748049ccc5f3565de3">check_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a5bf014e7733b17748049ccc5f3565de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is finite.  <a href="#a5bf014e7733b17748049ccc5f3565de3">More...</a><br/></td></tr>
<tr class="separator:a5bf014e7733b17748049ccc5f3565de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad60ac97b8f74b7c5ce2feb4bdb9e09e0">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low)</td></tr>
<tr class="memdesc:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is strictly greater than <code>low</code>.  <a href="#ad60ac97b8f74b7c5ce2feb4bdb9e09e0">More...</a><br/></td></tr>
<tr class="separator:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5b19f8930c14681349d8444142487e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:a3d5b19f8930c14681349d8444142487e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d5b19f8930c14681349d8444142487e">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low)</td></tr>
<tr class="memdesc:a3d5b19f8930c14681349d8444142487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is greater or equal than <code>low</code>.  <a href="#a3d5b19f8930c14681349d8444142487e">More...</a><br/></td></tr>
<tr class="separator:a3d5b19f8930c14681349d8444142487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab225792149dceaec443ce09b93f8744"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:aab225792149dceaec443ce09b93f8744"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab225792149dceaec443ce09b93f8744">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:aab225792149dceaec443ce09b93f8744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is strictly less than <code>high</code>.  <a href="#aab225792149dceaec443ce09b93f8744">More...</a><br/></td></tr>
<tr class="separator:aab225792149dceaec443ce09b93f8744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dd0895901bf876eca824b41f04003"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:a5e9dd0895901bf876eca824b41f04003"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e9dd0895901bf876eca824b41f04003">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:a5e9dd0895901bf876eca824b41f04003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>.  <a href="#a5e9dd0895901bf876eca824b41f04003">More...</a><br/></td></tr>
<tr class="separator:a5e9dd0895901bf876eca824b41f04003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6be100befb6d08504cf5af8440b236"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7a6be100befb6d08504cf5af8440b236"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a6be100befb6d08504cf5af8440b236">check_nonnegative</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a7a6be100befb6d08504cf5af8440b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is non-negative.  <a href="#a7a6be100befb6d08504cf5af8440b236">More...</a><br/></td></tr>
<tr class="separator:a7a6be100befb6d08504cf5af8440b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7942532ef8f89cee24af75a383835ee1"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7942532ef8f89cee24af75a383835ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7942532ef8f89cee24af75a383835ee1">check_not_nan</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a7942532ef8f89cee24af75a383835ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is not <code>NaN</code>.  <a href="#a7942532ef8f89cee24af75a383835ee1">More...</a><br/></td></tr>
<tr class="separator:a7942532ef8f89cee24af75a383835ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814694b1125e641ca7b2e7269c82f966"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a814694b1125e641ca7b2e7269c82f966"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a814694b1125e641ca7b2e7269c82f966">check_positive</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a814694b1125e641ca7b2e7269c82f966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive.  <a href="#a814694b1125e641ca7b2e7269c82f966">More...</a><br/></td></tr>
<tr class="separator:a814694b1125e641ca7b2e7269c82f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0725693b09e454f5c8327ac89cf0245"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af0725693b09e454f5c8327ac89cf0245"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af0725693b09e454f5c8327ac89cf0245">check_positive_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:af0725693b09e454f5c8327ac89cf0245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive and finite.  <a href="#af0725693b09e454f5c8327ac89cf0245">More...</a><br/></td></tr>
<tr class="separator:af0725693b09e454f5c8327ac89cf0245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe1398a136f3dc36d246a2ea747500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6fe1398a136f3dc36d246a2ea747500">check_positive_size</a> (const char *function, const char *name, const char *expr, const int <a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size</a>)</td></tr>
<tr class="memdesc:ac6fe1398a136f3dc36d246a2ea747500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>size</code> is positive.  <a href="#ac6fe1398a136f3dc36d246a2ea747500">More...</a><br/></td></tr>
<tr class="separator:ac6fe1398a136f3dc36d246a2ea747500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4764556637084eee528b45d8eaa767"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeb4764556637084eee528b45d8eaa767">abs</a> (double x)</td></tr>
<tr class="memdesc:aeb4764556637084eee528b45d8eaa767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return floating-point absolute value.  <a href="#aeb4764556637084eee528b45d8eaa767">More...</a><br/></td></tr>
<tr class="separator:aeb4764556637084eee528b45d8eaa767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec93b560b654740be65de81d6f348cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ec93b560b654740be65de81d6f348cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ec93b560b654740be65de81d6f348cc">as_bool</a> (const T x)</td></tr>
<tr class="memdesc:a3ec93b560b654740be65de81d6f348cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <a href="#a3ec93b560b654740be65de81d6f348cc">More...</a><br/></td></tr>
<tr class="separator:a3ec93b560b654740be65de81d6f348cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebfb3835848bd8550192cd5e090d3b5a">bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:aebfb3835848bd8550192cd5e090d3b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_first\_kind}(v,x) = \begin{cases} J_v(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_251.png"/>
</p>
  <a href="#aebfb3835848bd8550192cd5e090d3b5a">More...</a><br/></td></tr>
<tr class="separator:aebfb3835848bd8550192cd5e090d3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a645ce13c6454913ec39be807751604dc">bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:a645ce13c6454913ec39be807751604dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_second\_kind}(v,x) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ Y_v(x) &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_255.png"/>
</p>
  <a href="#a645ce13c6454913ec39be807751604dc">More...</a><br/></td></tr>
<tr class="separator:a645ce13c6454913ec39be807751604dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add2a043f562537b8cc57bb35780ac5b5">binary_log_loss</a> (const int y, const T y_hat)</td></tr>
<tr class="memdesc:add2a043f562537b8cc57bb35780ac5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log loss function for binary classification with specified reference and response values.  <a href="#add2a043f562537b8cc57bb35780ac5b5">More...</a><br/></td></tr>
<tr class="separator:add2a043f562537b8cc57bb35780ac5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_n &gt; </td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_N, T_n &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27dad23d38c6d5e74c65e7571c70272e">binomial_coefficient_log</a> (const T_N N, const T_n n)</td></tr>
<tr class="memdesc:a27dad23d38c6d5e74c65e7571c70272e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the binomial coefficient for the specified arguments.  <a href="#a27dad23d38c6d5e74c65e7571c70272e">More...</a><br/></td></tr>
<tr class="separator:a27dad23d38c6d5e74c65e7571c70272e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffd66726e0532160e16e6b48d6f428"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa2ffd66726e0532160e16e6b48d6f428">pi</a> ()</td></tr>
<tr class="memdesc:aa2ffd66726e0532160e16e6b48d6f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of pi.  <a href="#aa2ffd66726e0532160e16e6b48d6f428">More...</a><br/></td></tr>
<tr class="separator:aa2ffd66726e0532160e16e6b48d6f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b650a0131d41167ef4837ecc7d02be5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a> ()</td></tr>
<tr class="memdesc:a3b650a0131d41167ef4837ecc7d02be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base of the natural logarithm.  <a href="#a3b650a0131d41167ef4837ecc7d02be5">More...</a><br/></td></tr>
<tr class="separator:a3b650a0131d41167ef4837ecc7d02be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1369f60a09e3af4933096de3a54ac28c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1369f60a09e3af4933096de3a54ac28c">sqrt2</a> ()</td></tr>
<tr class="memdesc:a1369f60a09e3af4933096de3a54ac28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of two.  <a href="#a1369f60a09e3af4933096de3a54ac28c">More...</a><br/></td></tr>
<tr class="separator:a1369f60a09e3af4933096de3a54ac28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4f7c092e2bc9a089885628b86c004"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a21f4f7c092e2bc9a089885628b86c004">log10</a> ()</td></tr>
<tr class="memdesc:a21f4f7c092e2bc9a089885628b86c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of ten.  <a href="#a21f4f7c092e2bc9a089885628b86c004">More...</a><br/></td></tr>
<tr class="separator:a21f4f7c092e2bc9a089885628b86c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34675a70d3df614d88d33ddbdd49b49a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34675a70d3df614d88d33ddbdd49b49a">positive_infinity</a> ()</td></tr>
<tr class="memdesc:a34675a70d3df614d88d33ddbdd49b49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity.  <a href="#a34675a70d3df614d88d33ddbdd49b49a">More...</a><br/></td></tr>
<tr class="separator:a34675a70d3df614d88d33ddbdd49b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34bffe91b7a24cb29bd69cb60814c39e">negative_infinity</a> ()</td></tr>
<tr class="memdesc:a34bffe91b7a24cb29bd69cb60814c39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return negative infinity.  <a href="#a34bffe91b7a24cb29bd69cb60814c39e">More...</a><br/></td></tr>
<tr class="separator:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381493bccc58bd993d797a2a5458c486"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a381493bccc58bd993d797a2a5458c486">not_a_number</a> ()</td></tr>
<tr class="memdesc:a381493bccc58bd993d797a2a5458c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (quiet) not-a-number.  <a href="#a381493bccc58bd993d797a2a5458c486">More...</a><br/></td></tr>
<tr class="separator:a381493bccc58bd993d797a2a5458c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a173839dddd0a8ac8afa710b9e3d5008a">machine_precision</a> ()</td></tr>
<tr class="memdesc:a173839dddd0a8ac8afa710b9e3d5008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between 1.0 and the next value representable.  <a href="#a173839dddd0a8ac8afa710b9e3d5008a">More...</a><br/></td></tr>
<tr class="separator:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb54ce92709046c6d168e851d2481c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5eb54ce92709046c6d168e851d2481c7">digamma</a> (double x)</td></tr>
<tr class="memdesc:a5eb54ce92709046c6d168e851d2481c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{digamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_275.png"/>
</p>
  <a href="#a5eb54ce92709046c6d168e851d2481c7">More...</a><br/></td></tr>
<tr class="separator:a5eb54ce92709046c6d168e851d2481c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae86020a972c6efc6b3407c3cfc30f4a6">dist</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04cebee51d38a543e0ec689ae1399c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaf04cebee51d38a543e0ec689ae1399c">divide</a> (const int x, const int y)</td></tr>
<tr class="separator:aaf04cebee51d38a543e0ec689ae1399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b73319bd8df9dad1d3902997d8e89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd3b73319bd8df9dad1d3902997d8e89">dot</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:afd3b73319bd8df9dad1d3902997d8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a4ef7c701db7984297d153580c8d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a6a4ef7c701db7984297d153580c8d4">dot_self</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a8a6a4ef7c701db7984297d153580c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ef734d7c3b8ebd689012295bf826e94">exp2</a> (const T y)</td></tr>
<tr class="memdesc:a0ef734d7c3b8ebd689012295bf826e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponent base 2 of the specified argument (C99).  <a href="#a0ef734d7c3b8ebd689012295bf826e94">More...</a><br/></td></tr>
<tr class="separator:a0ef734d7c3b8ebd689012295bf826e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2df2a7019f7f68a915b3edab21921a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac2df2a7019f7f68a915b3edab21921a1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac2df2a7019f7f68a915b3edab21921a1">falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:ac2df2a7019f7f68a915b3edab21921a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{falling\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_279.png"/>
</p>
  <a href="#ac2df2a7019f7f68a915b3edab21921a1">More...</a><br/></td></tr>
<tr class="separator:ac2df2a7019f7f68a915b3edab21921a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7d2db622c0f83134b7f3ebd1eec3c1d6">fdim</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The positive difference function (C99).  <a href="#a7d2db622c0f83134b7f3ebd1eec3c1d6">More...</a><br/></td></tr>
<tr class="separator:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed411d626d4ae01a76584c454a83673f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed411d626d4ae01a76584c454a83673f">gamma_p</a> (double x, double a)</td></tr>
<tr class="memdesc:aed411d626d4ae01a76584c454a83673f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_p}(a,z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ P(a,z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_285.png"/>
</p>
  <a href="#aed411d626d4ae01a76584c454a83673f">More...</a><br/></td></tr>
<tr class="separator:aed411d626d4ae01a76584c454a83673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0830ba049b81bc98ea9fbcf1eb7b4bd6">gamma_q</a> (double x, double a)</td></tr>
<tr class="memdesc:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_q}(a,z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ Q(a,z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_291.png"/>
</p>
  <a href="#a0830ba049b81bc98ea9fbcf1eb7b4bd6">More...</a><br/></td></tr>
<tr class="separator:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b430ac57e75ba2d55843cd868506e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af7b430ac57e75ba2d55843cd868506e1">ibeta</a> (const double a, const double b, const double x)</td></tr>
<tr class="memdesc:af7b430ac57e75ba2d55843cd868506e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, and x.  <a href="#af7b430ac57e75ba2d55843cd868506e1">More...</a><br/></td></tr>
<tr class="separator:af7b430ac57e75ba2d55843cd868506e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa732732442d65936275d718b7286cb51"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false &gt; </td></tr>
<tr class="memitem:aa732732442d65936275d718b7286cb51"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_true, T_false &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa732732442d65936275d718b7286cb51">if_else</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:aa732732442d65936275d718b7286cb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second argument if the first argument is true and otherwise return the second argument.  <a href="#aa732732442d65936275d718b7286cb51">More...</a><br/></td></tr>
<tr class="separator:aa732732442d65936275d718b7286cb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c507cff4b7b473cd86e1d428fb03136">int_step</a> (const T y)</td></tr>
<tr class="memdesc:a8c507cff4b7b473cd86e1d428fb03136"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer step, or Heaviside, function.  <a href="#a8c507cff4b7b473cd86e1d428fb03136">More...</a><br/></td></tr>
<tr class="separator:a8c507cff4b7b473cd86e1d428fb03136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab64935e0bdac8227bfd9608285d4e699">inv</a> (const T x)</td></tr>
<tr class="separator:ab64935e0bdac8227bfd9608285d4e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a008bf0b6c2ab38d088b0aba5d7b10c8d">inv_cloglog</a> (T x)</td></tr>
<tr class="memdesc:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <a href="#a008bf0b6c2ab38d088b0aba5d7b10c8d">More...</a><br/></td></tr>
<tr class="separator:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad2c4834fc581f55acf8491ec3f80ecb7">inv_logit</a> (const T a)</td></tr>
<tr class="memdesc:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <a href="#ad2c4834fc581f55acf8491ec3f80ecb7">More...</a><br/></td></tr>
<tr class="separator:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4b4db5e98585c71cc7c14319f96e0c04">inv_sqrt</a> (const T x)</td></tr>
<tr class="separator:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d2e922aa13e2dfae510fc13d86eaea3">inv_square</a> (const T x)</td></tr>
<tr class="separator:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1edc35cc581dda178263f6a4a4fd1158">inverse_softmax</a> (const Vector &amp;simplex, Vector &amp;y)</td></tr>
<tr class="memdesc:a1edc35cc581dda178263f6a4a4fd1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the inverse softmax of the simplex argument into the second argument.  <a href="#a1edc35cc581dda178263f6a4a4fd1158">More...</a><br/></td></tr>
<tr class="separator:a1edc35cc581dda178263f6a4a4fd1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0020ce04cad9a5eb9b55abb690863fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae0020ce04cad9a5eb9b55abb690863fa">is_inf</a> (const double x)</td></tr>
<tr class="memdesc:ae0020ce04cad9a5eb9b55abb690863fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input is infinite and 0 otherwise.  <a href="#ae0020ce04cad9a5eb9b55abb690863fa">More...</a><br/></td></tr>
<tr class="separator:ae0020ce04cad9a5eb9b55abb690863fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01488df30a81c36b1a00391b9541e1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae01488df30a81c36b1a00391b9541e1d">is_nan</a> (double x)</td></tr>
<tr class="memdesc:ae01488df30a81c36b1a00391b9541e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input is NaN and 0 otherwise.  <a href="#ae01488df30a81c36b1a00391b9541e1d">More...</a><br/></td></tr>
<tr class="separator:ae01488df30a81c36b1a00391b9541e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40c14c26dc55a985e05695b3ff1eeef2">is_uninitialized</a> (T x)</td></tr>
<tr class="memdesc:a40c14c26dc55a985e05695b3ff1eeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="#a40c14c26dc55a985e05695b3ff1eeef2">More...</a><br/></td></tr>
<tr class="separator:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ccdb3f505b7db61c510e59e97b947b6">lbeta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a3ccdb3f505b7db61c510e59e97b947b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the beta function applied to the specified arguments.  <a href="#a3ccdb3f505b7db61c510e59e97b947b6">More...</a><br/></td></tr>
<tr class="separator:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f46d7f63f5118a32cad11382c0551"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a836f46d7f63f5118a32cad11382c0551">lgamma</a> (double x)</td></tr>
<tr class="memdesc:a836f46d7f63f5118a32cad11382c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lgamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \ln\Gamma(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_315.png"/>
</p>
  <a href="#a836f46d7f63f5118a32cad11382c0551">More...</a><br/></td></tr>
<tr class="separator:a836f46d7f63f5118a32cad11382c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ee0706b2cb6d2e1da2c3b6041c06a56">lmgamma</a> (const int k, T x)</td></tr>
<tr class="memdesc:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument.  <a href="#a0ee0706b2cb6d2e1da2c3b6041c06a56">More...</a><br/></td></tr>
<tr class="separator:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4f92092fb8a70b31d00898bbbe769612">log1m</a> (T x)</td></tr>
<tr class="memdesc:a4f92092fb8a70b31d00898bbbe769612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the specified value.  <a href="#a4f92092fb8a70b31d00898bbbe769612">More...</a><br/></td></tr>
<tr class="separator:a4f92092fb8a70b31d00898bbbe769612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ce261caf05bd371c430e82a0e6389a5">log1m_exp</a> (const T a)</td></tr>
<tr class="memdesc:a3ce261caf05bd371c430e82a0e6389a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)).  <a href="#a3ce261caf05bd371c430e82a0e6389a5">More...</a><br/></td></tr>
<tr class="separator:a3ce261caf05bd371c430e82a0e6389a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac7f71c696a5e0da4daab30e5f3704842">log1m_inv_logit</a> (const T u)</td></tr>
<tr class="memdesc:ac7f71c696a5e0da4daab30e5f3704842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of 1 minus the inverse logit of the specified argument.  <a href="#ac7f71c696a5e0da4daab30e5f3704842">More...</a><br/></td></tr>
<tr class="separator:ac7f71c696a5e0da4daab30e5f3704842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5166d3c58ad8ce0aedbf104179888b69">log1p</a> (const T x)</td></tr>
<tr class="memdesc:a5166d3c58ad8ce0aedbf104179888b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified value.  <a href="#a5166d3c58ad8ce0aedbf104179888b69">More...</a><br/></td></tr>
<tr class="separator:a5166d3c58ad8ce0aedbf104179888b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88151def26813dec3e04c4a8b9674091">log1p_exp</a> (const T a)</td></tr>
<tr class="memdesc:a88151def26813dec3e04c4a8b9674091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 plus the exponential of the specified value without overflow.  <a href="#a88151def26813dec3e04c4a8b9674091">More...</a><br/></td></tr>
<tr class="separator:a88151def26813dec3e04c4a8b9674091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa25e1572bf46e3a6b9ee270f0c7e2c4d">log2</a> (const T a)</td></tr>
<tr class="memdesc:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the argument (C99).  <a href="#aa25e1572bf46e3a6b9ee270f0c7e2c4d">More...</a><br/></td></tr>
<tr class="separator:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ba3fe3c87293f7c57395007100c79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a947ba3fe3c87293f7c57395007100c79">log2</a> ()</td></tr>
<tr class="memdesc:a947ba3fe3c87293f7c57395007100c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of two.  <a href="#a947ba3fe3c87293f7c57395007100c79">More...</a><br/></td></tr>
<tr class="separator:a947ba3fe3c87293f7c57395007100c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1dbafd4c2a129415e86f868fc0979a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aac1dbafd4c2a129415e86f868fc0979a"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aac1dbafd4c2a129415e86f868fc0979a">log_diff_exp</a> (const T1 x, const T2 y)</td></tr>
<tr class="memdesc:aac1dbafd4c2a129415e86f868fc0979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2.  <a href="#aac1dbafd4c2a129415e86f868fc0979a">More...</a><br/></td></tr>
<tr class="separator:aac1dbafd4c2a129415e86f868fc0979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa9cb2f3f6c73b2005d9e9fadbad415bf">log_falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_falling\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_339.png"/>
</p>
  <a href="#aa9cb2f3f6c73b2005d9e9fadbad415bf">More...</a><br/></td></tr>
<tr class="separator:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad5be889d1ef4284654a04e400f5371a7">log_inv_logit</a> (const T &amp;u)</td></tr>
<tr class="memdesc:ad5be889d1ef4284654a04e400f5371a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <a href="#ad5be889d1ef4284654a04e400f5371a7">More...</a><br/></td></tr>
<tr class="separator:ad5be889d1ef4284654a04e400f5371a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1b7b9cda7f1b3234cc4b3fc20e595482">log_mix</a> (double theta, double lambda1, double lambda2)</td></tr>
<tr class="memdesc:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities.  <a href="#a1b7b9cda7f1b3234cc4b3fc20e595482">More...</a><br/></td></tr>
<tr class="separator:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf23285d755661c14ca29c3ba935b77d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aaf23285d755661c14ca29c3ba935b77d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaf23285d755661c14ca29c3ba935b77d">log_rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:aaf23285d755661c14ca29c3ba935b77d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_rising\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_348.png"/>
</p>
  <a href="#aaf23285d755661c14ca29c3ba935b77d">More...</a><br/></td></tr>
<tr class="separator:aaf23285d755661c14ca29c3ba935b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c5f32f7cd1a5690a697f4031df569c4">log_sum_exp</a> (const T2 &amp;a, const T1 &amp;b)</td></tr>
<tr class="memdesc:a3c5f32f7cd1a5690a697f4031df569c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponetials without overflow.  <a href="#a3c5f32f7cd1a5690a697f4031df569c4">More...</a><br/></td></tr>
<tr class="separator:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e67f9b1692743a9db4462e98bb49ef5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e67f9b1692743a9db4462e98bb49ef5">log_sum_exp</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e67f9b1692743a9db4462e98bb49ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified sequence of values.  <a href="#a9e67f9b1692743a9db4462e98bb49ef5">More...</a><br/></td></tr>
<tr class="separator:a9e67f9b1692743a9db4462e98bb49ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adc35bab2db89b3ceda66f11e1fa53ec8">logical_and</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise.  <a href="#adc35bab2db89b3ceda66f11e1fa53ec8">More...</a><br/></td></tr>
<tr class="separator:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab2213736b55fd6696fa0120fd3fe72e4">logical_eq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab2213736b55fd6696fa0120fd3fe72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is equal to the second.  <a href="#ab2213736b55fd6696fa0120fd3fe72e4">More...</a><br/></td></tr>
<tr class="separator:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aba86bfd994302061a0260e1202fca777">logical_gt</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:aba86bfd994302061a0260e1202fca777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly greater than the second.  <a href="#aba86bfd994302061a0260e1202fca777">More...</a><br/></td></tr>
<tr class="separator:aba86bfd994302061a0260e1202fca777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6bb0b8623192207d35e207ea312d8be">logical_gte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ac6bb0b8623192207d35e207ea312d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than or equal to the second.  <a href="#ac6bb0b8623192207d35e207ea312d8be">More...</a><br/></td></tr>
<tr class="separator:ac6bb0b8623192207d35e207ea312d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0b5bd91412749e10933f304b54aef88f">logical_lt</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:a0b5bd91412749e10933f304b54aef88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly less than the second.  <a href="#a0b5bd91412749e10933f304b54aef88f">More...</a><br/></td></tr>
<tr class="separator:a0b5bd91412749e10933f304b54aef88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af3649d4c704962c4502cd6220a5e2230">logical_lte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:af3649d4c704962c4502cd6220a5e2230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is less than or equal to the second.  <a href="#af3649d4c704962c4502cd6220a5e2230">More...</a><br/></td></tr>
<tr class="separator:af3649d4c704962c4502cd6220a5e2230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aad2fc9ce55dfac079d930335beb7e4a8">logical_negation</a> (const T x)</td></tr>
<tr class="memdesc:aad2fc9ce55dfac079d930335beb7e4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical negation function which returns 1 if the input is equal to zero and 0 otherwise.  <a href="#aad2fc9ce55dfac079d930335beb7e4a8">More...</a><br/></td></tr>
<tr class="separator:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a206eb210d8e7e2c718af25c40de8f9d1">logical_neq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a206eb210d8e7e2c718af25c40de8f9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is unequal to the second.  <a href="#a206eb210d8e7e2c718af25c40de8f9d1">More...</a><br/></td></tr>
<tr class="separator:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac74007e2d5f55d5ae4a308f535869aee">logical_or</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:ac74007e2d5f55d5ae4a308f535869aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise.  <a href="#ac74007e2d5f55d5ae4a308f535869aee">More...</a><br/></td></tr>
<tr class="separator:ac74007e2d5f55d5ae4a308f535869aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53342d0c2cd3a6e440c533070054aca3">logit</a> (const T a)</td></tr>
<tr class="memdesc:a53342d0c2cd3a6e440c533070054aca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logit function applied to the argument.  <a href="#a53342d0c2cd3a6e440c533070054aca3">More...</a><br/></td></tr>
<tr class="separator:a53342d0c2cd3a6e440c533070054aca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6be1d580b3b5cf4b4f57546062352"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a> (const double a, const double b)</td></tr>
<tr class="separator:a86b6be1d580b3b5cf4b4f57546062352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab360c822174f211838f5979760c7e09e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab360c822174f211838f5979760c7e09e">min</a> (const double a, const double b)</td></tr>
<tr class="separator:ab360c822174f211838f5979760c7e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acafecf14b103c7c17da33368d07b1565">modified_bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:acafecf14b103c7c17da33368d07b1565"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_first\_kind}(v,z) = \begin{cases} I_v(z) &amp; \mbox{if } -\infty\leq z \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_363.png"/>
</p>
  <a href="#acafecf14b103c7c17da33368d07b1565">More...</a><br/></td></tr>
<tr class="separator:acafecf14b103c7c17da33368d07b1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a72ce86f3db5478cad4666c9cf1d05a6e">modified_bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_second\_kind}(v,z) = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ K_v(z) &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_367.png"/>
</p>
  <a href="#a72ce86f3db5478cad4666c9cf1d05a6e">More...</a><br/></td></tr>
<tr class="separator:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf62df7cae63f67b1c5c67651bc8dcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afcf62df7cae63f67b1c5c67651bc8dcf">modulus</a> (const int x, const int y)</td></tr>
<tr class="separator:afcf62df7cae63f67b1c5c67651bc8dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_a, T_b &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab530a1792bc901bb6ade34ef3d9ef8b3">multiply_log</a> (const T_a a, const T_b b)</td></tr>
<tr class="memdesc:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs.  <a href="#ab530a1792bc901bb6ade34ef3d9ef8b3">More...</a><br/></td></tr>
<tr class="separator:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66a7e8ebefd11e5801aab51d6ed9c9d8">owens_t</a> (const T1 &amp;h, const T2 &amp;a)</td></tr>
<tr class="memdesc:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#a66a7e8ebefd11e5801aab51d6ed9c9d8">More...</a><br/></td></tr>
<tr class="separator:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac85644bbd92359d699f374adea62c643">Phi</a> (const T x)</td></tr>
<tr class="memdesc:ac85644bbd92359d699f374adea62c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative distribution function.  <a href="#ac85644bbd92359d699f374adea62c643">More...</a><br/></td></tr>
<tr class="separator:ac85644bbd92359d699f374adea62c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cf4bf2074175fd7bcde43f9f94e4d16">Phi_approx</a> (T x)</td></tr>
<tr class="memdesc:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF.  <a href="#a6cf4bf2074175fd7bcde43f9f94e4d16">More...</a><br/></td></tr>
<tr class="separator:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cbc3a490edf340544fb12df544269e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cbc3a490edf340544fb12df544269e"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;, T &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8cbc3a490edf340544fb12df544269e">primitive_value</a> (T x)</td></tr>
<tr class="memdesc:af8cbc3a490edf340544fb12df544269e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified arithmetic argument unmodified with its own declared type.  <a href="#af8cbc3a490edf340544fb12df544269e">More...</a><br/></td></tr>
<tr class="separator:af8cbc3a490edf340544fb12df544269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491e419195548cdede51a384547aef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0491e419195548cdede51a384547aef2"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
, double &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0491e419195548cdede51a384547aef2">primitive_value</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0491e419195548cdede51a384547aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified argument.  <a href="#a0491e419195548cdede51a384547aef2">More...</a><br/></td></tr>
<tr class="separator:a0491e419195548cdede51a384547aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413627171d6e5de85393af92edfb7234"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a413627171d6e5de85393af92edfb7234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt; T, S &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a413627171d6e5de85393af92edfb7234">promote_scalar</a> (const S &amp;x)</td></tr>
<tr class="memdesc:a413627171d6e5de85393af92edfb7234"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the top-level function to call to promote the scalar types of an input of type S to type T.  <a href="#a413627171d6e5de85393af92edfb7234">More...</a><br/></td></tr>
<tr class="separator:a413627171d6e5de85393af92edfb7234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad3d78d2735a35451f02bcd2f4da24886">rep_array</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:ad3d78d2735a35451f02bcd2f4da24886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8edf0b7ec2ad24b1fda26a8d58513106">rep_array</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; std::vector&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53054db4cfa6672654fbaedafbdae242">rep_array</a> (const T &amp;x, int k, int m, int n)</td></tr>
<tr class="separator:a53054db4cfa6672654fbaedafbdae242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c25994a9886374662f280ecba376a42"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3c25994a9886374662f280ecba376a42"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c25994a9886374662f280ecba376a42">rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:a3c25994a9886374662f280ecba376a42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{rising\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_382.png"/>
</p>
  <a href="#a3c25994a9886374662f280ecba376a42">More...</a><br/></td></tr>
<tr class="separator:a3c25994a9886374662f280ecba376a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb786f14699d69c39cfdd49893a8006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2eb786f14699d69c39cfdd49893a8006">scaled_add</a> (std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y, const double lambda)</td></tr>
<tr class="separator:a2eb786f14699d69c39cfdd49893a8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825f81b97ddf0b2e1217f30913559a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad825f81b97ddf0b2e1217f30913559a3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad825f81b97ddf0b2e1217f30913559a3">sign</a> (const T &amp;z)</td></tr>
<tr class="separator:ad825f81b97ddf0b2e1217f30913559a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a056b82f11f784f321bce2c5677089e24">square</a> (const T x)</td></tr>
<tr class="memdesc:a056b82f11f784f321bce2c5677089e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the specified argument.  <a href="#a056b82f11f784f321bce2c5677089e24">More...</a><br/></td></tr>
<tr class="separator:a056b82f11f784f321bce2c5677089e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fdc5e5ba8e306c2a594e928bfd62ea2">step</a> (const T y)</td></tr>
<tr class="memdesc:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step, or Heaviside, function.  <a href="#a8fdc5e5ba8e306c2a594e928bfd62ea2">More...</a><br/></td></tr>
<tr class="separator:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e4c5e5b76b18a41b28f646104b3cd46">sub</a> (std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;y, std::vector&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1fe0f002efa49cf9f7c129fe1a1d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adde1fe0f002efa49cf9f7c129fe1a1d0">sum</a> (std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:adde1fe0f002efa49cf9f7c129fe1a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18c21bad37c9af26424d0922936355e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab18c21bad37c9af26424d0922936355e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab18c21bad37c9af26424d0922936355e">trigamma</a> (T x)</td></tr>
<tr class="memdesc:ab18c21bad37c9af26424d0922936355e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{trigamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \Psi_1(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_390.png"/>
</p>
  <a href="#ab18c21bad37c9af26424d0922936355e">More...</a><br/></td></tr>
<tr class="separator:ab18c21bad37c9af26424d0922936355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e">value_of</a> (const T x)</td></tr>
<tr class="memdesc:a73087d72fd937f4be66684bd2613ae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="#a73087d72fd937f4be66684bd2613ae6e">More...</a><br/></td></tr>
<tr class="separator:a73087d72fd937f4be66684bd2613ae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2d7774df98215b7d113075019d74ebbf">value_of&lt; double &gt;</a> (const double x)</td></tr>
<tr class="memdesc:a2d7774df98215b7d113075019d74ebbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="#a2d7774df98215b7d113075019d74ebbf">More...</a><br/></td></tr>
<tr class="separator:a2d7774df98215b7d113075019d74ebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a99d6e8d6986fffb421e859770560bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a99d6e8d6986fffb421e859770560bc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a99d6e8d6986fffb421e859770560bc">value_of_rec</a> (const T x)</td></tr>
<tr class="memdesc:a7a99d6e8d6986fffb421e859770560bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="#a7a99d6e8d6986fffb421e859770560bc">More...</a><br/></td></tr>
<tr class="separator:a7a99d6e8d6986fffb421e859770560bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7bb47fffd6ec0b1864d5e8bf0b99cf55">value_of_rec&lt; double &gt;</a> (const double x)</td></tr>
<tr class="memdesc:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="#a7bb47fffd6ec0b1864d5e8bf0b99cf55">More...</a><br/></td></tr>
<tr class="separator:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4b97f71328d3de40de286ec6e3754e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a3d4b97f71328d3de40de286ec6e3754e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d4b97f71328d3de40de286ec6e3754e">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a3d4b97f71328d3de40de286ec6e3754e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrices.  <a href="#a3d4b97f71328d3de40de286ec6e3754e">More...</a><br/></td></tr>
<tr class="separator:a3d4b97f71328d3de40de286ec6e3754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ade0aeac74c8366b8c210446324a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:aa92ade0aeac74c8366b8c210446324a1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa92ade0aeac74c8366b8c210446324a1">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:aa92ade0aeac74c8366b8c210446324a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrix and specified scalar.  <a href="#aa92ade0aeac74c8366b8c210446324a1">More...</a><br/></td></tr>
<tr class="separator:aa92ade0aeac74c8366b8c210446324a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cbcb4a48d3284e93afe13093412683"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:ac4cbcb4a48d3284e93afe13093412683"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac4cbcb4a48d3284e93afe13093412683">add</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ac4cbcb4a48d3284e93afe13093412683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalar and specified matrix.  <a href="#ac4cbcb4a48d3284e93afe13093412683">More...</a><br/></td></tr>
<tr class="separator:ac4cbcb4a48d3284e93afe13093412683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4b84e31ce04be2750e4b906f8399d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a61e4b84e31ce04be2750e4b906f8399d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; typename <a class="el" href="structstan_1_1return__type.html">return_type</a><br class="typebreak"/>
&lt; T1, T2 &gt;::type, Dynamic, <br class="typebreak"/>
Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a61e4b84e31ce04be2750e4b906f8399d">append_col</a> (const Matrix&lt; T1, R1, C1 &gt; &amp;A, const Matrix&lt; T2, R2, C2 &gt; &amp;B)</td></tr>
<tr class="separator:a61e4b84e31ce04be2750e4b906f8399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc71c8083ea01c4e5ca7509118fdea2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:abcc71c8083ea01c4e5ca7509118fdea2"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abcc71c8083ea01c4e5ca7509118fdea2">append_col</a> (const Matrix&lt; T, R1, C1 &gt; &amp;A, const Matrix&lt; T, R2, C2 &gt; &amp;B)</td></tr>
<tr class="separator:abcc71c8083ea01c4e5ca7509118fdea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab63bad76023a50d55ea00393e9400d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ab63bad76023a50d55ea00393e9400d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, 1, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2ab63bad76023a50d55ea00393e9400d">append_col</a> (const Matrix&lt; T, 1, Dynamic &gt; &amp;A, const Matrix&lt; T, 1, Dynamic &gt; &amp;B)</td></tr>
<tr class="separator:a2ab63bad76023a50d55ea00393e9400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5d7ce5cb34bedef6e8148889d4a075"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6b5d7ce5cb34bedef6e8148889d4a075"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; typename <a class="el" href="structstan_1_1return__type.html">return_type</a><br class="typebreak"/>
&lt; T1, T2 &gt;::type, Dynamic, <br class="typebreak"/>
Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6b5d7ce5cb34bedef6e8148889d4a075">append_row</a> (const Matrix&lt; T1, R1, C1 &gt; &amp;A, const Matrix&lt; T2, R2, C2 &gt; &amp;B)</td></tr>
<tr class="separator:a6b5d7ce5cb34bedef6e8148889d4a075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a581c504cbf0410ef66e9827b5137a"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a23a581c504cbf0410ef66e9827b5137a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a23a581c504cbf0410ef66e9827b5137a">append_row</a> (const Matrix&lt; T, R1, C1 &gt; &amp;A, const Matrix&lt; T, R2, C2 &gt; &amp;B)</td></tr>
<tr class="separator:a23a581c504cbf0410ef66e9827b5137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65bb02e97a8403f5807f0650709817"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f65bb02e97a8403f5807f0650709817"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f65bb02e97a8403f5807f0650709817">append_row</a> (const Matrix&lt; T, Dynamic, 1 &gt; &amp;A, const Matrix&lt; T, Dynamic, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a6f65bb02e97a8403f5807f0650709817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf">assign</a> (LHS &amp;lhs, const RHS &amp;rhs)</td></tr>
<tr class="memdesc:a5f394c15ea3eb97743382631f91801cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5f394c15ea3eb97743382631f91801cf">More...</a><br/></td></tr>
<tr class="separator:a5f394c15ea3eb97743382631f91801cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5371f0f914e9b79a0700577e5557c0b7">assign</a> (Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;x, const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;y)</td></tr>
<tr class="memdesc:a5371f0f914e9b79a0700577e5557c0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5371f0f914e9b79a0700577e5557c0b7">More...</a><br/></td></tr>
<tr class="separator:a5371f0f914e9b79a0700577e5557c0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a80c719463c4e3caa03df731e2c2cb9">assign</a> (Eigen::Matrix&lt; LHS, R, C &gt; &amp;x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:a0a80c719463c4e3caa03df731e2c2cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a0a80c719463c4e3caa03df731e2c2cb9">More...</a><br/></td></tr>
<tr class="separator:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa4af3a90ad3b5ec1507dfc1823fdb8da">assign</a> (Eigen::Block&lt; LHS &gt; x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#aa4af3a90ad3b5ec1507dfc1823fdb8da">More...</a><br/></td></tr>
<tr class="separator:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2c6dec98c71fd478c2ee16bc274b464d">assign</a> (std::vector&lt; LHS &gt; &amp;x, const std::vector&lt; RHS &gt; &amp;y)</td></tr>
<tr class="memdesc:a2c6dec98c71fd478c2ee16bc274b464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a2c6dec98c71fd478c2ee16bc274b464d">More...</a><br/></td></tr>
<tr class="separator:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af163dfd071f1cff0297b7418156563a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af163dfd071f1cff0297b7418156563a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af163dfd071f1cff0297b7418156563a8">block</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:af163dfd071f1cff0297b7418156563a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1,j-1).  <a href="#af163dfd071f1cff0297b7418156563a8">More...</a><br/></td></tr>
<tr class="separator:af163dfd071f1cff0297b7418156563a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abbcc91ff24e86fa318fe0f8a9111b4c5">cholesky_decompose</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="#abbcc91ff24e86fa318fe0f8a9111b4c5">More...</a><br/></td></tr>
<tr class="separator:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae497ca37fd7867fd11c4cd095c8aaa71">col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t j)</td></tr>
<tr class="memdesc:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified matrix using start-at-1 indexing.  <a href="#ae497ca37fd7867fd11c4cd095c8aaa71">More...</a><br/></td></tr>
<tr class="separator:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a871bccc233a4dcd764ffece5a3f9a399">cols</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a871bccc233a4dcd764ffece5a3f9a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d03b34aa7329a68f31d1c7bc500c5c8">columns_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6d03b34aa7329a68f31d1c7bc500c5c8">More...</a><br/></td></tr>
<tr class="separator:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03701ff6420231890468e9881eb9245"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af03701ff6420231890468e9881eb9245"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af03701ff6420231890468e9881eb9245">columns_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:af03701ff6420231890468e9881eb9245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="#af03701ff6420231890468e9881eb9245">More...</a><br/></td></tr>
<tr class="separator:af03701ff6420231890468e9881eb9245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a142c1899afa9dea4bdc053e959bf7"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a95a142c1899afa9dea4bdc053e959bf7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a95a142c1899afa9dea4bdc053e959bf7">to_matrix</a> (Matrix&lt; T, R, C &gt; matrix)</td></tr>
<tr class="separator:a95a142c1899afa9dea4bdc053e959bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d53d7c1ac5bb3a3eff436d70b2cfbd6">to_matrix</a> (const vector&lt; vector&lt; T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5894e034cf63df686f4a32b78facbf"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaa5894e034cf63df686f4a32b78facbf">to_matrix</a> (const vector&lt; vector&lt; int &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:aaa5894e034cf63df686f4a32b78facbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aa02a20972263242e2f6a8785cf58d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae2aa02a20972263242e2f6a8785cf58d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae2aa02a20972263242e2f6a8785cf58d">to_vector</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:ae2aa02a20972263242e2f6a8785cf58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7916ec81b929389e94c7fd725fd87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cc7916ec81b929389e94c7fd725fd87"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1cc7916ec81b929389e94c7fd725fd87">to_vector</a> (const vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a1cc7916ec81b929389e94c7fd725fd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3b48fe1676d80fd5775f97f2b6a9a"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fc3b48fe1676d80fd5775f97f2b6a9a">to_vector</a> (const vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a2fc3b48fe1676d80fd5775f97f2b6a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c7bf292d2f253217a813e6327899ce"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a69c7bf292d2f253217a813e6327899ce"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, 1, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69c7bf292d2f253217a813e6327899ce">to_row_vector</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:a69c7bf292d2f253217a813e6327899ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb83869b0604ee1a484547330db06f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8eb83869b0604ee1a484547330db06f"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, 1, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab8eb83869b0604ee1a484547330db06f">to_row_vector</a> (const vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:ab8eb83869b0604ee1a484547330db06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e184ac2d303916513687b326bb01035"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, 1, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e184ac2d303916513687b326bb01035">to_row_vector</a> (const vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a0e184ac2d303916513687b326bb01035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdd0729c27213abdf446412e7f7793c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cdd0729c27213abdf446412e7f7793c"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cdd0729c27213abdf446412e7f7793c">to_array_2d</a> (const Matrix&lt; T, Dynamic, Dynamic &gt; &amp;matrix)</td></tr>
<tr class="separator:a6cdd0729c27213abdf446412e7f7793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88c990ca9770c6c37d883d87eb82eb6d">to_array_1d</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad927f0ff9564aa04073f673d5e6bddfa">to_array_1d</a> (const vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a><br class="typebreak"/>
&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8108c33b0612c8fe8f47767fa1ca6ad1">to_array_1d</a> (const vector&lt; vector&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="separator:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a62cc3a137ff3220bdd0137a52a4b9714">crossprod</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a62cc3a137ff3220bdd0137a52a4b9714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="#a62cc3a137ff3220bdd0137a52a4b9714">More...</a><br/></td></tr>
<tr class="separator:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7340f6be8ae1e121c6d854005560fef5">cumulative_sum</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7340f6be8ae1e121c6d854005560fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="#a7340f6be8ae1e121c6d854005560fef5">More...</a><br/></td></tr>
<tr class="separator:a7340f6be8ae1e121c6d854005560fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab469ac332306aa00947f4a7c5d30b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:affab469ac332306aa00947f4a7c5d30b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#affab469ac332306aa00947f4a7c5d30b">cumulative_sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:affab469ac332306aa00947f4a7c5d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified matrix.  <a href="#affab469ac332306aa00947f4a7c5d30b">More...</a><br/></td></tr>
<tr class="separator:affab469ac332306aa00947f4a7c5d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab65e9ab0e6f725c7e11068b0be2af84f">determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the specified square matrix.  <a href="#ab65e9ab0e6f725c7e11068b0be2af84f">More...</a><br/></td></tr>
<tr class="separator:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af970bc3201f476e84259e7ba2d4eb276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af970bc3201f476e84259e7ba2d4eb276"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af970bc3201f476e84259e7ba2d4eb276">diag_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:af970bc3201f476e84259e7ba2d4eb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="#af970bc3201f476e84259e7ba2d4eb276">More...</a><br/></td></tr>
<tr class="separator:af970bc3201f476e84259e7ba2d4eb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00896827d3247350178c86c0aed533f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a00896827d3247350178c86c0aed533f6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00896827d3247350178c86c0aed533f6">diag_post_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a00896827d3247350178c86c0aed533f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6159f8ffb5a37c394dff93781622f504"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6159f8ffb5a37c394dff93781622f504"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R2, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6159f8ffb5a37c394dff93781622f504">diag_pre_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a6159f8ffb5a37c394dff93781622f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a877aa9df52c3a3f300a3d214c7bde64a">diagonal</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a877aa9df52c3a3f300a3d214c7bde64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <a href="#a877aa9df52c3a3f300a3d214c7bde64a">More...</a><br/></td></tr>
<tr class="separator:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a> (const T &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a2b9073e39033e56eb31344091f0170fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af95a2dcde478c06e3543511821618902">dims</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:af95a2dcde478c06e3543511821618902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a467589eef4220a87d457c8a268a1fd5d">dims</a> (const std::vector&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a467589eef4220a87d457c8a268a1fd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a33777ee768c7032331ca8b92e5323384">dims</a> (const T &amp;x)</td></tr>
<tr class="separator:a33777ee768c7032331ca8b92e5323384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354d9d6e7465ec8a49116f276d971db1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a354d9d6e7465ec8a49116f276d971db1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a354d9d6e7465ec8a49116f276d971db1">distance</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a354d9d6e7465ec8a49116f276d971db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between the specified vectors.  <a href="#a354d9d6e7465ec8a49116f276d971db1">More...</a><br/></td></tr>
<tr class="separator:a354d9d6e7465ec8a49116f276d971db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a082ee76b34a2ea656d2c8ab9186c1a2b">divide</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix divided by specified scalar.  <a href="#a082ee76b34a2ea656d2c8ab9186c1a2b">More...</a><br/></td></tr>
<tr class="separator:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8d73851895fb151fdf79e55bf33e98e">dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af8d73851895fb151fdf79e55bf33e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#af8d73851895fb151fdf79e55bf33e98e">More...</a><br/></td></tr>
<tr class="separator:af8d73851895fb151fdf79e55bf33e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58da447df259e9e092e8fd910b338e1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58da447df259e9e092e8fd910b338e1f">dot_product</a> (const double *v1, const double *v2, size_t <a class="el" href="namespacestan.html#a59c48c2ee48c5a6e8048fa2d6a035445">length</a>)</td></tr>
<tr class="memdesc:a58da447df259e9e092e8fd910b338e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#a58da447df259e9e092e8fd910b338e1f">More...</a><br/></td></tr>
<tr class="separator:a58da447df259e9e092e8fd910b338e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd93708bf432b3bd3d284958972ede"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7cd93708bf432b3bd3d284958972ede">dot_product</a> (const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab7cd93708bf432b3bd3d284958972ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#ab7cd93708bf432b3bd3d284958972ede">More...</a><br/></td></tr>
<tr class="separator:ab7cd93708bf432b3bd3d284958972ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac81ab85d390fcb594884773a85fac657">dot_self</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ac81ab85d390fcb594884773a85fac657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vector with itself.  <a href="#ac81ab85d390fcb594884773a85fac657">More...</a><br/></td></tr>
<tr class="separator:ac81ab85d390fcb594884773a85fac657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa37c65f508af7ad1d0b010aa5c932cbe">eigenvalues_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix in descending order of magnitude.  <a href="#aa37c65f508af7ad1d0b010aa5c932cbe">More...</a><br/></td></tr>
<tr class="separator:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4729756e6ed00a35f1e4531444c13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bd4729756e6ed00a35f1e4531444c13"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9bd4729756e6ed00a35f1e4531444c13">eigenvectors_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a9bd4729756e6ed00a35f1e4531444c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9262da41fbf44fefc9a66141a0759d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a3c9262da41fbf44fefc9a66141a0759d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c9262da41fbf44fefc9a66141a0759d">elt_divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a3c9262da41fbf44fefc9a66141a0759d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrices.  <a href="#a3c9262da41fbf44fefc9a66141a0759d">More...</a><br/></td></tr>
<tr class="separator:a3c9262da41fbf44fefc9a66141a0759d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0016fa774de95c513f4cc40ade45fad6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a0016fa774de95c513f4cc40ade45fad6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0016fa774de95c513f4cc40ade45fad6">elt_divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, T2 s)</td></tr>
<tr class="memdesc:a0016fa774de95c513f4cc40ade45fad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrix by the specified scalar.  <a href="#a0016fa774de95c513f4cc40ade45fad6">More...</a><br/></td></tr>
<tr class="separator:a0016fa774de95c513f4cc40ade45fad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06">elt_divide</a> (T1 s, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified scalar by the specified matrix.  <a href="#a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06">More...</a><br/></td></tr>
<tr class="separator:a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e2dce5971bba8c059995797e22ba0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a998e2dce5971bba8c059995797e22ba0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a998e2dce5971bba8c059995797e22ba0">elt_multiply</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a998e2dce5971bba8c059995797e22ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified matrices.  <a href="#a998e2dce5971bba8c059995797e22ba0">More...</a><br/></td></tr>
<tr class="separator:a998e2dce5971bba8c059995797e22ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac38f1fab5fe3e9b45c8c6e78ac3cc749">exp</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise exponentiation of the matrix or vector.  <a href="#ac38f1fab5fe3e9b45c8c6e78ac3cc749">More...</a><br/></td></tr>
<tr class="separator:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6004af7342e8187af0b1053da1b7deb"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols&gt; </td></tr>
<tr class="memitem:aa6004af7342e8187af0b1053da1b7deb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6004af7342e8187af0b1053da1b7deb">exp</a> (const Eigen::Matrix&lt; double, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="separator:aa6004af7342e8187af0b1053da1b7deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d362e53d3d40b61e68fdd08dc5eb38b">fill</a> (T &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a6d362e53d3d40b61e68fdd08dc5eb38b">More...</a><br/></td></tr>
<tr class="separator:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename S &gt; </td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73e791042ed648602eed1754679feff4">fill</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a73e791042ed648602eed1754679feff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a73e791042ed648602eed1754679feff4">More...</a><br/></td></tr>
<tr class="separator:a73e791042ed648602eed1754679feff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7f5d81c4d45f2407096def8810ffe00">fill</a> (std::vector&lt; T &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:aa7f5d81c4d45f2407096def8810ffe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#aa7f5d81c4d45f2407096def8810ffe00">More...</a><br/></td></tr>
<tr class="separator:aa7f5d81c4d45f2407096def8810ffe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7535c86e2c9ee9d5391a8cc63187317e">get_base1</a> (const std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7535c86e2c9ee9d5391a8cc63187317e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#a7535c86e2c9ee9d5391a8cc63187317e">More...</a><br/></td></tr>
<tr class="separator:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca7c84b936da0d3422507927cf9a68cc">get_base1</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aca7c84b936da0d3422507927cf9a68cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aca7c84b936da0d3422507927cf9a68cc">More...</a><br/></td></tr>
<tr class="separator:aca7c84b936da0d3422507927cf9a68cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a714e39ba9fcbbd90c787a51d511c9af1">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a714e39ba9fcbbd90c787a51d511c9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a714e39ba9fcbbd90c787a51d511c9af1">More...</a><br/></td></tr>
<tr class="separator:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa23b355397df347249da513307fd6667">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aa23b355397df347249da513307fd6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aa23b355397df347249da513307fd6667">More...</a><br/></td></tr>
<tr class="separator:aa23b355397df347249da513307fd6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25c1fac0445beea55c521c94f360e13e">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a25c1fac0445beea55c521c94f360e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a25c1fac0445beea55c521c94f360e13e">More...</a><br/></td></tr>
<tr class="separator:a25c1fac0445beea55c521c94f360e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a20a82151947fc8816c5ce5b7bc6d8abd">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a20a82151947fc8816c5ce5b7bc6d8abd">More...</a><br/></td></tr>
<tr class="separator:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6fb72caff19c8ce19dc6e3c25c79f7b8">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a6fb72caff19c8ce19dc6e3c25c79f7b8">More...</a><br/></td></tr>
<tr class="separator:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#accc97dd76490d575638ebb22da233a53">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:accc97dd76490d575638ebb22da233a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#accc97dd76490d575638ebb22da233a53">More...</a><br/></td></tr>
<tr class="separator:accc97dd76490d575638ebb22da233a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72208605f731144cab862feecb456a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae72208605f731144cab862feecb456a2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae72208605f731144cab862feecb456a2">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ae72208605f731144cab862feecb456a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#ae72208605f731144cab862feecb456a2">More...</a><br/></td></tr>
<tr class="separator:ae72208605f731144cab862feecb456a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51091bb67549e42c241f4e08e7d291d6">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a51091bb67549e42c241f4e08e7d291d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#a51091bb67549e42c241f4e08e7d291d6">More...</a><br/></td></tr>
<tr class="separator:a51091bb67549e42c241f4e08e7d291d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0dbeed50ff3f8630ea3cd54f9ecb804">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#ab0dbeed50ff3f8630ea3cd54f9ecb804">More...</a><br/></td></tr>
<tr class="separator:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abf9dcd5236495d3f581b31dd05b9a227">get_base1</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abf9dcd5236495d3f581b31dd05b9a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#abf9dcd5236495d3f581b31dd05b9a227">More...</a><br/></td></tr>
<tr class="separator:abf9dcd5236495d3f581b31dd05b9a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac54b1427fd9d0765f0200dc9caa830f9">get_base1_lhs</a> (std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ac54b1427fd9d0765f0200dc9caa830f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#ac54b1427fd9d0765f0200dc9caa830f9">More...</a><br/></td></tr>
<tr class="separator:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d5711f99869d05a6263218f3256e582">get_base1_lhs</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a4d5711f99869d05a6263218f3256e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a4d5711f99869d05a6263218f3256e582">More...</a><br/></td></tr>
<tr class="separator:a4d5711f99869d05a6263218f3256e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37f3ceaa6197904ef662f1edc8245e1a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a37f3ceaa6197904ef662f1edc8245e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a37f3ceaa6197904ef662f1edc8245e1a">More...</a><br/></td></tr>
<tr class="separator:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3132eb36eaf861cfbd119b38e0a85a15">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a3132eb36eaf861cfbd119b38e0a85a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a3132eb36eaf861cfbd119b38e0a85a15">More...</a><br/></td></tr>
<tr class="separator:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afbcc061003aabcaf675f4415adc80c0a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:afbcc061003aabcaf675f4415adc80c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#afbcc061003aabcaf675f4415adc80c0a">More...</a><br/></td></tr>
<tr class="separator:afbcc061003aabcaf675f4415adc80c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1958245532761be08be7ac9bc781f3a7">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a1958245532761be08be7ac9bc781f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a1958245532761be08be7ac9bc781f3a7">More...</a><br/></td></tr>
<tr class="separator:a1958245532761be08be7ac9bc781f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aedc7fc712ebe439bec1892c8f69447cd">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aedc7fc712ebe439bec1892c8f69447cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aedc7fc712ebe439bec1892c8f69447cd">More...</a><br/></td></tr>
<tr class="separator:aedc7fc712ebe439bec1892c8f69447cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a64467731d9abfaf97ea8d541d528142c">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a64467731d9abfaf97ea8d541d528142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a64467731d9abfaf97ea8d541d528142c">More...</a><br/></td></tr>
<tr class="separator:a64467731d9abfaf97ea8d541d528142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd7246170c1c0cade6c7be73f436e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbdd7246170c1c0cade6c7be73f436e0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abbdd7246170c1c0cade6c7be73f436e0">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abbdd7246170c1c0cade6c7be73f436e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#abbdd7246170c1c0cade6c7be73f436e0">More...</a><br/></td></tr>
<tr class="separator:abbdd7246170c1c0cade6c7be73f436e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8cb7e6e670cddcdf5527ec92fa3ff37">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#af8cb7e6e670cddcdf5527ec92fa3ff37">More...</a><br/></td></tr>
<tr class="separator:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffeab694f7588c92dc97b6736e5be7b">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:adffeab694f7588c92dc97b6736e5be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#adffeab694f7588c92dc97b6736e5be7b">More...</a><br/></td></tr>
<tr class="separator:adffeab694f7588c92dc97b6736e5be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6133d90708e16760b6394c6ca6a305ff">get_base1_lhs</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6133d90708e16760b6394c6ca6a305ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#a6133d90708e16760b6394c6ca6a305ff">More...</a><br/></td></tr>
<tr class="separator:a6133d90708e16760b6394c6ca6a305ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fd1b6e6ba9738332204bae823dc006"><td class="memTemplParams" colspan="2">template&lt;typename T_lp , typename T_lp_accum &gt; </td></tr>
<tr class="memitem:ac0fd1b6e6ba9738332204bae823dc006"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_lp, T_lp_accum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0fd1b6e6ba9738332204bae823dc006">get_lp</a> (const T_lp &amp;lp, const <a class="el" href="classstan_1_1math_1_1accumulator.html">stan::math::accumulator</a>&lt; T_lp_accum &gt; &amp;lp_accum)</td></tr>
<tr class="separator:ac0fd1b6e6ba9738332204bae823dc006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140b54b11069aed039f67c6dd172256b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a140b54b11069aed039f67c6dd172256b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a140b54b11069aed039f67c6dd172256b">head</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:a140b54b11069aed039f67c6dd172256b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the front of the specified vector.  <a href="#a140b54b11069aed039f67c6dd172256b">More...</a><br/></td></tr>
<tr class="separator:a140b54b11069aed039f67c6dd172256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7964d83597ea54cd7ba63bee50409f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d7964d83597ea54cd7ba63bee50409f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d7964d83597ea54cd7ba63bee50409f">head</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:a4d7964d83597ea54cd7ba63bee50409f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the front of the specified row vector.  <a href="#a4d7964d83597ea54cd7ba63bee50409f">More...</a><br/></td></tr>
<tr class="separator:a4d7964d83597ea54cd7ba63bee50409f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e746ba14994b318a0a192a97a0a28db">head</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a5e746ba14994b318a0a192a97a0a28db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the front of the specified standard vector.  <a href="#a5e746ba14994b318a0a192a97a0a28db">More...</a><br/></td></tr>
<tr class="separator:a5e746ba14994b318a0a192a97a0a28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af81e05dfd6918524dafff10715f21a8d">initialize</a> (T &amp;x, const T &amp;v)</td></tr>
<tr class="separator:af81e05dfd6918524dafff10715f21a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad7882cc7a7e2e07016e006d2092427"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a5ad7882cc7a7e2e07016e006d2092427"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; V &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ad7882cc7a7e2e07016e006d2092427">initialize</a> (T &amp;x, V v)</td></tr>
<tr class="separator:a5ad7882cc7a7e2e07016e006d2092427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename V &gt; </td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1cb47e7569cabd57a1c0c6816ca48293">initialize</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad27706378f77dc22746ad74721d495d4">initialize</a> (std::vector&lt; T &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:ad27706378f77dc22746ad74721d495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461598c914f5634fa5057da7a817803d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a461598c914f5634fa5057da7a817803d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a461598c914f5634fa5057da7a817803d">inverse</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a461598c914f5634fa5057da7a817803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified matrix.  <a href="#a461598c914f5634fa5057da7a817803d">More...</a><br/></td></tr>
<tr class="separator:a461598c914f5634fa5057da7a817803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989989548db02c34cd6134790bd93478"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a989989548db02c34cd6134790bd93478"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a989989548db02c34cd6134790bd93478">inverse_spd</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a989989548db02c34cd6134790bd93478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified symmetric, pos/neg-definite matrix.  <a href="#a989989548db02c34cd6134790bd93478">More...</a><br/></td></tr>
<tr class="separator:a989989548db02c34cd6134790bd93478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3e7ce33064686ec2a2591fa5d4227cf">log</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise logarithm of the matrix or vector.  <a href="#ae3e7ce33064686ec2a2591fa5d4227cf">More...</a><br/></td></tr>
<tr class="separator:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca29dad18932e3ca17ac52fd0238b364">log_determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:aca29dad18932e3ca17ac52fd0238b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#aca29dad18932e3ca17ac52fd0238b364">More...</a><br/></td></tr>
<tr class="separator:aca29dad18932e3ca17ac52fd0238b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d95f632b80e8653fe5891209bdeda45"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a1d95f632b80e8653fe5891209bdeda45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1d95f632b80e8653fe5891209bdeda45">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;A)</td></tr>
<tr class="separator:a1d95f632b80e8653fe5891209bdeda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae9a296d4414d0193108c70b350a05cfc">log_determinant_spd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae9a296d4414d0193108c70b350a05cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#ae9a296d4414d0193108c70b350a05cfc">More...</a><br/></td></tr>
<tr class="separator:ae9a296d4414d0193108c70b350a05cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a8c8bb83f9b6c700a725240be33b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a011a8c8bb83f9b6c700a725240be33b5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a011a8c8bb83f9b6c700a725240be33b5">log_softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a011a8c8bb83f9b6c700a725240be33b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the softmax of the specified vector.  <a href="#a011a8c8bb83f9b6c700a725240be33b5">More...</a><br/></td></tr>
<tr class="separator:a011a8c8bb83f9b6c700a725240be33b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb47266493c7da21a6508944d65bdf"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac1fb47266493c7da21a6508944d65bdf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1fb47266493c7da21a6508944d65bdf">log_sum_exp</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:ac1fb47266493c7da21a6508944d65bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="#ac1fb47266493c7da21a6508944d65bdf">More...</a><br/></td></tr>
<tr class="separator:ac1fb47266493c7da21a6508944d65bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#a5da0ef87756d3dbd20ca4ff5a3efa10d">More...</a><br/></td></tr>
<tr class="separator:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acde414919e0e4dcfa72d565679819091">max</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:acde414919e0e4dcfa72d565679819091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#acde414919e0e4dcfa72d565679819091">More...</a><br/></td></tr>
<tr class="separator:acde414919e0e4dcfa72d565679819091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3f299773dc20e8305fc16df1be8d029">max</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae3f299773dc20e8305fc16df1be8d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified vector, row vector, or matrix.  <a href="#ae3f299773dc20e8305fc16df1be8d029">More...</a><br/></td></tr>
<tr class="separator:ae3f299773dc20e8305fc16df1be8d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266758367e8260b2afbfaeea7d5b418"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7266758367e8260b2afbfaeea7d5b418"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7266758367e8260b2afbfaeea7d5b418">mdivide_left</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a7266758367e8260b2afbfaeea7d5b418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a7266758367e8260b2afbfaeea7d5b418">More...</a><br/></td></tr>
<tr class="separator:a7266758367e8260b2afbfaeea7d5b418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a13f35ed7f2fe36be55d293ba733a"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a012a13f35ed7f2fe36be55d293ba733a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a012a13f35ed7f2fe36be55d293ba733a">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a012a13f35ed7f2fe36be55d293ba733a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a012a13f35ed7f2fe36be55d293ba733a">More...</a><br/></td></tr>
<tr class="separator:a012a13f35ed7f2fe36be55d293ba733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c8c6e72f1cbf2b73008d4fc98de1abe">mdivide_left_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#a0c8c6e72f1cbf2b73008d4fc98de1abe">More...</a><br/></td></tr>
<tr class="separator:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9ffa799f8af2cd4941cbd2506bc4573">mdivide_left_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#ac9ffa799f8af2cd4941cbd2506bc4573">More...</a><br/></td></tr>
<tr class="separator:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dbd828faf06c2ef74152367f749ca4"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a58dbd828faf06c2ef74152367f749ca4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58dbd828faf06c2ef74152367f749ca4">mdivide_left_tri</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="memdesc:a58dbd828faf06c2ef74152367f749ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="#a58dbd828faf06c2ef74152367f749ca4">More...</a><br/></td></tr>
<tr class="separator:a58dbd828faf06c2ef74152367f749ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a199a9357715dff8b9a3bae8cc1bb4aa5">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8391d23da9e29f3420fdb89116e83cd"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:ae8391d23da9e29f3420fdb89116e83cd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae8391d23da9e29f3420fdb89116e83cd">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="separator:ae8391d23da9e29f3420fdb89116e83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5efba9dddcf77889b66c1210ba55cf5f">mdivide_right</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a5efba9dddcf77889b66c1210ba55cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a5efba9dddcf77889b66c1210ba55cf5f">More...</a><br/></td></tr>
<tr class="separator:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c862e90d97ea5d5552101b65978813"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a68c862e90d97ea5d5552101b65978813"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a68c862e90d97ea5d5552101b65978813">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a68c862e90d97ea5d5552101b65978813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a68c862e90d97ea5d5552101b65978813">More...</a><br/></td></tr>
<tr class="separator:a68c862e90d97ea5d5552101b65978813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d77bf4121d56b8491092164d1523ce"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a01d77bf4121d56b8491092164d1523ce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a01d77bf4121d56b8491092164d1523ce">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;b, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R2, C2 &gt; &amp;A)</td></tr>
<tr class="separator:a01d77bf4121d56b8491092164d1523ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d6f32dd8adc4a9ffa28d63b62d4c90f">mdivide_right_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#a5d6f32dd8adc4a9ffa28d63b62d4c90f">More...</a><br/></td></tr>
<tr class="separator:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae158767243e09b91b9ba6cd366e7dab8"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ae158767243e09b91b9ba6cd366e7dab8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae158767243e09b91b9ba6cd366e7dab8">mdivide_right_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:ae158767243e09b91b9ba6cd366e7dab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#ae158767243e09b91b9ba6cd366e7dab8">More...</a><br/></td></tr>
<tr class="separator:ae158767243e09b91b9ba6cd366e7dab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09f35fbeab4d8ff311ce77d91492e26b">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a09f35fbeab4d8ff311ce77d91492e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A.  <a href="#a09f35fbeab4d8ff311ce77d91492e26b">More...</a><br/></td></tr>
<tr class="separator:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3443c4ac994b039a7f055c55c5afa8a3">mean</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a3443c4ac994b039a7f055c55c5afa8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified standard vector.  <a href="#a3443c4ac994b039a7f055c55c5afa8a3">More...</a><br/></td></tr>
<tr class="separator:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8074c0041b93407c473fd26a7c45dc88">mean</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8074c0041b93407c473fd26a7c45dc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8074c0041b93407c473fd26a7c45dc88">More...</a><br/></td></tr>
<tr class="separator:a8074c0041b93407c473fd26a7c45dc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f076860549f63d55c0e4985dce78099"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f076860549f63d55c0e4985dce78099">min</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a3f076860549f63d55c0e4985dce78099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a3f076860549f63d55c0e4985dce78099">More...</a><br/></td></tr>
<tr class="separator:a3f076860549f63d55c0e4985dce78099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e9c3a01030d96fd4c8f28e2ed8d3d61">min</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a9e9c3a01030d96fd4c8f28e2ed8d3d61">More...</a><br/></td></tr>
<tr class="separator:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86f2380e5c54a549e0f74ffd51204d33">min</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a86f2380e5c54a549e0f74ffd51204d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified matrix, vector, or row vector.  <a href="#a86f2380e5c54a549e0f74ffd51204d33">More...</a><br/></td></tr>
<tr class="separator:a86f2380e5c54a549e0f74ffd51204d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87b343d6dc12982c2b76c453650c0797">minus</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a87b343d6dc12982c2b76c453650c0797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negation of the specified scalar or matrix.  <a href="#a87b343d6dc12982c2b76c453650c0797">More...</a><br/></td></tr>
<tr class="separator:a87b343d6dc12982c2b76c453650c0797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a919d4a6495c489841df3d0423200b147">multiply</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a919d4a6495c489841df3d0423200b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <a href="#a919d4a6495c489841df3d0423200b147">More...</a><br/></td></tr>
<tr class="separator:a919d4a6495c489841df3d0423200b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5a2b6dbfb5543b73dac8496091745ec1">multiply</a> (T c, const Eigen::Matrix&lt; double, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a5a2b6dbfb5543b73dac8496091745ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified scalar multiplied by specified matrix.  <a href="#a5a2b6dbfb5543b73dac8496091745ec1">More...</a><br/></td></tr>
<tr class="separator:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c72cdca253e0230e0dbd19400781b5c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7c72cdca253e0230e0dbd19400781b5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c72cdca253e0230e0dbd19400781b5c">multiply</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a7c72cdca253e0230e0dbd19400781b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="#a7c72cdca253e0230e0dbd19400781b5c">More...</a><br/></td></tr>
<tr class="separator:a7c72cdca253e0230e0dbd19400781b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplParams" colspan="2">template&lt;int C1, int R2&gt; </td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e67698775aaac248efa49b646ca2a51">multiply</a> (const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a6e67698775aaac248efa49b646ca2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <a href="#a6e67698775aaac248efa49b646ca2a51">More...</a><br/></td></tr>
<tr class="separator:a6e67698775aaac248efa49b646ca2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c953951f141b35277fe2308777cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c0c953951f141b35277fe2308777cff">multiply_lower_tri_self_transpose</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;L)</td></tr>
<tr class="memdesc:a3c0c953951f141b35277fe2308777cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="#a3c0c953951f141b35277fe2308777cff">More...</a><br/></td></tr>
<tr class="separator:a3c0c953951f141b35277fe2308777cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac360c5b10dbf87d81e346f2be7d19ade">num_elements</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ac360c5b10dbf87d81e346f2be7d19ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, the number of elements in a primitive type.  <a href="#ac360c5b10dbf87d81e346f2be7d19ade">More...</a><br/></td></tr>
<tr class="separator:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e716815601bf5055a2d7fbfd8a757ea">num_elements</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e716815601bf5055a2d7fbfd8a757ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the specified matrix.  <a href="#a3e716815601bf5055a2d7fbfd8a757ea">More...</a><br/></td></tr>
<tr class="separator:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a38a5d6d7f867666902fcd0adbe602920">num_elements</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a38a5d6d7f867666902fcd0adbe602920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified vector.  <a href="#a38a5d6d7f867666902fcd0adbe602920">More...</a><br/></td></tr>
<tr class="separator:a38a5d6d7f867666902fcd0adbe602920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1649a895ec6e79097d5645a3f8b8a1e6">prod</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified standard vector.  <a href="#a1649a895ec6e79097d5645a3f8b8a1e6">More...</a><br/></td></tr>
<tr class="separator:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7082de8742d87f7a0fa0842207341c9">prod</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7082de8742d87f7a0fa0842207341c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified column vector.  <a href="#ad7082de8742d87f7a0fa0842207341c9">More...</a><br/></td></tr>
<tr class="separator:ad7082de8742d87f7a0fa0842207341c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91458631115a8d1cf29298431f745556"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:a91458631115a8d1cf29298431f745556"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a91458631115a8d1cf29298431f745556">promote_common</a> (const F &amp;u)</td></tr>
<tr class="separator:a91458631115a8d1cf29298431f745556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d52e361a0193272276fe4ed57cd8ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7d52e361a0193272276fe4ed57cd8ab"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7d52e361a0193272276fe4ed57cd8ab">qr_Q</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:aa7d52e361a0193272276fe4ed57cd8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d6852cc39664aa5b5a6f69665746c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a376d6852cc39664aa5b5a6f69665746c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a376d6852cc39664aa5b5a6f69665746c">qr_R</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a376d6852cc39664aa5b5a6f69665746c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf914518093a808041339a8c259e096"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:a6cf914518093a808041339a8c259e096"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cf914518093a808041339a8c259e096">quad_form</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a6cf914518093a808041339a8c259e096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute B^T A B.  <a href="#a6cf914518093a808041339a8c259e096">More...</a><br/></td></tr>
<tr class="separator:a6cf914518093a808041339a8c259e096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, typename T &gt; </td></tr>
<tr class="memitem:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8166027d80ecdbc607ef3c1c44fd1e8d">quad_form</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bbfca6cef0653589e949c9247e406e"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:a56bbfca6cef0653589e949c9247e406e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a56bbfca6cef0653589e949c9247e406e">quad_form_sym</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a56bbfca6cef0653589e949c9247e406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, typename T &gt; </td></tr>
<tr class="memitem:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8b0b2bfea6c360dcc5739fd908b39d60">quad_form_sym</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010e06b84cba3460961d4939e1278783"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a010e06b84cba3460961d4939e1278783"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; typename promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, Dynamic, <br class="typebreak"/>
Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a010e06b84cba3460961d4939e1278783">quad_form_diag</a> (const Matrix&lt; T1, Dynamic, Dynamic &gt; &amp;mat, const Matrix&lt; T2, R, C &gt; &amp;vec)</td></tr>
<tr class="separator:a010e06b84cba3460961d4939e1278783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1baa9539e0a8d4ea50aa16b73d736d93">rank</a> (const std::vector&lt; T &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a1baa9539e0a8d4ea50aa16b73d736d93">More...</a><br/></td></tr>
<tr class="separator:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a808d3133624cd36ac410ba872ea653c2">rank</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a808d3133624cd36ac410ba872ea653c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a808d3133624cd36ac410ba872ea653c2">More...</a><br/></td></tr>
<tr class="separator:a808d3133624cd36ac410ba872ea653c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fd1c6f1cd56836b049489009d2221"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad31fd1c6f1cd56836b049489009d2221"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad31fd1c6f1cd56836b049489009d2221">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:ad31fd1c6f1cd56836b049489009d2221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79febbfc52e2118819bb0eb77fbea561"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79febbfc52e2118819bb0eb77fbea561"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79febbfc52e2118819bb0eb77fbea561">rep_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, int n)</td></tr>
<tr class="separator:a79febbfc52e2118819bb0eb77fbea561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa70f063ee9a5790fbed08ba8ae07c52e">rep_matrix</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, int m)</td></tr>
<tr class="separator:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9d77ddf6ad38a102ebd6f5e433c3e6c">rep_row_vector</a> (const T &amp;x, int m)</td></tr>
<tr class="separator:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b132ea41ccfdb7b0ca4897cbb64649a">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8abf3ffa6d67a158348134225c9d3090">resize</a> (T &amp;x, std::vector&lt; size_t &gt; <a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a>)</td></tr>
<tr class="memdesc:a8abf3ffa6d67a158348134225c9d3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices.  <a href="#a8abf3ffa6d67a158348134225c9d3090">More...</a><br/></td></tr>
<tr class="separator:a8abf3ffa6d67a158348134225c9d3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab540ec1825d8a36cf690a3f061d544bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab540ec1825d8a36cf690a3f061d544bb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab540ec1825d8a36cf690a3f061d544bb">row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i)</td></tr>
<tr class="memdesc:ab540ec1825d8a36cf690a3f061d544bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified matrix, using start-at-1 indexing.  <a href="#ab540ec1825d8a36cf690a3f061d544bb">More...</a><br/></td></tr>
<tr class="separator:ab540ec1825d8a36cf690a3f061d544bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adb157990709e17068a450238d0a579fb">rows</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:adb157990709e17068a450238d0a579fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e1fb33918f8c4e61cc7709905db012c">rows_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6e1fb33918f8c4e61cc7709905db012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6e1fb33918f8c4e61cc7709905db012c">More...</a><br/></td></tr>
<tr class="separator:a6e1fb33918f8c4e61cc7709905db012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7b071fe169e76df6dc2a49c85ec28b2f">rows_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="#a7b071fe169e76df6dc2a49c85ec28b2f">More...</a><br/></td></tr>
<tr class="separator:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34fd02fe795ea38c98f4a02befed309f">sd</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a34fd02fe795ea38c98f4a02befed309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified column vector.  <a href="#a34fd02fe795ea38c98f4a02befed309f">More...</a><br/></td></tr>
<tr class="separator:a34fd02fe795ea38c98f4a02befed309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e1cb72c1528f0ff383033c642341147">sd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8e1cb72c1528f0ff383033c642341147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8e1cb72c1528f0ff383033c642341147">More...</a><br/></td></tr>
<tr class="separator:a8e1cb72c1528f0ff383033c642341147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e828d606f1a1c8faf42e6d901089543"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e828d606f1a1c8faf42e6d901089543"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4e828d606f1a1c8faf42e6d901089543">segment</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="memdesc:a4e828d606f1a1c8faf42e6d901089543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector.  <a href="#a4e828d606f1a1c8faf42e6d901089543">More...</a><br/></td></tr>
<tr class="separator:a4e828d606f1a1c8faf42e6d901089543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad2c340addebdc88ac086b0e1fac2c1b7">segment</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="separator:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a721232b5c8e7c068a120719255f5fb0c">segment</a> (const std::vector&lt; T &gt; &amp;sv, size_t i, size_t n)</td></tr>
<tr class="separator:a721232b5c8e7c068a120719255f5fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a204f15e3685b2c610ca2c0c80a3005d5">singular_values</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a204f15e3685b2c610ca2c0c80a3005d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the singular values of the specified matrix in decreasing order of magnitude.  <a href="#a204f15e3685b2c610ca2c0c80a3005d5">More...</a><br/></td></tr>
<tr class="separator:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa1f9966aade9c4515d33d3ffa7305462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724679c01caa9ae44c146fe8019ddcf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a724679c01caa9ae44c146fe8019ddcf6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6">softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a724679c01caa9ae44c146fe8019ddcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <a href="#a724679c01caa9ae44c146fe8019ddcf6">More...</a><br/></td></tr>
<tr class="separator:a724679c01caa9ae44c146fe8019ddcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a80f5418b16ea26e9bc6d2a8f9b764897">sort_asc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order.  <a href="#a80f5418b16ea26e9bc6d2a8f9b764897">More...</a><br/></td></tr>
<tr class="separator:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0b2712eab9b95535c0589455ed11cfc">sort_desc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:ab0b2712eab9b95535c0589455ed11cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order.  <a href="#ab0b2712eab9b95535c0589455ed11cfc">More...</a><br/></td></tr>
<tr class="separator:ab0b2712eab9b95535c0589455ed11cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aea0d013ec0a699e61dd74f32aa722fa0">sort_asc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:aea0d013ec0a699e61dd74f32aa722fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in ascending order.  <a href="#aea0d013ec0a699e61dd74f32aa722fa0">More...</a><br/></td></tr>
<tr class="separator:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a13ae8cd1155e8c4c684efb4405a1e277">sort_desc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:a13ae8cd1155e8c4c684efb4405a1e277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in descending order.  <a href="#a13ae8cd1155e8c4c684efb4405a1e277">More...</a><br/></td></tr>
<tr class="separator:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4a13ccb29cba05ef0daa9712ee9bf7a3">sort_indices_asc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="#a4a13ccb29cba05ef0daa9712ee9bf7a3">More...</a><br/></td></tr>
<tr class="separator:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27f6f9085eb850e9e0fcb98df345aeba">sort_indices_desc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a27f6f9085eb850e9e0fcb98df345aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="#a27f6f9085eb850e9e0fcb98df345aeba">More...</a><br/></td></tr>
<tr class="separator:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be3830eeabd6536a75897d0b90f7b1"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a65be3830eeabd6536a75897d0b90f7b1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65be3830eeabd6536a75897d0b90f7b1">squared_distance</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a65be3830eeabd6536a75897d0b90f7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between the specified vectors.  <a href="#a65be3830eeabd6536a75897d0b90f7b1">More...</a><br/></td></tr>
<tr class="separator:a65be3830eeabd6536a75897d0b90f7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c14b7fd70050f03a07fdf73a1df06d2">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37cb2d874adcc950cb0439af044f549f">stan_print</a> (std::ostream *o, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a37cb2d874adcc950cb0439af044f549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae94f7170ee85d4b353f55e3a044d2345">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="separator:ae94f7170ee85d4b353f55e3a044d2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9c9057d71cf2795d0042f665c0f89c1">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffa61a0521d0c07b8c4cd7ccbbb4aca">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63cf32e07d51c4ebfe042dd452eeae14">sub_col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:a63cf32e07d51c4ebfe042dd452eeae14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x 1 subcolumn starting at (i-1,j-1).  <a href="#a63cf32e07d51c4ebfe042dd452eeae14">More...</a><br/></td></tr>
<tr class="separator:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ea780efd8d0282dbf069f0776d727b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1ea780efd8d0282dbf069f0776d727b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1ea780efd8d0282dbf069f0776d727b">sub_row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:aa1ea780efd8d0282dbf069f0776d727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x nrows subrow starting at (i-1,j-1).  <a href="#aa1ea780efd8d0282dbf069f0776d727b">More...</a><br/></td></tr>
<tr class="separator:aa1ea780efd8d0282dbf069f0776d727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a90c28e884c638ed67fa0c81ffc01e2d3">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second specified matrix from the first specified matrix.  <a href="#a90c28e884c638ed67fa0c81ffc01e2d3">More...</a><br/></td></tr>
<tr class="separator:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36726c055970205db893867a77e9d0a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a36726c055970205db893867a77e9d0a7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a36726c055970205db893867a77e9d0a7">subtract</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a36726c055970205db893867a77e9d0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776789f307db599fddcda6a68c480557"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a776789f307db599fddcda6a68c480557"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a776789f307db599fddcda6a68c480557">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="separator:a776789f307db599fddcda6a68c480557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1efee0b4f8879a114af50b7e9802745c">sum</a> (const std::vector&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1efee0b4f8879a114af50b7e9802745c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the values in the specified standard vector.  <a href="#a1efee0b4f8879a114af50b7e9802745c">More...</a><br/></td></tr>
<tr class="separator:a1efee0b4f8879a114af50b7e9802745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44c32c2d7e895378feb11c99091765ad">sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:a44c32c2d7e895378feb11c99091765ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified column vector.  <a href="#a44c32c2d7e895378feb11c99091765ad">More...</a><br/></td></tr>
<tr class="separator:a44c32c2d7e895378feb11c99091765ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2770a97397fc738125d70420393fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5b2770a97397fc738125d70420393fb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac5b2770a97397fc738125d70420393fb">tail</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:ac5b2770a97397fc738125d70420393fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the back of the specified vector.  <a href="#ac5b2770a97397fc738125d70420393fb">More...</a><br/></td></tr>
<tr class="separator:ac5b2770a97397fc738125d70420393fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7ae4ee69ace75bb2fb216247ab8272ec">tail</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the back of the specified row vector.  <a href="#a7ae4ee69ace75bb2fb216247ab8272ec">More...</a><br/></td></tr>
<tr class="separator:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9956cf78180c6340f61667e797cf7055">tail</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="separator:a9956cf78180c6340f61667e797cf7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b07b3f7d18cdb710806c5793a83d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16b07b3f7d18cdb710806c5793a83d31">tcrossprod</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a16b07b3f7d18cdb710806c5793a83d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="#a16b07b3f7d18cdb710806c5793a83d31">More...</a><br/></td></tr>
<tr class="separator:a16b07b3f7d18cdb710806c5793a83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7001fd7e0296d5dae6ab0a88e1a28547">trace</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <a href="#a7001fd7e0296d5dae6ab0a88e1a28547">More...</a><br/></td></tr>
<tr class="separator:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb2aa245d794e2a6c352038f4811a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fb2aa245d794e2a6c352038f4811a37"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fb2aa245d794e2a6c352038f4811a37">trace</a> (const T &amp;m)</td></tr>
<tr class="separator:a8fb2aa245d794e2a6c352038f4811a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d451ecbf0b92587211925755a19008"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , int R1, int C1, int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:a67d451ecbf0b92587211925755a19008"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T1 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T2 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T3 &gt;::value, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2, T3 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a67d451ecbf0b92587211925755a19008">trace_gen_inv_quad_form_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;D, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:a67d451ecbf0b92587211925755a19008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplParams" colspan="2">template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09d402800ee27ba77d03dc3ec365d22e">trace_gen_quad_form</a> (const Eigen::Matrix&lt; double, RD, CD &gt; &amp;D, const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a09d402800ee27ba77d03dc3ec365d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(D B^T A B).  <a href="#a09d402800ee27ba77d03dc3ec365d22e">More...</a><br/></td></tr>
<tr class="separator:a09d402800ee27ba77d03dc3ec365d22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244c73de6ba86a3d2e7101ee681d1542"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:a244c73de6ba86a3d2e7101ee681d1542"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T1 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T2 &gt;::value, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a244c73de6ba86a3d2e7101ee681d1542">trace_inv_quad_form_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T2, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:a244c73de6ba86a3d2e7101ee681d1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a097af33142548fd565d1dab2233fa3e5">trace_quad_form</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a097af33142548fd565d1dab2233fa3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <a href="#a097af33142548fd565d1dab2233fa3e5">More...</a><br/></td></tr>
<tr class="separator:a097af33142548fd565d1dab2233fa3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db6bf273b69e20dc12e0c348b928296"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a9db6bf273b69e20dc12e0c348b928296"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9db6bf273b69e20dc12e0c348b928296">transpose</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a9db6bf273b69e20dc12e0c348b928296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f321e8f26d8d62ca9b3d7eb66c7068"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a42f321e8f26d8d62ca9b3d7eb66c7068"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a>&lt; T &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a42f321e8f26d8d62ca9b3d7eb66c7068">value_of</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;M)</td></tr>
<tr class="memdesc:a42f321e8f26d8d62ca9b3d7eb66c7068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <a href="#a42f321e8f26d8d62ca9b3d7eb66c7068">More...</a><br/></td></tr>
<tr class="separator:a42f321e8f26d8d62ca9b3d7eb66c7068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded9e89210ba1a66b9160aed3acef34"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8ded9e89210ba1a66b9160aed3acef34"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8ded9e89210ba1a66b9160aed3acef34">value_of_rec</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;M)</td></tr>
<tr class="memdesc:a8ded9e89210ba1a66b9160aed3acef34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <a href="#a8ded9e89210ba1a66b9160aed3acef34">More...</a><br/></td></tr>
<tr class="separator:a8ded9e89210ba1a66b9160aed3acef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa433ac2fc47bbd40a6d87f62574dff85">variance</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa433ac2fc47bbd40a6d87f62574dff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector.  <a href="#aa433ac2fc47bbd40a6d87f62574dff85">More...</a><br/></td></tr>
<tr class="separator:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f055da8754c2215aac70d7787692f54">variance</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a1f055da8754c2215aac70d7787692f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector.  <a href="#a1f055da8754c2215aac70d7787692f54">More...</a><br/></td></tr>
<tr class="separator:a1f055da8754c2215aac70d7787692f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9becde1f060be033b72797b2b577d5a3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9becde1f060be033b72797b2b577d5a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a><br class="typebreak"/>
&lt; T1, T2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9becde1f060be033b72797b2b577d5a3">integrate_ode</a> (const F &amp;f, const std::vector&lt; T1 &gt; y0, const double t0, const std::vector&lt; double &gt; &amp;ts, const std::vector&lt; T2 &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs)</td></tr>
<tr class="memdesc:a9becde1f060be033b72797b2b577d5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solutions for the specified system of ordinary differential equations given the specified initial state, initial times, times of desired solution, and parameters and data, writing error and warning messages to the specified stream.  <a href="#a9becde1f060be033b72797b2b577d5a3">More...</a><br/></td></tr>
<tr class="separator:a9becde1f060be033b72797b2b577d5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2421cf831c518a6260f60d19eb5c32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada2421cf831c518a6260f60d19eb5c32"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada2421cf831c518a6260f60d19eb5c32">F32</a> (T a, T b, T c, T d, T <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, T z, T precision=1e-6)</td></tr>
<tr class="separator:ada2421cf831c518a6260f60d19eb5c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43226a00b6c2d3f3a2ab5906490f3136">grad_2F1</a> (T &amp;gradA, T &amp;gradC, T a, T b, T c, T z, T precision=1e-6)</td></tr>
<tr class="separator:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd0b6c85425c2005e265d8e66852a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02dd0b6c85425c2005e265d8e66852a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a02dd0b6c85425c2005e265d8e66852a8">grad_F32</a> (T *g, T a, T b, T c, T d, T <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, T z, T precision=1e-6)</td></tr>
<tr class="separator:a02dd0b6c85425c2005e265d8e66852a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb272bd839945c13d7b41058c35c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a33cb272bd839945c13d7b41058c35c51">grad_inc_beta</a> (double &amp;g1, double &amp;g2, double a, double b, double z)</td></tr>
<tr class="separator:a33cb272bd839945c13d7b41058c35c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a11eeb59eb3ae4f0710a7e417478c1212">grad_reg_inc_beta</a> (T &amp;g1, T &amp;g2, T a, T b, T z, T digammaA, T digammaB, T digammaSum, T betaAB)</td></tr>
<tr class="separator:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6336e9873f3029f5abe54c4914c71cb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6336e9873f3029f5abe54c4914c71cb2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6336e9873f3029f5abe54c4914c71cb2">grad_reg_inc_gamma</a> (T a, T z, T g, T dig, T precision=1e-6)</td></tr>
<tr class="separator:a6336e9873f3029f5abe54c4914c71cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01192e5a2e1c208f78818b57b4d6aa78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a01192e5a2e1c208f78818b57b4d6aa78">inc_beta</a> (const double &amp;a, const double &amp;b, const double &amp;x)</td></tr>
<tr class="separator:a01192e5a2e1c208f78818b57b4d6aa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aece739c5a2672028f0c7848045b89f08"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aece739c5a2672028f0c7848045b89f08">CONSTRAINT_TOLERANCE</a> = 1E-8</td></tr>
<tr class="memdesc:aece739c5a2672028f0c7848045b89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance for checking arithmetic bounds In rank and in simplexes.  <a href="#aece739c5a2672028f0c7848045b89f08">More...</a><br/></td></tr>
<tr class="separator:aece739c5a2672028f0c7848045b89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f94e47c6dc073bbd3929903b4431fe"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66f94e47c6dc073bbd3929903b4431fe">E</a> = boost::math::constants::e&lt;double&gt;()</td></tr>
<tr class="memdesc:a66f94e47c6dc073bbd3929903b4431fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_270.png"/>.  <a href="#a66f94e47c6dc073bbd3929903b4431fe">More...</a><br/></td></tr>
<tr class="separator:a66f94e47c6dc073bbd3929903b4431fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a> = std::sqrt(2.0)</td></tr>
<tr class="memdesc:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_271.png"/>.  <a href="#a491d6e40aaa2a3e205ea6708dc3c75dd">More...</a><br/></td></tr>
<tr class="separator:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e346d5a812af988f8de4a5948c88"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5491e346d5a812af988f8de4a5948c88">INV_SQRT_2</a> = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td></tr>
<tr class="memdesc:a5491e346d5a812af988f8de4a5948c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_272.png"/>.  <a href="#a5491e346d5a812af988f8de4a5948c88">More...</a><br/></td></tr>
<tr class="separator:a5491e346d5a812af988f8de4a5948c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43fb48f0a7f26bc60c1dfb572283b149">LOG_2</a> = std::log(2.0)</td></tr>
<tr class="memdesc:a43fb48f0a7f26bc60c1dfb572283b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_273.png"/>.  <a href="#a43fb48f0a7f26bc60c1dfb572283b149">More...</a><br/></td></tr>
<tr class="separator:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773773e2db53015eb48ab1730816fb5"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab773773e2db53015eb48ab1730816fb5">LOG_10</a> = std::log(10.0)</td></tr>
<tr class="memdesc:ab773773e2db53015eb48ab1730816fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_274.png"/>.  <a href="#ab773773e2db53015eb48ab1730816fb5">More...</a><br/></td></tr>
<tr class="separator:ab773773e2db53015eb48ab1730816fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7f2ac8ebf3095e9934715bb34f0669b3">INFTY</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <a href="#a7f2ac8ebf3095e9934715bb34f0669b3">More...</a><br/></td></tr>
<tr class="separator:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa37d0f67f02e0a0b5797ed9f4df56bfb">NEGATIVE_INFTY</a> = - std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <a href="#aa37d0f67f02e0a0b5797ed9f4df56bfb">More...</a><br/></td></tr>
<tr class="separator:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf147700a2e38335abc618b2c913b8a"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cf147700a2e38335abc618b2c913b8a">NOT_A_NUMBER</a> = std::numeric_limits&lt;double&gt;::quiet_NaN()</td></tr>
<tr class="memdesc:a9cf147700a2e38335abc618b2c913b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Quiet) not-a-number value.  <a href="#a9cf147700a2e38335abc618b2c913b8a">More...</a><br/></td></tr>
<tr class="separator:a9cf147700a2e38335abc618b2c913b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ffd625c2083751d7ccabb7dbe39cbe0">EPSILON</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest positive value.  <a href="#a5ffd625c2083751d7ccabb7dbe39cbe0">More...</a><br/></td></tr>
<tr class="separator:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcea3a9752d079c9f972040b873b704"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1dcea3a9752d079c9f972040b873b704">NEGATIVE_EPSILON</a> = - std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a1dcea3a9752d079c9f972040b873b704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest negative value (i.e., smallest absolute value).  <a href="#a1dcea3a9752d079c9f972040b873b704">More...</a><br/></td></tr>
<tr class="separator:a1dcea3a9752d079c9f972040b873b704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177764626d2378e0d7bdfb26aac187b6"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a177764626d2378e0d7bdfb26aac187b6">LOG_PI_OVER_FOUR</a> = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td></tr>
<tr class="separator:a177764626d2378e0d7bdfb26aac187b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935530f53a026ebb80fcd9006059e9c8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a> = 2.0 / std::sqrt(boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a935530f53a026ebb80fcd9006059e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a344504ea0c1f4f956c85ea8027a07ba9">NEG_TWO_OVER_SQRT_PI</a> = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td></tr>
<tr class="separator:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d54686aa26009d0e9101be42afd877"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44d54686aa26009d0e9101be42afd877">INV_SQRT_TWO_PI</a> = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a44d54686aa26009d0e9101be42afd877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrices and templated mathematical functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac1a24821b475ee296830ebac12f70460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">stan::math::matrix_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for matrix of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac105e584e4ed2d24a5c3a40df4d94697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,1,Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac105e584e4ed2d24a5c3a40df4d94697">stan::math::row_vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (row) vector of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7989b1f96eb2793fa94b0f373ee29a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a>&lt;Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; &gt;::type <a class="el" href="namespacestan_1_1math.html#ae7989b1f96eb2793fa94b0f373ee29a8">stan::math::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for sizes and indexes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with double e. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c7ab54df86be3a3d61e58623c210d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,Eigen::Dynamic,1&gt; <a class="el" href="namespacestan_1_1math.html#a0c7ab54df86be3a3d61e58623c210d86">stan::math::vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (column) vector of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00030">30</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aeb4764556637084eee528b45d8eaa767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return floating-point absolute value. </p>
<p>Delegates to <code>fabs(double)</code> rather than <code>std::abs(int)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of scalar </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2abs_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2abs_8hpp_source.html">abs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d4b97f71328d3de40de286ec6e3754e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrices. </p>
<p>The two matrices must have the same dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if m1 and m2 do not have the same dimensions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00027">27</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa92ade0aeac74c8366b8c210446324a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrix and specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix plus the scalar. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00051">51</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4cbcb4a48d3284e93afe13093412683"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified scalar and specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar plus the matrix. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00072">72</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae16452cc0da4c7b77be53de0fcf3eed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::add_initial_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classstan_1_1agrad_1_1var.html">stan::agrad::var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classstan_1_1agrad_1_1var.html">stan::agrad::var</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the state derived from the coupled system in the with the original initial state. </p>
<p>This is necessary because the coupled system subtracts out the initial state in its representation when the initial state is unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>original initial values to add back into the coupled system. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>state of the coupled system on input, incremented with initial values on output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="agrad_2rev_2ode_2coupled__ode__system_8hpp_source.html#l00034">34</a> of file <a class="el" href="agrad_2rev_2ode_2coupled__ode__system_8hpp_source.html">coupled_ode_system.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61e4b84e31ce04be2750e4b906f8399d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, Dynamic, Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00023">23</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcc71c8083ea01c4e5ca7509118fdea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00051">51</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab63bad76023a50d55ea00393e9400d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, 1, Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 1, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, 1, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00066">66</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b5d7ce5cb34bedef6e8148889d4a075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, Dynamic, Dynamic&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00023">23</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23a581c504cbf0410ef66e9827b5137a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00051">51</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f65bb02e97a8403f5807f0650709817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, 1&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00066">66</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ec93b560b654740be65de81d6f348cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::as_bool </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the argument is unequal to zero and 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if argument is equal to zero (or NaN) and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2as__bool_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2functions_2as__bool_8hpp_source.html">as_bool.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f394c15ea3eb97743382631f91801cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHS &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will match arguments where the right-hand side is assignable to the left and they are not both <code>std::vector</code> or <code>Eigen::Matrix</code> types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00038">38</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5371f0f914e9b79a0700577e5557c0b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types, but whose shapes are not compatible. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R1</td><td>Row shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row shape of right-hand side matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column shape of right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00064">64</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a80c719463c4e3caa03df731e2c2cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape of both mtarices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00096">96</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4af3a90ad3b5ec1507dfc1823fdb8da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Block&lt; LHS &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shape of the right-hand side matrix is specified in the row and column shape template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of matrix block elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape for right-hand side matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape for right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side block view of matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00125">125</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c6dec98c71fd478c2ee16bc274b464d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>std::vector</code>, and will call <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> element-by element.</p>
<p>For example, a <code>std::vector&lt;int&gt;</code> can be assigned to a <code>std::vector&lt;double&gt;</code> using this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side vector elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side vector. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00157">157</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebfb3835848bd8550192cd5e090d3b5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_first\_kind}(v,x) = \begin{cases} J_v(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_251.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{bessel\_first\_kind}(v,x)}{\partial x} = \begin{cases} \frac{\partial\, J_v(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_252.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ J_v(x)=\left(\frac{1}{2}x\right)^v \sum_{k=0}^\infty \frac{\left(-\frac{1}{4}x^2\right)^k}{k!\, \Gamma(v+k+1)} \]" src="form_253.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, J_v(x)}{\partial x} = \frac{v}{x}J_v(x)-J_{v+1}(x) \]" src="form_254.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2bessel__first__kind_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2bessel__first__kind_8hpp_source.html">bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a645ce13c6454913ec39be807751604dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_second\_kind}(v,x) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ Y_v(x) &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_255.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{bessel\_second\_kind}(v,x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ \frac{\partial\, Y_v(x)}{\partial x} &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_256.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Y_v(x)=\frac{J_v(x)\cos(v\pi)-J_{-v}(x)}{\sin(v\pi)} \]" src="form_257.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Y_v(x)}{\partial x} = \frac{v}{x}Y_v(x)-Y_{v+1}(x) \]" src="form_258.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2bessel__second__kind_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2bessel__second__kind_8hpp_source.html">bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add2a043f562537b8cc57bb35780ac5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::binary_log_loss </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log loss function for binary classification with specified reference and response values. </p>
<p>The log loss function for prediction <img class="formulaInl" alt="$\hat{y} \in [0, 1]$" src="form_259.png"/> given outcome <img class="formulaInl" alt="$y \in \{ 0, 1 \}$" src="form_260.png"/> is</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(1,\hat{y}) = -\log \hat{y} $" src="form_261.png"/>, and</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(0,\hat{y}) = -\log (1 - \hat{y}) $" src="form_262.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Reference value in { 0 , 1 }. </td></tr>
    <tr><td class="paramname">y_hat</td><td>Response value in [0,1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log loss for response given reference value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2binary__log__loss_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2functions_2binary__log__loss_8hpp_source.html">binary_log_loss.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27dad23d38c6d5e74c65e7571c70272e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_N , typename T_n &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_N, T_n&gt;::type stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const T_N&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_n&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the binomial coefficient for the specified arguments. </p>
<p>The binomial coefficient, <img class="formulaInl" alt="${N \choose n}$" src="form_263.png"/>, read "N choose n", is defined for <img class="formulaInl" alt="$0 \leq n \leq N$" src="form_264.png"/> by</p>
<p><img class="formulaInl" alt="${N \choose n} = \frac{N!}{n! (N-n)!}$" src="form_265.png"/>.</p>
<p>This function uses Gamma functions to define the log and generalize the arguments to continuous N and n.</p>
<p><img class="formulaInl" alt="$ \log {N \choose n} = \log \ \Gamma(N+1) - \log \Gamma(n+1) - \log \Gamma(N-n+1)$" src="form_266.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{binomial\_coefficient\_log}(x,y) = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ \ln\Gamma(x+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad -\ln\Gamma(y+1)&amp; \\ \quad -\ln\Gamma(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_267.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{binomial\_coefficient\_log}(x,y)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ \Psi(x+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad -\Psi(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_268.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{binomial\_coefficient\_log}(x,y)}{\partial y} = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ -\Psi(y+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad +\Psi(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_269.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>total number of objects. </td></tr>
    <tr><td class="paramname">n</td><td>number of objects chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log (N choose n). </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2binomial__coefficient__log_8hpp_source.html#l00063">63</a> of file <a class="el" href="math_2functions_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af163dfd071f1cff0297b7418156563a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::block </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x ncols submatrix starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row </td></tr>
    <tr><td class="paramname">j</td><td>Starting column </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="block_8hpp_source.html#l00023">23</a> of file <a class="el" href="block_8hpp_source.html">block.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16d53b31b377bc3fc120d6469af3d99e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_bounded </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the value is between the low and high values, inclusively. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of value </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of low value </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of high value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Value to check </td></tr>
    <tr><td class="paramname">low</td><td>Low bound </td></tr>
    <tr><td class="paramname">high</td><td>High bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is between low and high, inclusively. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>otherwise. This also throws if any of the arguments are NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__bounded_8hpp_source.html#l00094">94</a> of file <a class="el" href="check__bounded_8hpp_source.html">check_bounded.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3c1ad17fc5567f1599fa9d0a218620"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor. </p>
<p>A Cholesky factor is a lower triangular matrix whose diagonal elements are all positive. Note that Cholesky factors need not be square, but require at least as many rows M as columns N (i.e., M &gt;= N).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not a valid Choleksy factor, if number of rows is less than the number of columns, if there are 0 columns, or if any element in matrix is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00036">36</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f24b6f8e2a52523ae37a7ff2664e9b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor_corr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor of a correlation matrix. </p>
<p>A Cholesky factor is a lower triangular matrix whose diagonal elements are all positive. Note that Cholesky factors need not be square, but require at least as many rows M as columns N (i.e., M &gt;= N).</p>
<p>Tolerance is specified by <code><a class="el" href="namespacestan_1_1math.html#aece739c5a2672028f0c7848045b89f08" title="The tolerance for checking arithmetic bounds In rank and in simplexes. ">math::CONSTRAINT_TOLERANCE</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor of a correlation matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not a valid Choleksy factor, if number of rows is less than the number of columns, if there are 0 columns, or if any element in matrix is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor__corr_8hpp_source.html#l00040">40</a> of file <a class="el" href="check__cholesky__factor__corr_8hpp_source.html">check_cholesky_factor_corr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b0a60f741f97efac53254839f24ff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_column_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is a valid column of the matrix. </p>
<p>By default, this is a 1-indexed check (as opposed to 0-indexed). Behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>. This function will throw an <code>std::out_of_range</code> exception if the index is out of bounds.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">R</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Number of columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid column index of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is an invalid column index </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__column__index_8hpp_source.html#l00037">37</a> of file <a class="el" href="check__column__index_8hpp_source.html">check_column_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b6ab798e2f2a2ffad6b244efab0a58f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x is consistent, which is defined to be <code>expected_size</code> if x is a vector or 1 if x is not a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">expected_size</td><td>Expected size if x is a vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x is scalar or if x is vector-like and has size of <code>expected_size</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if the size is inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__size_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__consistent__size_8hpp_source.html">check_consistent_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1 is consistent with x2. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1 and x2 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00031">31</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fa5d10851fe1307ed7a0ffb768ff861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1, x2, and x3 are consistent. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2 </td></tr>
    <tr><td class="paramname">T3</td><td>Type of x3</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name3</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x3</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1, x2, and x3 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00066">66</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a817ff4687b2d9d98f7f7bf82e9286266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1, x2, x3, and x4 are consistent. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2 </td></tr>
    <tr><td class="paramname">T3</td><td>Type of x3 </td></tr>
    <tr><td class="paramname">T4</td><td>Type of x4</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name3</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x3</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name4</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x4</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1, x2, x3, and x4 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00107">107</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41204c48d930b46e81329d8b00a0793e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid correlation matrix. </p>
<p>A valid correlation matrix is symmetric, has a unit diagonal (all 1 values), and has all values between -1 and 1 (inclusive).</p>
<p>This function throws exceptions if the variable is not a valid correlation matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function this was called from </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified matrix is a valid correlation matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is non-symmetric, diagonals not near 1, not positive definite, or any of the elements nan. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__corr__matrix_8hpp_source.html#l00045">45</a> of file <a class="el" href="check__corr__matrix_8hpp_source.html">check_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb915b09e2e60dd76885b6d68655790c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid covariance matrix. </p>
<p>A valid covariance matrix is a square, symmetric matrix that is positive definite.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid covariance matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, if the matrix is not positive definite, or if any element of the matrix is nan </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d8cfae284cdae1bb7e83d2a136f9a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_eq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_eq &amp;&#160;</td>
          <td class="paramname"><em>eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is equal to <code>eq</code>. </p>
<p>This function is vectorized over both <code>y</code> and <code>eq</code>. If both <code>y</code> and <code>eq</code> are scalar or vector-like, then each element is compared in order. If one of <code>y</code> or <code>eq</code> are vector and the other is scalar, then the scalar is broadcast to the size of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of variable </td></tr>
    <tr><td class="paramname">T_eq</td><td>Type of comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check equality </td></tr>
    <tr><td class="paramname">eq</td><td>Expected value for y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is equal to eq </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is unequal to eq or if any element of y or eq is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__equal_8hpp_source.html#l00087">87</a> of file <a class="el" href="check__equal_8hpp_source.html">check_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf014e7733b17748049ccc5f3565de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is finite. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is finite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is infinity, -infinity, or NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__finite_8hpp_source.html#l00061">61</a> of file <a class="el" href="check__finite_8hpp_source.html">check_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad60ac97b8f74b7c5ce2feb4bdb9e09e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is strictly greater than <code>low</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>low</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">low</td><td>Lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is strictly greater than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not greater than low or if any element of y or low is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__greater_8hpp_source.html#l00080">80</a> of file <a class="el" href="check__greater_8hpp_source.html">check_greater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d5b19f8930c14681349d8444142487e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is greater or equal than <code>low</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>low</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">low</td><td>Lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater or equal than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not greater or equal to low or if any element of y or low is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__greater__or__equal_8hpp_source.html#l00081">81</a> of file <a class="el" href="check__greater__or__equal_8hpp_source.html">check_greater_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7547b05717280b1cc041309803ec797d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ldlt_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the argument is a valid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code>. </p>
<p><code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></code> can be constructed in an invalid state, so it must be checked. A invalid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></code> is constructed from a non positive definite matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar </td></tr>
    <tr><td class="paramname">R</td><td>Rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code> to check for validity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive definite. </dd>
<dd>
throws <code>std::domain_error</code> the <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> was created improperly (A.success() == false) </dd></dl>

<p>Definition at line <a class="el" href="check__ldlt__factor_8hpp_source.html#l00034">34</a> of file <a class="el" href="check__ldlt__factor_8hpp_source.html">check_ldlt_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab225792149dceaec443ce09b93f8744"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is strictly less than <code>high</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>high</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">high</td><td>Upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is strictly less than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not less than low or if any element of y or high is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__less_8hpp_source.html#l00077">77</a> of file <a class="el" href="check__less_8hpp_source.html">check_less.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9dd0895901bf876eca824b41f04003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>high</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">high</td><td>Upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is less than or equal to low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not less than or equal to low or if any element of y or high is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__less__or__equal_8hpp_source.html#l00077">77</a> of file <a class="el" href="check__less__or__equal_8hpp_source.html">check_less_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe34ba3113cc8f10f179873edb9b60ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is lower triangular. </p>
<p>A matrix x is not lower triangular if there is a non-zero entry x[m,n] with m &lt; n. This function only inspects the upper triangular portion of the matrix, not including the diagonal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is lower triangular. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not lower triangular or if any element in the upper triangular portion is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__lower__triangular_8hpp_source.html#l00035">35</a> of file <a class="el" href="check__lower__triangular_8hpp_source.html">check_lower_triangular.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1149504bbf29d464f23508ca5eccc0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_matching_dims </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the two matrices are of the same size. </p>
<p>This function checks not only the runtime sizes, but the static sizes as well. For example, a 4x1 matrix is not the same as a vector with 4 elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of the second matrix </td></tr>
    <tr><td class="paramname">R1</td><td>Rows specified at compile time of the first matrix </td></tr>
    <tr><td class="paramname">C1</td><td>Columns specified at compile time of the first matrix </td></tr>
    <tr><td class="paramname">R2</td><td>Rows specified at compile time of the second matrix </td></tr>
    <tr><td class="paramname">C2</td><td>Columns specified at compile time of the second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name for the first matrix (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First matrix </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name for the second matrix (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the dimensions of the two matrices match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the dimensions of the matrices do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__matching__dims_8hpp_source.html#l00037">37</a> of file <a class="el" href="check__matching__dims_8hpp_source.html">check_matching_dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52ba893fcf6fc650e992c13d41fbc3ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y1 , typename T_y2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y1 &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y2 &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if two structures at the same size. </p>
<p>This function only checks the runtime sizes for variables that implement a <code><a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size()</a></code> method.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y1</td><td>Type of the first variable </td></tr>
    <tr><td class="paramname">T_y2</td><td>Type of the second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>First variable name (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First variable </td></tr>
    <tr><td class="paramname">name2</td><td>Second variable name (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__matching__sizes_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__matching__sizes_8hpp_source.html">check_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cfbb4f09fe34b9ece32be051f16ce66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_multiplicable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the matrices can be multiplied. </p>
<p>This checks the runtime sizes to determine whether the two matrices are multiplicable. This allows <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices, vectors, and row vectors to be checked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name for the first matrix (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First matrix </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name for the second matrix (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two matrices are multiplicable </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrices are not multiplicable or if either matrix is size 0 for either rows or columns </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__multiplicable_8hpp_source.html#l00033">33</a> of file <a class="el" href="check__multiplicable_8hpp_source.html">check_multiplicable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6be100befb6d08504cf5af8440b236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonnegative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is non-negative. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater than or equal to 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is negative or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__nonnegative_8hpp_source.html#l00065">65</a> of file <a class="el" href="check__nonnegative_8hpp_source.html">check_nonnegative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97c3c23033e47a923ed5ce26a4deeba5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonzero_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix/vector is of non-zero size. </p>
<p>Throws a std:invalid_argument otherwise. The message will indicate that the variable name "has size 0".</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of container</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Container to test. This will accept matrices and vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the specified matrix/vector is of non-zero size </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the specified matrix/vector has zero size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__nonzero__size_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__nonzero__size_8hpp_source.html">check_nonzero_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7942532ef8f89cee24af75a383835ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_not_nan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is not <code>NaN</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code>. If any element is <code>NaN</code>, this function will throw an exception.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is not NaN. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__not__nan_8hpp_source.html#l00061">61</a> of file <a class="el" href="check__not__nan_8hpp_source.html">check_not_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7b212a4431aeedca59b2e94c84f788"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is sorted into strictly increasing order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Vector to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector elements are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00031">31</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55e7669a804e68bc9d39ecd06318b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T_y &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is sorted into strictly increasing order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code>std::vector</code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector elements are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00078">78</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0133fd07702f5253126a385703b7d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_definite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified square, symmetric matrix is positive definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive definite </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix has 0 size. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, if it is not positive definite, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="error__handling_2matrix_2check__pos__definite_8hpp_source.html#l00034">34</a> of file <a class="el" href="error__handling_2matrix_2check__pos__definite_8hpp_source.html">check_pos_definite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa26244f58d5a4dfd49181b39d9b4569b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is positive definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>scalar type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive semi-definite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix has 0 size. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, or if it is not positive semi-definite, or if any element of the matrix is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__pos__semidefinite_8hpp_source.html#l00036">36</a> of file <a class="el" href="check__pos__semidefinite_8hpp_source.html">check_pos_semidefinite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a814694b1125e641ca7b2e7269c82f966"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is positive. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater than 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is negative or zero or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive_8hpp_source.html#l00066">66</a> of file <a class="el" href="check__positive_8hpp_source.html">check_positive.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0725693b09e454f5c8327ac89cf0245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is positive and finite. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of y is greater than 0 and y is not infinite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if any element of y is not positive or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__finite_8hpp_source.html#l00028">28</a> of file <a class="el" href="check__positive__finite_8hpp_source.html">check_positive_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87f00a8c0f07c5a82145a14712437673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector contains non-negative values and is sorted into strictly increasing order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Vector to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is positive, ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector contains non-positive values, if the values are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__ordered_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__positive__ordered_8hpp_source.html">check_positive_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6fe1398a136f3dc36d246a2ea747500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>size</code> is positive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">expr</td><td>Expression for the dimension size (for error messages) </td></tr>
    <tr><td class="paramname">size</td><td>Size value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>size</code> is greater than 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>size</code> is zero or negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__size_8hpp_source.html#l00023">23</a> of file <a class="el" href="check__positive__size_8hpp_source.html">check_positive_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcd4dcac328824f71f31d6861b8610ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nested_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check </td></tr>
    <tr><td class="paramname">nested_level</td><td>Nested level (for error messages) </td></tr>
    <tr><td class="paramname">error_msg</td><td>Additional error message (for error messages)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00028">28</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8822ad6a9b8706465e8e1f90c336e3c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check </td></tr>
    <tr><td class="paramname">error_msg</td><td>Additional error message (for error messages)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00061">61</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e76ffb67d3c6c6c225b0ba7b991f449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00088">88</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb080867499e68f688b0dcb5c8f4e061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_row_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is a valid row of the matrix. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
    <tr><td class="paramname">R</td><td>Compile time rows </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test </td></tr>
    <tr><td class="paramname">i</td><td>is index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid row index in the matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__row__index_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__row__index_8hpp_source.html">check_row_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6affd19d4999c427291a2bbb07bce304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_simplex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is simplex. </p>
<p>To be a simplex, all values must be greater than or equal to 0 and the values must sum to 1.</p>
<p>A valid simplex is one where the sum of hte elements is equal to 1. This function tests that the sum is within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>. This function only accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors, statically typed vectors, not general matrices with 1 column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Scalar type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a simplex </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>theta</code> is a 0-vector. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector is not a simplex or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__simplex_8hpp_source.html#l00041">41</a> of file <a class="el" href="check__simplex_8hpp_source.html">check_simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa547146eaac690e79a611e50a6dffb4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the provided sizes match. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_size1</td><td>Type of size 1 </td></tr>
    <tr><td class="paramname">T_size2</td><td>Type of size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name_i</td><td>Variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">i</td><td>Size 1 </td></tr>
    <tr><td class="paramname">name_j</td><td>Variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">j</td><td>Size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c66b22fce7bd878b687d550299eb248"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the provided sizes match. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_size1</td><td>Type of size 1 </td></tr>
    <tr><td class="paramname">T_size2</td><td>Type of size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">expr_i</td><td>Expression for variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">name_i</td><td>Variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">i</td><td>Size 1 </td></tr>
    <tr><td class="paramname">expr_j</td><td>Expression for variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">name_j</td><td>Variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">j</td><td>Size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00067">67</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30d5ef4f11dbce1a670766034b416339"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_spsd_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square, symmetric, and positive semi-definite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric or if the matrix is not positive semi-definite </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__spsd__matrix_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__spsd__matrix_8hpp_source.html">check_spsd_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94cfaa76ca5bc3f0ea5ad1d5b9f80727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_square </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is square. </p>
<p>This check allows 0x0 matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__square_8hpp_source.html#l00028">28</a> of file <a class="el" href="check__square_8hpp_source.html">check_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ed873db07e833c14413c319a5bb9837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_std_vector_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is valid in std vector. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code>std::vector</code> to test </td></tr>
    <tr><td class="paramname">i</td><td>Index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid in std vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__std__vector__index_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__std__vector__index_8hpp_source.html">check_std_vector_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57384e961806a959d95a5444fd8d7190"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is symmetric. </p>
<p>The error message is either 0 or 1 indexed, specified by <code><a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is symmetric </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if any element not on the main diagonal is <code>NaN</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__symmetric_8hpp_source.html#l00038">38</a> of file <a class="el" href="check__symmetric_8hpp_source.html">check_symmetric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14e15ece9efbe2751549da6a598964c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_unit_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is unit vector. </p>
<p>A valid unit vector is one where the square of the elements summed is equal to 1. This function tests that the sum is within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>. This function only accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors, statically typed vectors, not general matrices with 1 column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Scalar type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a unit vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>theta</code> is a 0-vector. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector is not a unit vector or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__unit__vector_8hpp_source.html#l00038">38</a> of file <a class="el" href="check__unit__vector_8hpp_source.html">check_unit_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b78e5ddf65db13aaa65a6c58205fbf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the matrix is either a row vector or column vector. </p>
<p>This function checks the runtime size of the matrix to check whether it is a row or column vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the matrix </td></tr>
    <tr><td class="paramname">R</td><td>Compile time rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x</td><td>Matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x either has 1 columns or 1 rows </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if x is not a row or column vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__vector_8hpp_source.html#l00033">33</a> of file <a class="el" href="check__vector_8hpp_source.html">check_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbcc91ff24e86fa318fe0f8a9111b4c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. </p>
<p>The return value <img class="formulaInl" alt="$L$" src="form_394.png"/> will be a lower-traingular matrix such that the original matrix <img class="formulaInl" alt="$A$" src="form_395.png"/> is given by </p>
<p><img class="formulaInl" alt="$A = L \times L^T$" src="form_396.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Symmetrix matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square root of matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not a symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cholesky__decompose_8hpp_source.html#l00023">23</a> of file <a class="el" href="cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae497ca37fd7867fd11c4cd095c8aaa71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified column of the specified matrix using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.col(i - 1)</code> and assigning the resulting template expression to a column vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">j</td><td>Column index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified column of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="col_8hpp_source.html#l00024">24</a> of file <a class="el" href="col_8hpp_source.html">col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a871bccc233a4dcd764ffece5a3f9a399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::cols </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cols_8hpp_source.html#l00012">12</a> of file <a class="el" href="cols_8hpp_source.html">cols.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d03b34aa7329a68f31d1c7bc500c5c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2columns__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af03701ff6420231890468e9881eb9245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,C&gt; stan::math::columns_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each column of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2columns__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2columns__dot__self_8hpp_source.html">columns_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62cc3a137ff3220bdd0137a52a4b9714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::crossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of pre-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of M times M </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2crossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2crossprod_8hpp_source.html">crossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7340f6be8ae1e121c6d854005560fef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified vector. </p>
<p>The cumulative sum of a vector of values</p>
<div class="fragment"><div class="line"> is the</div>
<div class="line"></div>
<div class="line">@code x[0], x[1] + x[2], ..., x[1] + ,..., + x[x.size()-1] </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00023">23</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affab469ac332306aa00947f4a7c5d30b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified matrix. </p>
<p>The cumulative sum is of the same type as the input and has values defined by</p>
<div class="fragment"><div class="line">x(0), x(1) + x(2), ..., x(1) + ,..., + x(x.size()-1) </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00049">49</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab65e9ab0e6f725c7e11068b0be2af84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af970bc3201f476e84259e7ba2d4eb276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::diag_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a square diagonal matrix with the specified vector of coefficients as the diagonal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal matrix with vector as diagonal values. </dd></dl>

<p>Definition at line <a class="el" href="diag__matrix_8hpp_source.html#l00018">18</a> of file <a class="el" href="diag__matrix_8hpp_source.html">diag_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00896827d3247350178c86c0aed533f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1, C1&gt; stan::math::diag_post_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__post__multiply_8hpp_source.html#l00013">13</a> of file <a class="el" href="diag__post__multiply_8hpp_source.html">diag_post_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6159f8ffb5a37c394dff93781622f504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R2, C2&gt; stan::math::diag_pre_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__pre__multiply_8hpp_source.html#l00013">13</a> of file <a class="el" href="diag__pre__multiply_8hpp_source.html">diag_pre_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a877aa9df52c3a3f300a3d214c7bde64a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::diagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of the diagonal elements of the specified matrix. </p>
<p>The matrix is not required to be square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="diagonal_8hpp_source.html#l00018">18</a> of file <a class="el" href="diagonal_8hpp_source.html">diagonal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5eb54ce92709046c6d168e851d2481c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::digamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{digamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_275.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{digamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \frac{\partial\, \Psi(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_276.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi(x)=\frac{\Gamma'(x)}{\Gamma(x)} \]" src="form_277.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Psi(x)}{\partial x} = \frac{\Gamma''(x)\Gamma(x)-(\Gamma'(x))^2}{\Gamma^2(x)} \]" src="form_278.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2digamma_8hpp_source.html#l00039">39</a> of file <a class="el" href="math_2functions_2digamma_8hpp_source.html">digamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b9073e39033e56eb31344091f0170fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00013">13</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af95a2dcde478c06e3543511821618902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00018">18</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a467589eef4220a87d457c8a268a1fd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00025">25</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33777ee768c7032331ca8b92e5323384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00034">34</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae86020a972c6efc6b3407c3cfc30f4a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dist_8hpp_source.html#l00011">11</a> of file <a class="el" href="dist_8hpp_source.html">dist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a354d9d6e7465ec8a49116f276d971db1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distance_8hpp_source.html#l00025">25</a> of file <a class="el" href="distance_8hpp_source.html">distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf04cebee51d38a543e0ec689ae1399c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2divide_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a082ee76b34a2ea656d2c8ab9186c1a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix divided by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix divided by scalar. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2divide_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2matrix_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeebafad688145fc64353e4f455d014bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;&lt;msg2&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error_8hpp_source.html#l00032">32</a> of file <a class="el" href="domain__error_8hpp_source.html">domain_error.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a108d489a4a749c8e429b519d9e26c157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error_8hpp_source.html#l00067">67</a> of file <a class="el" href="domain__error_8hpp_source.html">domain_error.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c23bfe9ebcb5747ed175a59b2182072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error__vec_8hpp_source.html#l00037">37</a> of file <a class="el" href="domain__error__vec_8hpp_source.html">domain_error_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f55be80da8ff729d5850c653d2b28d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error__vec_8hpp_source.html#l00072">72</a> of file <a class="el" href="domain__error__vec_8hpp_source.html">domain_error_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd3b73319bd8df9dad1d3902997d8e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dot_8hpp_source.html#l00011">11</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8d73851895fb151fdf79e55bf33e98e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58da447df259e9e092e8fd910b338e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
    <tr><td class="paramname">length</td><td>Length of both arrays. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cd93708bf432b3bd3d284958972ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the vectors are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00050">50</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a6a4ef7c701db7984297d153580c8d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2dot__self_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac81ab85d390fcb594884773a85fac657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vector with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>number of rows or <code>Eigen::Dynamic</code> for dynamic </td></tr>
    <tr><td class="paramname">C</td><td>number of rows or <code>Eigen::Dyanmic</code> for dynamic </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If v is not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__self_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b650a0131d41167ef4837ecc7d02be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::e </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base of the natural logarithm. </p>
<dl class="section return"><dt>Returns</dt><dd>Base of natural logarithm. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00086">86</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa37c65f508af7ad1d0b010aa5c932cbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::eigenvalues_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the eigenvalues of the specified symmetric matrix in descending order of magnitude. </p>
<p>This function is more efficient than the general eigenvalues function for symmetric matrices. </p>
<p>See <code>eigen_decompose()</code> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of matrix. </dd></dl>

<p>Definition at line <a class="el" href="eigenvalues__sym_8hpp_source.html#l00022">22</a> of file <a class="el" href="eigenvalues__sym_8hpp_source.html">eigenvalues_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bd4729756e6ed00a35f1e4531444c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::eigenvectors_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="eigenvectors__sym_8hpp_source.html#l00013">13</a> of file <a class="el" href="eigenvectors__sym_8hpp_source.html">eigenvectors_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c9262da41fbf44fefc9a66141a0759d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00024">24</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0016fa774de95c513f4cc40ade45fad6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified matrix by the specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in the matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the scalar. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramname">s</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of a scalar by matrix. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00050">50</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf8fb8bfb6f2d9bdc1abbe4a7ceed06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified scalar by the specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the scalar. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in the matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>scalar </td></tr>
    <tr><td class="paramname">m</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of a scalar by matrix. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00068">68</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a998e2dce5971bba8c059995797e22ba0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise multiplication of the specified matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise product of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="elt__multiply_8hpp_source.html">elt_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac38f1fab5fe3e9b45c8c6e78ac3cc749"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Rows,Cols&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise exponentiation of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i,j) = exp(m(i,j)) </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2exp_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6004af7342e8187af0b1053da1b7deb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,Rows,Cols&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2exp_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2matrix_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef734d7c3b8ebd689012295bf826e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponent base 2 of the specified argument (C99). </p>
<p>The exponent base 2 function is defined by</p>
<p><code>exp2(y) = pow(2.0,y)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exponent base 2 of value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2exp2_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2exp2_8hpp_source.html">exp2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada2421cf831c518a6260f60d19eb5c32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::F32 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_f32_8hpp_source.html#l00011">11</a> of file <a class="el" href="_f32_8hpp_source.html">F32.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2df2a7019f7f68a915b3edab21921a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{falling\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_279.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{falling\_factorial}(x,n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, (x)_n}{\partial x} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_280.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{falling\_factorial}(x,n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, (x)_n}{\partial n} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_281.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ (x)_n=\frac{\Gamma(x+1)}{\Gamma(x-n+1)} \]" src="form_282.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, (x)_n}{\partial x} = (x)_n\Psi(x+1) \]" src="form_283.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, (x)_n}{\partial n} = -(x)_n\Psi(n+1) \]" src="form_284.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2falling__factorial_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2functions_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d2db622c0f83134b7f3ebd1eec3c1d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The positive difference function (C99). </p>
<p>The function is defined by</p>
<p><code>fdim(a,b) = (a &gt; b) ? (a - b) : 0.0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns min(a - b, 0.0). </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2fdim_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d362e53d3d40b61e68fdd08dc5eb38b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>This base case simply assigns the value to the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of reference container. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00022">22</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73e791042ed648602eed1754679feff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>The specified matrix is filled by element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar for matrix container. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00039">39</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f5d81c4d45f2407096def8810ffe00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>Each container in the specified standard vector is filled recursively by calling <code>fill</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of container in vector. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00055">55</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed411d626d4ae01a76584c454a83673f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_p}(a,z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ P(a,z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_285.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{gamma\_p}(a,z)}{\partial a} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, P(a,z)}{\partial a} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_286.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{gamma\_p}(a,z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, P(a,z)}{\partial z} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_287.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(a,z)=\frac{1}{\Gamma(a)}\int_0^zt^{a-1}e^{-t}dt \]" src="form_288.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, P(a,z)}{\partial a} = -\frac{\Psi(a)}{\Gamma^2(a)}\int_0^zt^{a-1}e^{-t}dt + \frac{1}{\Gamma(a)}\int_0^z (a-1)t^{a-2}e^{-t}dt \]" src="form_289.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, P(a,z)}{\partial z} = \frac{z^{a-1}e^{-z}}{\Gamma(a)} \]" src="form_290.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2gamma__p_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2functions_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0830ba049b81bc98ea9fbcf1eb7b4bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_q}(a,z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ Q(a,z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_291.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{gamma\_q}(a,z)}{\partial a} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, Q(a,z)}{\partial a} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_292.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{gamma\_q}(a,z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, Q(a,z)}{\partial z} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_293.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q(a,z)=\frac{1}{\Gamma(a)}\int_z^\infty t^{a-1}e^{-t}dt \]" src="form_294.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Q(a,z)}{\partial a} = -\frac{\Psi(a)}{\Gamma^2(a)}\int_z^\infty t^{a-1}e^{-t}dt + \frac{1}{\Gamma(a)}\int_z^\infty (a-1)t^{a-2}e^{-t}dt \]" src="form_295.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Q(a,z)}{\partial z} = -\frac{z^{a-1}e^{-z}}{\Gamma(a)} \]" src="form_296.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2gamma__q_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2functions_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7535c86e2c9ee9d5391a8cc63187317e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca7c84b936da0d3422507927cf9a68cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00053">53</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a714e39ba9fcbbd90c787a51d511c9af1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00081">81</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa23b355397df347249da513307fd6667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00111">111</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25c1fac0445beea55c521c94f360e13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00143">143</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20a82151947fc8816c5ce5b7bc6d8abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00177">177</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fb72caff19c8ce19dc6e3c25c79f7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00214">214</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accc97dd76490d575638ebb22da233a53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00253">253</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae72208605f731144cab862feecb456a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00292">292</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51091bb67549e42c241f4e08e7d291d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00319">319</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0dbeed50ff3f8630ea3cd54f9ecb804"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00346">346</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf9dcd5236495d3f581b31dd05b9a227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00371">371</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac54b1427fd9d0765f0200dc9caa830f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5711f99869d05a6263218f3256e582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00053">53</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37f3ceaa6197904ef662f1edc8245e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00081">81</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3132eb36eaf861cfbd119b38e0a85a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00111">111</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbcc061003aabcaf675f4415adc80c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00143">143</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1958245532761be08be7ac9bc781f3a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00177">177</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedc7fc712ebe439bec1892c8f69447cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00214">214</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64467731d9abfaf97ea8d541d528142c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00253">253</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbdd7246170c1c0cade6c7be73f436e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; &gt; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00293">293</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8cb7e6e670cddcdf5527ec92fa3ff37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00320">320</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffeab694f7588c92dc97b6736e5be7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00347">347</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6133d90708e16760b6394c6ca6a305ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00372">372</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fd1b6e6ba9738332204bae823dc006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_lp , typename T_lp_accum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_lp, T_lp_accum&gt;::type stan::math::get_lp </td>
          <td>(</td>
          <td class="paramtype">const T_lp &amp;&#160;</td>
          <td class="paramname"><em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1accumulator.html">stan::math::accumulator</a>&lt; T_lp_accum &gt; &amp;&#160;</td>
          <td class="paramname"><em>lp_accum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="get__lp_8hpp_source.html#l00011">11</a> of file <a class="el" href="get__lp_8hpp_source.html">get_lp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43226a00b6c2d3f3a2ab5906490f3136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_2F1 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>gradA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>gradC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__2_f1_8hpp_source.html#l00012">12</a> of file <a class="el" href="grad__2_f1_8hpp_source.html">grad_2F1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02dd0b6c85425c2005e265d8e66852a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_F32 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad___f32_8hpp_source.html#l00011">11</a> of file <a class="el" href="grad___f32_8hpp_source.html">grad_F32.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33cb272bd839945c13d7b41058c35c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_inc_beta </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2grad__inc__beta_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2grad__inc__beta_8hpp_source.html">grad_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11eeb59eb3ae4f0710a7e417478c1212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_reg_inc_beta </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>betaAB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__reg__inc__beta_8hpp_source.html#l00016">16</a> of file <a class="el" href="grad__reg__inc__beta_8hpp_source.html">grad_reg_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6336e9873f3029f5abe54c4914c71cb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::grad_reg_inc_gamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__reg__inc__gamma_8hpp_source.html#l00016">16</a> of file <a class="el" href="grad__reg__inc__gamma_8hpp_source.html">grad_reg_inc_gamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a140b54b11069aed039f67c6dd172256b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the front of the specified vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector input </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of v </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00024">24</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d7964d83597ea54cd7ba63bee50409f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the front of the specified row vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return row vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of rv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00042">42</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e746ba14994b318a0a192a97a0a28db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the specified number of elements as a standard vector from the front of the specified standard vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>Standard vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of sv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00058">58</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b430ac57e75ba2d55843cd868506e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::ibeta </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normalized incomplete beta function of a, b, and x. </p>
<p>Used to compute the cumulative density function for the beta distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Shape parameter a &lt;= 0; a and b can't both be 0 </td></tr>
    <tr><td class="paramname">b</td><td>Shape parameter b &lt;= 0 </td></tr>
    <tr><td class="paramname">x</td><td>Random variate. 0 &lt;= x &lt;= 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>constraints are violated or if any argument is NaN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized incomplete beta function. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2ibeta_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2ibeta_8hpp_source.html">ibeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa732732442d65936275d718b7286cb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_true , typename T_false &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_true,T_false&gt;::type stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_true&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_false&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the second argument if the first argument is true and otherwise return the second argument. </p>
<p>This is just a convenience method to provide a function with the same behavior as the built-in ternary operator. In general, this function behaves as if defined by</p>
<p><code>if_else(c,y1,y0) = c ? y1 : y0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition value. </td></tr>
    <tr><td class="paramname">y_true</td><td>Value to return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Value to return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2if__else_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01192e5a2e1c208f78818b57b4d6aa78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::inc_beta </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2inc__beta_8hpp_source.html#l00010">10</a> of file <a class="el" href="math_2inc__beta_8hpp_source.html">inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af81e05dfd6918524dafff10715f21a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00017">17</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ad7882cc7a7e2e07016e006d2092427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;V&gt;::value, void&gt;::type stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00023">23</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb47e7569cabd57a1c0c6816ca48293"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C, typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00027">27</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad27706378f77dc22746ad74721d495d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00032">32</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c507cff4b7b473cd86e1d428fb03136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int stan::math::int_step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer step, or Heaviside, function. </p>
<p>For double NaN input, int_step(NaN) returns 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{int\_step}(x) = \begin{cases} 0 &amp; \mbox{if } x \leq 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_297.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if value is greater than 0 and 0 otherwise </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar argument type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="int__step_8hpp_source.html#l00025">25</a> of file <a class="el" href="int__step_8hpp_source.html">int_step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9becde1f060be033b72797b2b577d5a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1,T2&gt;::type&gt; &gt; stan::math::integrate_ode </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T1 &gt;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the solutions for the specified system of ordinary differential equations given the specified initial state, initial times, times of desired solution, and parameters and data, writing error and warning messages to the specified stream. </p>
<p><b>Warning:</b> If the system of equations is stiff, roughly defined by having varying time scales across dimensions, then this solver is likely to be slow.</p>
<p>This function is templated to allow the initial times to be either data or autodiff variables and the parameters to be data or autodiff variables. The autodiff-based implementation for reverse-mode are defined in namespace <code><a class="el" href="namespacestan_1_1agrad.html" title="Function gradients via reverse-mode automatic differentiation. ">stan::agrad</a></code> and may be invoked via argument-dependent lookup by including their headers.</p>
<p>This function uses the <a href="http://en.wikipedia.org/wiki/Dormand–Prince_method">Dormand-Prince method</a> as implemented in Boost's <code> boost::numeric::odeint::runge_kutta_dopri5</code> integrator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type of ODE system function. </td></tr>
    <tr><td class="paramname">T1</td><td>type of scalars for initial values. </td></tr>
    <tr><td class="paramname">T2</td><td>type of scalars for parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>functor for the base ordinary differential equation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>initial state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>initial time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>times of the desired solutions, in strictly increasing order, all greater than the initial time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>parameter vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>continuous data vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_int</td><td>integer data vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td>the print stream for warning messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of states, each state being a vector of the same size as the state variable, corresponding to a time in ts. </dd></dl>

<p>Definition at line <a class="el" href="integrate__ode_8hpp_source.html#l00061">61</a> of file <a class="el" href="integrate__ode_8hpp_source.html">integrate_ode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab64935e0bdac8227bfd9608285d4e699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv_8hpp_source.html">inv.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a008bf0b6c2ab38d088b0aba5d7b10c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_cloglog </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse complementary log-log function. </p>
<p>The function is defined by</p>
<p><code>inv_cloglog(x) = 1 - exp(-exp(x))</code>.</p>
<p>This function can be used to implement the inverse link function for complementary-log-log regression.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_cloglog}(y) = \begin{cases} \mbox{cloglog}^{-1}(y) &amp; \mbox{if } -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_298.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{inv\_cloglog}(y)}{\partial y} = \begin{cases} \frac{\partial\, \mbox{cloglog}^{-1}(y)}{\partial y} &amp; \mbox{if } -\infty\leq y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_299.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{cloglog}^{-1}(y) = 1 - \exp \left( - \exp(y) \right) \]" src="form_300.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{cloglog}^{-1}(y)}{\partial y} = \exp(y-\exp(y)) \]" src="form_301.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse complementary log-log of the argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2inv__cloglog_8hpp_source.html#l00049">49</a> of file <a class="el" href="math_2functions_2inv__cloglog_8hpp_source.html">inv_cloglog.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c4834fc581f55acf8491ec3f80ecb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse logit function applied to the argument. </p>
<p>The inverse logit function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{logit}^{-1}(x) = \frac{1}{1 + \exp(-x)}$" src="form_302.png"/>.</p>
<p>This function can be used to implement the inverse link function for logistic regression.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#a53342d0c2cd3a6e440c533070054aca3" title="Returns the logit function applied to the argument. ">stan::math::logit</a></code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_logit}(y) = \begin{cases} \mbox{logit}^{-1}(y) &amp; \mbox{if } -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_303.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{inv\_logit}(y)}{\partial y} = \begin{cases} \frac{\partial\, \mbox{logit}^{-1}(y)}{\partial y} &amp; \mbox{if } -\infty\leq y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_304.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{logit}^{-1}(y) = \frac{1}{1 + \exp(-y)} \]" src="form_305.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{logit}^{-1}(y)}{\partial y} = \frac{\exp(y)}{(\exp(y)+1)^2} \]" src="form_306.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse logit of argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2inv__logit_8hpp_source.html#l00052">52</a> of file <a class="el" href="math_2functions_2inv__logit_8hpp_source.html">inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4db5e98585c71cc7c14319f96e0c04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_sqrt </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv__sqrt_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv__sqrt_8hpp_source.html">inv_sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d2e922aa13e2dfae510fc13d86eaea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv__square_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv__square_8hpp_source.html">inv_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bcb1af5657f92ccadf5204fc43377fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid_argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid argument. This will allow us to change the behavior for all functions at once.</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;&lt;msg2&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument_8hpp_source.html#l00031">31</a> of file <a class="el" href="invalid__argument_8hpp_source.html">invalid_argument.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacf5709c614035ef60053a348e18554c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid_argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid argument. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument_8hpp_source.html#l00066">66</a> of file <a class="el" href="invalid__argument_8hpp_source.html">invalid_argument.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add7b2630385b99ef7045818ba8fe2a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid arguments. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument__vec_8hpp_source.html#l00037">37</a> of file <a class="el" href="invalid__argument__vec_8hpp_source.html">invalid_argument_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a309a8690ee903eea7e5847e4d93483f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid arguments. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a3fd179fe8241fc295c97a4c316aaf30da0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument__vec_8hpp_source.html#l00072">72</a> of file <a class="el" href="invalid__argument__vec_8hpp_source.html">invalid_argument_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a461598c914f5634fa5057da7a817803d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2inverse_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2inverse_8hpp_source.html">inverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1edc35cc581dda178263f6a4a4fd1158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::inverse_softmax </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>simplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the inverse softmax of the simplex argument into the second argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6" title="Return the softmax of the specified vector. ">stan::math::softmax</a></code> for the inverse function and a definition of the relation.</p>
<p>The inverse softmax function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{inverse\_softmax}(x)[i] = \log x[i]$" src="form_307.png"/>.</p>
<p>This function defines the inverse of <code><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6" title="Return the softmax of the specified vector. ">stan::math::softmax</a></code> up to a scaling factor.</p>
<p>Because of the definition, values of 0.0 in the simplex are converted to negative infinity, and values of 1.0 are converted to 0.0.</p>
<p>There is no check that the input vector is a valid simplex vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>Simplex vector input. </td></tr>
    <tr><td class="paramname">y</td><td>Vector into which the inverse softmax is written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size of the input and output vectors differ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inverse__softmax_8hpp_source.html#l00034">34</a> of file <a class="el" href="inverse__softmax_8hpp_source.html">inverse_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a989989548db02c34cd6134790bd93478"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::inverse_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified symmetric, pos/neg-definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="inverse__spd_8hpp_source.html#l00019">19</a> of file <a class="el" href="inverse__spd_8hpp_source.html">inverse_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0020ce04cad9a5eb9b55abb690863fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::is_inf </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input is infinite and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespaceboost_1_1math.html#ad274b0c69c7bd9e4ca76ac7519fd9f74" title="Checks if the given number is infinite. ">boost::math::isinf</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is infinite. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2is__inf_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2is__inf_8hpp_source.html">is_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01488df30a81c36b1a00391b9541e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_nan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input is NaN and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespaceboost_1_1math.html#a3987c91e5ae7f757baf28ae8efc0fbbe" title="Checks if the given number is NaN. ">boost::math::isnan</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is NaN. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2is__nan_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2functions_2is__nan_8hpp_source.html">is_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40c14c26dc55a985e05695b3ff1eeef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_uninitialized </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the specified variable is uninitialized. </p>
<p>Arithmetic types are always initialized by definition (the value is not specified).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is uninitialized. </dd>
<dd>
false if input is NaN. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2is__uninitialized_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2is__uninitialized_8hpp_source.html">is_uninitialized.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ccdb3f505b7db61c510e59e97b947b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the beta function applied to the specified arguments. </p>
<p>The beta function is defined for <img class="formulaInl" alt="$a > 0$" src="form_308.png"/> and <img class="formulaInl" alt="$b > 0$" src="form_309.png"/> by</p>
<p><img class="formulaInl" alt="$\mbox{B}(a,b) = \frac{\Gamma(a) \Gamma(b)}{\Gamma(a+b)}$" src="form_310.png"/>.</p>
<p>This function returns its log,</p>
<p><img class="formulaInl" alt="$\log \mbox{B}(a,b) = \log \Gamma(a) + \log \Gamma(b) - \log \Gamma(a+b)$" src="form_311.png"/>.</p>
<p>See <a class="el" href="namespacestan_1_1agrad.html#acb8b7366b1ecbe633d2c96f1c8dc62b8">boost::math::lgamma()</a> for the double-based and <a class="el" href="namespacestan_1_1agrad.html" title="Function gradients via reverse-mode automatic differentiation. ">stan::agrad</a> for the variable-based log Gamma function.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lbeta}(\alpha,\beta) = \begin{cases} \ln\int_0^1 u^{\alpha - 1} (1 - u)^{\beta - 1} \, du &amp; \mbox{if } \alpha,\beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_312.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{lbeta}(\alpha,\beta)}{\partial \alpha} = \begin{cases} \Psi(\alpha)-\Psi(\alpha+\beta) &amp; \mbox{if } \alpha,\beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_313.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{lbeta}(\alpha,\beta)}{\partial \beta} = \begin{cases} \Psi(\beta)-\Psi(\alpha+\beta) &amp; \mbox{if } \alpha,\beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_314.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value </td></tr>
    <tr><td class="paramname">b</td><td>Second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log of the beta function applied to the two values. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first value. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2lbeta_8hpp_source.html#l00059">59</a> of file <a class="el" href="math_2functions_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a836f46d7f63f5118a32cad11382c0551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::lgamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lgamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \ln\Gamma(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_315.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{lgamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_316.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2lgamma_8hpp_source.html#l00031">31</a> of file <a class="el" href="math_2functions_2lgamma_8hpp_source.html">lgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ee0706b2cb6d2e1da2c3b6041c06a56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::lmgamma </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument. </p>
<p>The multivariate gamma function <img class="formulaInl" alt="$\Gamma_k(x)$" src="form_317.png"/> for dimensionality <img class="formulaInl" alt="$k$" src="form_318.png"/> and argument <img class="formulaInl" alt="$x$" src="form_319.png"/> is defined by</p>
<p><img class="formulaInl" alt="$\Gamma_k(x) = \pi^{k(k-1)/4} \, \prod_{j=1}^k \Gamma(x + (1 - j)/2)$" src="form_320.png"/>,</p>
<p>where <img class="formulaInl" alt="$\Gamma()$" src="form_321.png"/> is the gamma function.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lmgamma}(n,x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \ln\Gamma_n(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_322.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{lmgamma}(n,x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \frac{\partial\, \ln\Gamma_n(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_323.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ln\Gamma_n(x) = \pi^{n(n-1)/4} \, \prod_{j=1}^n \Gamma(x + (1 - j)/2) \]" src="form_324.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \ln\Gamma_n(x)}{\partial x} = \sum_{j=1}^n \Psi(x + (1 - j) / 2) \]" src="form_325.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of the multivariate gamma function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2lmgamma_8hpp_source.html#l00057">57</a> of file <a class="el" href="math_2functions_2lmgamma_8hpp_source.html">lmgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e7ce33064686ec2a2591fa5d4227cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Rows,Cols&gt; stan::math::log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise logarithm of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i,j) = log(m(i,j)) </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21f4f7c092e2bc9a089885628b86c004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of ten. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of ten. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00105">105</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f92092fb8a70b31d00898bbbe769612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one minus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m}(x) = \begin{cases} \ln(1-x) &amp; \mbox{if } x \leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_326.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log1m}(x)}{\partial x} = \begin{cases} -\frac{1}{1-x} &amp; \mbox{if } x \leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_327.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one minus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1m_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2log1m_8hpp_source.html">log1m.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce261caf05bd371c430e82a0e6389a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)). </p>
<p>This function is only defined for x&lt;0</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m\_exp}(x) = \begin{cases} \ln(1-\exp(x)) &amp; \mbox{if } x < 0 \\ \textrm{NaN} &amp; \mbox{if } x \geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_328.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{asinh}(x)}{\partial x} = \begin{cases} -\frac{\exp(x)}{1-\exp(x)} &amp; \mbox{if } x < 0 \\ \textrm{NaN} &amp; \mbox{if } x \geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_329.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2log1m__exp_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2log1m__exp_8hpp_source.html">log1m_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f71c696a5e0da4daab30e5f3704842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of 1 minus the inverse logit of the specified argument. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m\_inv\_logit}(x) = \begin{cases} -\ln(\exp(x)+1) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_330.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log1m\_inv\_logit}(x)}{\partial x} = \begin{cases} -\frac{\exp(x)}{\exp(x)+1} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_331.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of 1 minus the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1m__inv__logit_8hpp_source.html#l00036">36</a> of file <a class="el" href="math_2functions_2log1m__inv__logit_8hpp_source.html">log1m_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5166d3c58ad8ce0aedbf104179888b69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one plus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1p}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \ln(1+x)&amp; \mbox{if } x\geq -1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_332.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log1p}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \frac{1}{1+x} &amp; \mbox{if } x\geq -1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_333.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one plus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1p_8hpp_source.html#l00039">39</a> of file <a class="el" href="math_2functions_2log1p_8hpp_source.html">log1p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88151def26813dec3e04c4a8b9674091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 plus the exponential of the specified value without overflow. </p>
<p>This function is related to other special functions by:</p>
<p><code>log1p_exp(x) </code></p>
<p><code> = log1p(exp(a))</code></p>
<p><code> = log(1 + exp(x))</code></p>
<p><code> = log_sum_exp(0,x)</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1p\_exp}(x) = \begin{cases} \ln(1+\exp(x)) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_334.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log1p\_exp}(x)}{\partial x} = \begin{cases} \frac{\exp(x)}{1+\exp(x)} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_335.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2log1p__exp_8hpp_source.html#l00044">44</a> of file <a class="el" href="math_2functions_2log1p__exp_8hpp_source.html">log1p_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa25e1572bf46e3a6b9ee270f0c7e2c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base 2 logarithm of the argument (C99). </p>
<p>The function is defined by:</p>
<p><code>log2(a) = log(a) / std::log(2.0)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base 2 logarithm of the value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log2_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a947ba3fe3c87293f7c57395007100c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of two. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log2_8hpp_source.html#l00035">35</a> of file <a class="el" href="math_2functions_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca29dad18932e3ca17ac52fd0238b364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2log__determinant_8hpp_source.html">log_determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d95f632b80e8653fe5891209bdeda45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant_ldlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2log__determinant__ldlt_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2matrix_2log__determinant__ldlt_8hpp_source.html">log_determinant_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a296d4414d0193108c70b350a05cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__determinant__spd_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2matrix_2log__determinant__spd_8hpp_source.html">log_determinant_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac1dbafd4c2a129415e86f868fc0979a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2. </p>
<p>This function is only defined for x&lt;0</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_diff\_exp}(x,y) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ \ln(\exp(x)-\exp(y)) &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_336.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_diff\_exp}(x,y)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ \frac{\exp(x)}{\exp(x)-\exp(y)} &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_337.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_diff\_exp}(x,y)}{\partial y} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ -\frac{\exp(y)}{\exp(x)-\exp(y)} &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_338.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2log__diff__exp_8hpp_source.html#l00049">49</a> of file <a class="el" href="math_2functions_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9cb2f3f6c73b2005d9e9fadbad415bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_falling\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_339.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_falling\_factorial}(x,n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_340.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_falling\_factorial}(x,n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ -\Psi(n) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_341.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2log__falling__factorial_8hpp_source.html#l00041">41</a> of file <a class="el" href="math_2functions_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5be889d1ef4284654a04e400f5371a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of the inverse logit of the specified argument. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_inv\_logit}(x) = \begin{cases} \ln\left(\frac{1}{1+\exp(-x)}\right)&amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_342.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_inv\_logit}(x)}{\partial x} = \begin{cases} \frac{1}{1+\exp(x)} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_343.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log__inv__logit_8hpp_source.html#l00036">36</a> of file <a class="el" href="math_2functions_2log__inv__logit_8hpp_source.html">log_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b7b9cda7f1b3234cc4b3fc20e595482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log mixture density with specified mixing proportion and log densities. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \log \left( \theta \lambda_1 + (1 - \theta) \lambda_2 \right). \]" src="form_344.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \theta} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_345.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_1} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_346.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_2} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_347.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>mixing proportion in [0,1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda1</td><td>first log density. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda2</td><td>second log density. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log mixture of densities in specified proportion </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log__mix_8hpp_source.html#l00046">46</a> of file <a class="el" href="math_2functions_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf23285d755661c14ca29c3ba935b77d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_rising\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_348.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_rising\_factorial}(x,n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x+n) - \Psi(x) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_349.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_rising\_factorial}(x,n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x+n) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_350.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2log__rising__factorial_8hpp_source.html#l00041">41</a> of file <a class="el" href="math_2functions_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a011a8c8bb83f9b6c700a725240be33b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the softmax of the specified vector. </p>
<p><img class="formulaInl" alt="$ \log \mbox{softmax}(y) \ = \ y - \log \sum_{k=1}^K \exp(y_k) \ = \ y - \mbox{log\_sum\_exp}(y). $" src="form_397.png"/></p>
<p>For the log softmax function, the entries in the Jacobian are <img class="formulaInl" alt="$ \frac{\partial}{\partial y_m} \mbox{softmax}(y)[k] = \left\{ \begin{array}{ll} 1 - \mbox{softmax}(y)[m] &amp; \mbox{ if } m = k, \mbox{ and} \\[6pt] \mbox{softmax}(y)[m] &amp; \mbox{ if } m \neq k. \end{array} \right. $" src="form_398.png"/></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__softmax_8hpp_source.html#l00044">44</a> of file <a class="el" href="math_2matrix_2log__softmax_8hpp_source.html">log_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1fb47266493c7da21a6508944d65bdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified matrix of values. </p>
<p>The matrix may be a full matrix, a vector, or a row vector.</p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_356.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__sum__exp_8hpp_source.html#l00029">29</a> of file <a class="el" href="math_2matrix_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5f32f7cd1a5690a697f4031df569c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log sum of exponetials without overflow. </p>
<p><img class="formulaInl" alt="$\log (\exp(a) + \exp(b)) = m + \log(\exp(a-m) + \exp(b-m))$" src="form_351.png"/>,</p>
<p>where <img class="formulaInl" alt="$m = max(a,b)$" src="form_352.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_sum\_exp}(x,y) = \begin{cases} \ln(\exp(x)+\exp(y)) &amp; \mbox{if } -\infty\leq x,y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_353.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_sum\_exp}(x,y)}{\partial x} = \begin{cases} \frac{\exp(x)}{\exp(x)+\exp(y)} &amp; \mbox{if } -\infty\leq x,y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_354.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{log\_sum\_exp}(x,y)}{\partial y} = \begin{cases} \frac{\exp(y)}{\exp(x)+\exp(y)} &amp; \mbox{if } -\infty\leq x,y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_355.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html#l00049">49</a> of file <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e67f9b1692743a9db4462e98bb49ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified sequence of values. </p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_356.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html#l00068">68</a> of file <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc35bab2db89b3ceda66f11e1fa53ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_and </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 &amp;&amp; x2 != 0</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\&amp;\&amp;}(x,y) = \begin{cases} 0 &amp; \mbox{if } x = 0 \textrm{ or } y=0 \\ 1 &amp; \mbox{if } x,y \neq 0 \\[6pt] 1 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_357.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both x1 and x2 are not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__and_8hpp_source.html#l00030">30</a> of file <a class="el" href="logical__and_8hpp_source.html">logical_and.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2213736b55fd6696fa0120fd3fe72e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_eq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is equal to the second. </p>
<p>Equivalent to <code>x1 == x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 == x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__eq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__eq_8hpp_source.html">logical_eq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba86bfd994302061a0260e1202fca777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gt </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly greater than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gt_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gt_8hpp_source.html">logical_gt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6bb0b8623192207d35e207ea312d8be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is greater than or equal to the second. </p>
<p>Equivalent to <code>x1 &gt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gte_8hpp_source.html">logical_gte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b5bd91412749e10933f304b54aef88f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lt </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly less than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lt_8hpp_source.html#l00020">20</a> of file <a class="el" href="logical__lt_8hpp_source.html">logical_lt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3649d4c704962c4502cd6220a5e2230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is less than or equal to the second. </p>
<p>Equivalent to <code>x1 &lt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__lte_8hpp_source.html">logical_lte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad2fc9ce55dfac079d930335beb7e4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_negation </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical negation function which returns 1 if the input is equal to zero and 0 otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if input is equal to zero. </dd></dl>

<p>Definition at line <a class="el" href="logical__negation_8hpp_source.html#l00017">17</a> of file <a class="el" href="logical__negation_8hpp_source.html">logical_negation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a206eb210d8e7e2c718af25c40de8f9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_neq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is unequal to the second. </p>
<p>Equivalent to <code>x1 != x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 != x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__neq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__neq_8hpp_source.html">logical_neq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac74007e2d5f55d5ae4a308f535869aee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_or </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 || x2 != 0</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator||}(x,y) = \begin{cases} 0 &amp; \mbox{if } x,y=0 \\ 1 &amp; \mbox{if } x \neq 0 \textrm{ or } y\neq0\\[6pt] 1 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_358.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if either x1 or x2 is not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__or_8hpp_source.html#l00029">29</a> of file <a class="el" href="logical__or_8hpp_source.html">logical_or.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53342d0c2cd3a6e440c533070054aca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logit function applied to the argument. </p>
<p>The logit function is defined as for <img class="formulaInl" alt="$x \in [0,1]$" src="form_359.png"/> by returning the log odds of <img class="formulaInl" alt="$x$" src="form_319.png"/> treated as a probability,</p>
<p><img class="formulaInl" alt="$\mbox{logit}(x) = \log \left( \frac{x}{1 - x} \right)$" src="form_360.png"/>.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#ad2c4834fc581f55acf8491ec3f80ecb7" title="Returns the inverse logit function applied to the argument. ">stan::math::inv_logit</a></code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{logit}(x) = \begin{cases} \textrm{NaN}&amp; \mbox{if } x < 0 \textrm{ or } x > 1\\ \ln\frac{x}{1-x} &amp; \mbox{if } 0\leq x \leq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_361.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{logit}(x)}{\partial x} = \begin{cases} \textrm{NaN}&amp; \mbox{if } x < 0 \textrm{ or } x > 1\\ \frac{1}{x-x^2}&amp; \mbox{if } 0\leq x\leq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_362.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logit of the argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2logit_8hpp_source.html#l00044">44</a> of file <a class="el" href="math_2functions_2logit_8hpp_source.html">logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a173839dddd0a8ac8afa710b9e3d5008a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::machine_precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference between 1.0 and the next value representable. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum positive number. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00142">142</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86b6be1d580b3b5cf4b4f57546062352"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functions_2max_8hpp_source.html#l00007">7</a> of file <a class="el" href="functions_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5da0ef87756d3dbd20ca4ff5a3efa10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the size of the vector is zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00019">19</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde414919e0e4dcfa72d565679819091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00037">37</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f299773dc20e8305fc16df1be8d029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00054">54</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7266758367e8260b2afbfaeea7d5b418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a012a13f35ed7f2fe36be55d293ba733a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__ldlt_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c8c6e72f1cbf2b73008d4fc98de1abe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__spd_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2matrix_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9ffa799f8af2cd4941cbd2506bc4573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1,C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58dbd828faf06c2ef74152367f749ca4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R1,C1&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular and b=I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 . </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html#l00049">49</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a199a9357715dff8b9a3bae8cc1bb4aa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1,C2&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8391d23da9e29f3420fdb89116e83cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R1,C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html#l00032">32</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5efba9dddcf77889b66c1210ba55cf5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__right_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68c862e90d97ea5d5552101b65978813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__ldlt_8hpp_source.html#l00025">25</a> of file <a class="el" href="mdivide__right__ldlt_8hpp_source.html">mdivide_right_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01d77bf4121d56b8491092164d1523ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R1,C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mdivide__right__ldlt_8hpp_source.html#l00037">37</a> of file <a class="el" href="mdivide__right__ldlt_8hpp_source.html">mdivide_right_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6f32dd8adc4a9ffa28d63b62d4c90f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__spd_8hpp_source.html#l00028">28</a> of file <a class="el" href="mdivide__right__spd_8hpp_source.html">mdivide_right_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae158767243e09b91b9ba6cd366e7dab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__tri_8hpp_source.html#l00028">28</a> of file <a class="el" href="mdivide__right__tri_8hpp_source.html">mdivide_right_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09f35fbeab4d8ff311ce77d91492e26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b * tri(A)^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__right__tri__low_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3443c4ac994b039a7f055c55c5afa8a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00023">23</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8074c0041b93407c473fd26a7c45dc88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00040">40</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab360c822174f211838f5979760c7e09e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functions_2min_8hpp_source.html#l00007">7</a> of file <a class="el" href="functions_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f076860549f63d55c0e4985dce78099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00018">18</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e9c3a01030d96fd4c8f28e2ed8d3d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00036">36</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86f2380e5c54a549e0f74ffd51204d33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified matrix, vector, or row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix, vector, or row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00053">53</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87b343d6dc12982c2b76c453650c0797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::minus </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negation of the specified scalar or matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negation of subtrahend. </dd></dl>

<p>Definition at line <a class="el" href="minus_8hpp_source.html#l00016">16</a> of file <a class="el" href="minus_8hpp_source.html">minus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acafecf14b103c7c17da33368d07b1565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_first\_kind}(v,z) = \begin{cases} I_v(z) &amp; \mbox{if } -\infty\leq z \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_363.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{modified\_bessel\_first\_kind}(v,z)}{\partial z} = \begin{cases} \frac{\partial\, I_v(z)}{\partial z} &amp; \mbox{if } -\infty\leq z\leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_364.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {I_v}(z) = \left(\frac{1}{2}z\right)^v\sum_{k=0}^\infty \frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(v+k+1)} \]" src="form_365.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, I_v(z)}{\partial z} = I_{v-1}(z)-\frac{v}{z}I_v(z) \]" src="form_366.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2modified__bessel__first__kind_8hpp_source.html#l00039">39</a> of file <a class="el" href="math_2functions_2modified__bessel__first__kind_8hpp_source.html">modified_bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72ce86f3db5478cad4666c9cf1d05a6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_second\_kind}(v,z) = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ K_v(z) &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_367.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{modified\_bessel\_second\_kind}(v,z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ \frac{\partial\, K_v(z)}{\partial z} &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_368.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {K_v}(z) = \frac{\pi}{2}\cdot\frac{I_{-v}(z) - I_{v}(z)}{\sin(v\pi)} \]" src="form_369.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, K_v(z)}{\partial z} = -\frac{v}{z}K_v(z)-K_{v-1}(z) \]" src="form_370.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2modified__bessel__second__kind_8hpp_source.html#l00042">42</a> of file <a class="el" href="math_2functions_2modified__bessel__second__kind_8hpp_source.html">modified_bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcf62df7cae63f67b1c5c67651bc8dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::modulus </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="modulus_8hpp_source.html#l00011">11</a> of file <a class="el" href="modulus_8hpp_source.html">modulus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919d4a6495c489841df3d0423200b147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix multiplied by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of matrix and scalar. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a2b6dbfb5543b73dac8496091745ec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified scalar multiplied by specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalar and matrix. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00045">45</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c72cdca253e0230e0dbd19400781b5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R1,C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of the specified matrices. </p>
<p>The number of columns in the first matrix must be the same as the number of rows in the second matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the first and second matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the number of columns of m1 does not match the number of rows of m2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00061">61</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e67698775aaac248efa49b646ca2a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the scalar product of the specified row vector and specified column vector. </p>
<p>The return is the same as the dot product. The two vectors must be the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector. </td></tr>
    <tr><td class="paramname">v</td><td>Column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar result of multiplying row vector by column vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rv and v are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00080">80</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab530a1792bc901bb6ade34ef3d9ef8b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a , typename T_b &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_a,T_b&gt;::type stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const T_a&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_b&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs. </p>
<p><img class="formulaInl" alt="$ a * \log b $" src="form_371.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{multiply\_log}(x,y) = \begin{cases} 0 &amp; \mbox{if } x=y=0\\ x\ln y &amp; \mbox{if } x,y\neq0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_372.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{multiply\_log}(x,y)}{\partial x} = \begin{cases} \infty &amp; \mbox{if } x=y=0\\ \ln y &amp; \mbox{if } x,y\neq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_373.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{multiply\_log}(x,y)}{\partial y} = \begin{cases} \infty &amp; \mbox{if } x=y=0\\ \frac{x}{y} &amp; \mbox{if } x,y\neq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_374.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a * log(b) </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2multiply__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="math_2functions_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0c953951f141b35277fe2308777cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::multiply_lower_tri_self_transpose </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower triangular values in L times their own transpose. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the input matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply__lower__tri__self__transpose_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2multiply__lower__tri__self__transpose_8hpp_source.html">multiply_lower_tri_self_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34bffe91b7a24cb29bd69cb60814c39e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::negative_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Negative infinity. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00123">123</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a381493bccc58bd993d797a2a5458c486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::not_a_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (quiet) not-a-number. </p>
<dl class="section return"><dt>Returns</dt><dd>Quiet not-a-number. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00132">132</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac360c5b10dbf87d81e346f2be7d19ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1, the number of elements in a primitive type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00019">19</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e716815601bf5055a2d7fbfd8a757ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>argument matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of matrix </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00031">31</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38a5d6d7f867666902fcd0adbe602920"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the specified vector. </p>
<p>This assumes it is not ragged and that each of its contained elements has the same number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>argument vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of contained arguments </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00045">45</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34583d3983ee4d61d09004ce3e278250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::out_of_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an out_of_range exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing out of range. This will allow us to change the behavior for all functions at once.</p>
<p>The message is: "&lt;function&gt;: index &lt;index&gt; out of range; expecting index to be between " "1 and &lt;max&gt;&lt;msg1&gt;&lt;msg2&gt;"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">max</td><td>Max </td></tr>
    <tr><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print. Default is "". </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print. Default is "". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="out__of__range_8hpp_source.html#l00030">30</a> of file <a class="el" href="out__of__range_8hpp_source.html">out_of_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66a7e8ebefd11e5801aab51d6ed9c9d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{owens\_t}(h,a) = \begin{cases} \mbox{owens\_t}(h,a) &amp; \mbox{if } -\infty\leq h,a \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_375.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{owens\_t}(h,a)}{\partial h} = \begin{cases} \frac{\partial\, \mbox{owens\_t}(h,a)}{\partial h} &amp; \mbox{if } -\infty\leq h,a\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_376.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{owens\_t}(h,a)}{\partial a} = \begin{cases} \frac{\partial\, \mbox{owens\_t}(h,a)}{\partial a} &amp; \mbox{if } -\infty\leq h,a\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_377.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{owens\_t}(h,a) = \frac{1}{2\pi} \int_0^a \frac{\exp(-\frac{1}{2}h^2(1+x^2))}{1+x^2}dx \]" src="form_378.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{owens\_t}(h,a)}{\partial h} = -\frac{1}{2\sqrt{2\pi}} \operatorname{erf}\left(\frac{ha}{\sqrt{2}}\right) \exp\left(-\frac{h^2}{2}\right) \]" src="form_379.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{owens\_t}(h,a)}{\partial a} = \frac{\exp\left(-\frac{1}{2}h^2(1+a^2)\right)}{2\pi (1+a^2)} \]" src="form_380.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>First argument </td></tr>
    <tr><td class="paramname">a</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2owens__t_8hpp_source.html#l00064">64</a> of file <a class="el" href="math_2functions_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac85644bbd92359d699f374adea62c643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit normal cumulative distribution function. </p>
<p>The return value for a specified input is the probability that a random unit normal variate is less than or equal to the specified value, defined by</p>
<p><img class="formulaInl" alt="$\Phi(x) = \int_{-\infty}^x \mbox{\sf Norm}(x|0,1) \ dx$" src="form_381.png"/></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<p>Phi will underflow to 0 below -37.5 and overflow to 1 above 8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2_phi_8hpp_source.html#l00031">31</a> of file <a class="el" href="math_2functions_2_phi_8hpp_source.html">Phi.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf4bf2074175fd7bcde43f9f94e4d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi_approx </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximation of the unit normal CDF. </p>
<p><a href="http://www.jiem.org/index.php/jiem/article/download/60/27">http://www.jiem.org/index.php/jiem/article/download/60/27</a></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2_phi__approx_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2_phi__approx_8hpp_source.html">Phi_approx.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ffd66726e0532160e16e6b48d6f428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::pi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of pi. </p>
<dl class="section return"><dt>Returns</dt><dd>Pi. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00077">77</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34675a70d3df614d88d33ddbdd49b49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::positive_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Positive infinity. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00114">114</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8cbc3a490edf340544fb12df544269e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;boost::is_arithmetic&lt;T&gt;, T&gt;::type stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified arithmetic argument unmodified with its own declared type. </p>
<p>This template function can only be instantiated with arithmetic types as defined by Boost's <code>is_arithmetic</code> trait metaprogram.</p>
<p>This function differs from <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">stan::math::value_of</a></code> in that it does not cast all return types to <code>double</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of arithmetic input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input unmodified. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2primitive__value_8hpp_source.html#l00030">30</a> of file <a class="el" href="math_2functions_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0491e419195548cdede51a384547aef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_arithmetic&lt;T&gt;, double&gt;::type stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the primitive value of the specified argument. </p>
<p>This implementation only applies to non-arithmetic types as defined by Boost's <code>is_arithmetic</code> trait metaprogram.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of non-arithmetic input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of input. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2primitive__value_8hpp_source.html#l00047">47</a> of file <a class="el" href="math_2functions_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1649a895ec6e79097d5645a3f8b8a1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00017">17</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7082de8742d87f7a0fa0842207341c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00032">32</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91458631115a8d1cf29298431f745556"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt;T1,T2&gt;::type stan::math::promote_common </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="promote__common_8hpp_source.html#l00014">14</a> of file <a class="el" href="promote__common_8hpp_source.html">promote_common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a413627171d6e5de85393af92edfb7234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt;T,S&gt;::type stan::math::promote_scalar </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the top-level function to call to promote the scalar types of an input of type S to type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type of output. </td></tr>
    <tr><td class="paramname">S</td><td>input type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input vector with scalars promoted to type T. </dd></dl>

<p>Definition at line <a class="el" href="functions_2promote__scalar_8hpp_source.html#l00103">103</a> of file <a class="el" href="functions_2promote__scalar_8hpp_source.html">promote_scalar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d52e361a0193272276fe4ed57cd8ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2qr___q_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2matrix_2qr___q_8hpp_source.html">qr_Q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376d6852cc39664aa5b5a6f69665746c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::qr_R </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2qr___r_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2matrix_2qr___r_8hpp_source.html">qr_R.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf914518093a808041339a8c259e096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,CB,CB&gt; stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute B^T A B. </p>

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8166027d80ecdbc607ef3c1c44fd1e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00034">34</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a010e06b84cba3460961d4939e1278783"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;typename promote_args&lt;T1,T2&gt;::type, Dynamic, Dynamic&gt; stan::math::quad_form_diag </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T1, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="quad__form__diag_8hpp_source.html#l00020">20</a> of file <a class="el" href="quad__form__diag_8hpp_source.html">quad_form_diag.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56bbfca6cef0653589e949c9247e406e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,CB,CB&gt; stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00049">49</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b0b2bfea6c360dcc5739fd908b39d60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00067">67</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1baa9539e0a8d4ea50aa16b73d736d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00018">18</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a808d3133624cd36ac410ba872ea653c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00037">37</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d78d2735a35451f02bcd2f4da24886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00014">14</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8edf0b7ec2ad24b1fda26a8d58513106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00022">22</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53054db4cfa6672654fbaedafbdae242"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00032">32</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad31fd1c6f1cd56836b049489009d2221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79febbfc52e2118819bb0eb77fbea561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00026">26</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa70f063ee9a5790fbed08ba8ae07c52e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00036">36</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d77ddf6ad38a102ebd6f5e433c3e6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, 1,Eigen::Dynamic&gt; stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__row__vector_8hpp_source.html#l00015">15</a> of file <a class="el" href="rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b132ea41ccfdb7b0ca4897cbb64649a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic,1&gt; stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__vector_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8abf3ffa6d67a158348134225c9d3090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::resize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Array-like object to resize. </td></tr>
    <tr><td class="paramname">dims</td><td>New dimensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object being resized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="resize_8hpp_source.html#l00063">63</a> of file <a class="el" href="resize_8hpp_source.html">resize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c25994a9886374662f280ecba376a42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{rising\_factorial}(x,n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_382.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{rising\_factorial}(x,n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, x^{(n)}}{\partial x} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_383.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{rising\_factorial}(x,n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, x^{(n)}}{\partial n} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_384.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{(n)}=\frac{\Gamma(x+n)}{\Gamma(x)} \]" src="form_385.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, x^{(n)}}{\partial x} = x^{(n)}(\Psi(x+n)-\Psi(x)) \]" src="form_386.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, x^{(n)}}{\partial n} = (x)_n\Psi(x+n) \]" src="form_387.png"/>
</p>
 
<p>Definition at line <a class="el" href="math_2functions_2rising__factorial_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2functions_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab540ec1825d8a36cf690a3f061d544bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified row of the specified matrix, using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.row(i - 1)</code> and assigning the resulting template expression to a row vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar value type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">i</td><td>Row index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified row of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="row_8hpp_source.html#l00025">25</a> of file <a class="el" href="row_8hpp_source.html">row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb157990709e17068a450238d0a579fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rows_8hpp_source.html#l00012">12</a> of file <a class="el" href="rows_8hpp_source.html">rows.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1fb33918f8c4e61cc7709905db012c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2rows__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b071fe169e76df6dc2a49c85ec28b2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,1&gt; stan::math::rows_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each row of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2rows__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2rows__dot__self_8hpp_source.html">rows_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb786f14699d69c39cfdd49893a8006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::scaled_add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__add_8hpp_source.html#l00011">11</a> of file <a class="el" href="scaled__add_8hpp_source.html">scaled_add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34fd02fe795ea38c98f4a02befed309f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2sd_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1cb72c1528f0ff383033c642341147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2sd_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_2matrix_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e828d606f1a1c8faf42e6d901089543"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector. </p>

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00020">20</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c340addebdc88ac086b0e1fac2c1b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00034">34</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a721232b5c8e7c068a120719255f5fb0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00049">49</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad825f81b97ddf0b2e1217f30913559a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sign_8hpp_source.html#l00009">9</a> of file <a class="el" href="sign_8hpp_source.html">sign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a204f15e3685b2c610ca2c0c80a3005d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::singular_values </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of the singular values of the specified matrix in decreasing order of magnitude. </p>
<p>See the documentation for <code>svd()</code> for information on the signular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="singular__values_8hpp_source.html#l00019">19</a> of file <a class="el" href="singular__values_8hpp_source.html">singular_values.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f9966aade9c4515d33d3ffa7305462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size_8hpp_source.html#l00011">11</a> of file <a class="el" href="size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a724679c01caa9ae44c146fe8019ddcf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the softmax of the specified vector. </p>
<p><img class="formulaInl" alt="$ \mbox{softmax}(y) = \frac{\exp(y)} {\sum_{k=1}^K \exp(y_k)}, $" src="form_399.png"/></p>
<p>The entries in the Jacobian of the softmax function are given by <img class="formulaInl" alt="$ \begin{array}{l} \displaystyle \frac{\partial}{\partial y_m} \mbox{softmax}(y)[k] \\[8pt] \displaystyle \mbox{ } \ \ \ = \left\{ \begin{array}{ll} \mbox{softmax}(y)[k] - \mbox{softmax}(y)[k] \times \mbox{softmax}(y)[m] &amp; \mbox{ if } m = k, \mbox{ and} \\[6pt] \mbox{softmax}(y)[k] * \mbox{softmax}(y)[m] &amp; \mbox{ if } m \neq k. \end{array} \right. \end{array} $" src="form_400.png"/></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2softmax_8hpp_source.html#l00046">46</a> of file <a class="el" href="math_2matrix_2softmax_8hpp_source.html">softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80f5418b16ea26e9bc6d2a8f9b764897"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea0d013ec0a699e61dd74f32aa722fa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00046">46</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b2712eab9b95535c0589455ed11cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00033">33</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13ae8cd1155e8c4c684efb4405a1e277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00059">59</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a13ccb29cba05ef0daa9712ee9bf7a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::sort_indices_asc </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted copy of the argument container in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>type of container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Container to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted version of container </dd></dl>

<p>Definition at line <a class="el" href="sort__indices_8hpp_source.html#l00086">86</a> of file <a class="el" href="sort__indices_8hpp_source.html">sort_indices.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27f6f9085eb850e9e0fcb98df345aeba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::sort_indices_desc </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted copy of the argument container in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>type of container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Container to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted version of container </dd></dl>

<p>Definition at line <a class="el" href="sort__indices_8hpp_source.html#l00098">98</a> of file <a class="el" href="sort__indices_8hpp_source.html">sort_indices.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1369f60a09e3af4933096de3a54ac28c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sqrt2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Square root of two. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00095">95</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a056b82f11f784f321bce2c5677089e24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the specified argument. </p>
<p><img class="formulaInl" alt="$\mbox{square}(x) = x^2$" src="form_388.png"/>.</p>
<p>The implementation of <code>square(x)</code> is just <code>x * x</code>. Given this, this method is mainly useful in cases where <code>x</code> is not a simple primitive type, particularly when it is an auto-dif type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input to square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square of input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2square_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2functions_2square_8hpp_source.html">square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65be3830eeabd6536a75897d0b90f7b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2squared__distance_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2squared__distance_8hpp_source.html">squared_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c14b7fd70050f03a07fdf73a1df06d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37cb2d874adcc950cb0439af044f549f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae94f7170ee85d4b353f55e3a044d2345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9c9057d71cf2795d0042f665c0f89c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffa61a0521d0c07b8c4cd7ccbbb4aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00047">47</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fdc5e5ba8e306c2a594e928bfd62ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The step, or Heaviside, function. </p>
<p>The function is defined by</p>
<p><code>step(y) = (y &lt; 0.0) ? 0 : 1</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{step}(x) = \begin{cases} 0 &amp; \mbox{if } x \leq 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_389.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Scalar argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the specified argument is greater than or equal to 0.0, and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2step_8hpp_source.html#l00029">29</a> of file <a class="el" href="math_2functions_2step_8hpp_source.html">step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4c5e5b76b18a41b28f646104b3cd46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::sub </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sub_8hpp_source.html#l00010">10</a> of file <a class="el" href="sub_8hpp_source.html">sub.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63cf32e07d51c4ebfe042dd452eeae14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::sub_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x 1 subcolumn starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__col_8hpp_source.html#l00022">22</a> of file <a class="el" href="sub__col_8hpp_source.html">sub_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1ea780efd8d0282dbf069f0776d727b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::sub_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 1 x nrows subrow starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__row_8hpp_source.html#l00023">23</a> of file <a class="el" href="sub__row_8hpp_source.html">sub_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90c28e884c638ed67fa0c81ffc01e2d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of subtracting the second specified matrix from the first specified matrix. </p>
<p>The return scalar type is the promotion of the input types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Difference between first matrix and second matrix. </dd></dl>

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00027">27</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36726c055970205db893867a77e9d0a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00042">42</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a776789f307db599fddcda6a68c480557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00054">54</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adde1fe0f002efa49cf9f7c129fe1a1d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2sum_8hpp_source.html#l00010">10</a> of file <a class="el" href="math_2functions_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1efee0b4f8879a114af50b7e9802745c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the values in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of elements. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements summed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sum_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2matrix_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44c32c2d7e895378feb11c99091765ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the coefficients of the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2sum_8hpp_source.html#l00034">34</a> of file <a class="el" href="math_2matrix_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b2770a97397fc738125d70420393fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the back of the specified vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00022">22</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ae4ee69ace75bb2fb216247ab8272ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the back of the specified row vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00037">37</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9956cf78180c6340f61667e797cf7055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00045">45</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b07b3f7d18cdb710806c5793a83d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of post-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M times its transpose. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2tcrossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2tcrossprod_8hpp_source.html">tcrossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88c990ca9770c6c37d883d87eb82eb6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00131">131</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad927f0ff9564aa04073f673d5e6bddfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00143">143</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8108c33b0612c8fe8f47767fa1ca6ad1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a>&lt;T&gt;::type&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00150">150</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cdd0729c27213abdf446412e7f7793c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;T&gt; &gt; stan::math::to_array_2d </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00116">116</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95a142c1899afa9dea4bdc053e959bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00020">20</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d53d7c1ac5bb3a3eff436d70b2cfbd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00027">27</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa5894e034cf63df686f4a32b78facbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00044">44</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69c7bf292d2f253217a813e6327899ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00091">91</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8eb83869b0604ee1a484547330db06f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00098">98</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e184ac2d303916513687b326bb01035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00104">104</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2aa02a20972263242e2f6a8785cf58d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00064">64</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cc7916ec81b929389e94c7fd725fd87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00071">71</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc3b48fe1676d80fd5775f97f2b6a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="containers__conversion_8hpp_source.html#l00077">77</a> of file <a class="el" href="containers__conversion_8hpp_source.html">containers_conversion.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7001fd7e0296d5dae6ab0a88e1a28547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trace of the specified matrix. </p>
<p>The trace is defined as the sum of the elements on the diagonal. The matrix is not required to be square. Returns 0 if matrix is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="trace_8hpp_source.html#l00020">20</a> of file <a class="el" href="trace_8hpp_source.html">trace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb2aa245d794e2a6c352038f4811a37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trace_8hpp_source.html#l00026">26</a> of file <a class="el" href="trace_8hpp_source.html">trace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67d451ecbf0b92587211925755a19008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , int R1, int C1, int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T1&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T3&gt;::value, typename boost::math::tools::promote_args&lt;T1,T2,T3&gt;::type&gt;::type stan::math::trace_gen_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2trace__gen__inv__quad__form__ldlt_8hpp_source.html#l00028">28</a> of file <a class="el" href="math_2matrix_2trace__gen__inv__quad__form__ldlt_8hpp_source.html">trace_gen_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d402800ee27ba77d03dc3ec365d22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_gen_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RD, CD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(D B^T A B). </p>

<p>Definition at line <a class="el" href="math_2matrix_2trace__gen__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2trace__gen__quad__form_8hpp_source.html">trace_gen_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a244c73de6ba86a3d2e7101ee681d1542"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T1&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value, typename boost::math::tools::promote_args&lt;T1,T2&gt;::type&gt;::type stan::math::trace_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2trace__inv__quad__form__ldlt_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2trace__inv__quad__form__ldlt_8hpp_source.html">trace_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a097af33142548fd565d1dab2233fa3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(B^T A B). </p>

<p>Definition at line <a class="el" href="math_2matrix_2trace__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2trace__quad__form_8hpp_source.html">trace_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9db6bf273b69e20dc12e0c348b928296"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,C,R&gt; stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="transpose_8hpp_source.html#l00012">12</a> of file <a class="el" href="transpose_8hpp_source.html">transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab18c21bad37c9af26424d0922936355e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trigamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{trigamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \Psi_1(x) &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_390.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\,\mbox{trigamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots,-3,-2,-1,0\}\\ \frac{\partial\, \Psi_1(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots,-3,-2,-1,0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_391.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi_1(x)=\sum_{n=0}^\infty \frac{1}{(x+n)^2} \]" src="form_392.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Psi_1(x)}{\partial x} = -2\sum_{n=0}^\infty \frac{1}{(x+n)^3} \]" src="form_393.png"/>
</p>
 
<p>Definition at line <a class="el" href="trigamma_8hpp_source.html#l00049">49</a> of file <a class="el" href="trigamma_8hpp_source.html">trigamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb591fca3d88d2a5d587ce6172b62bf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_non_negative_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__non__negative__index_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__non__negative__index_8hpp_source.html">validate_non_negative_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73087d72fd937f4be66684bd2613ae6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified scalar argument converted to a double value. </p>
<p>See the <code><a class="el" href="namespacestan_1_1math.html#af8cbc3a490edf340544fb12df544269e" title="Return the value of the specified arithmetic argument unmodified with its own declared type...">stan::math::primitive_value</a></code> function to extract values without casting to <code>double</code>.</p>
<p>This function is meant to cover the primitive types. For types requiring pass-by-reference, this template function should be specialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar to convert to double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar cast to a double. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2functions_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42f321e8f26d8d62ca9b3d7eb66c7068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a>&lt;T&gt;::type,R,C&gt; stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a matrix of type T to a matrix of doubles. </p>
<p>T must implement value_of. See test/agrad/fwd/matrix/value_of.cpp for fvar and var usage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type in matrix </td></tr>
    <tr><td class="paramname">R</td><td>Rows of matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Matrix to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of values </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2value__of_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d7774df98215b7d113075019d74ebbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e">stan::math::value_of</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">value_of(T)</a></code> for a polymorphic implementation using static casts.</p>
<p>This inline pass-through no-op should be compiled away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ded9e89210ba1a66b9160aed3acef34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R,C&gt; stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a matrix of type T to a matrix of doubles. </p>
<p>T must implement value_of_rec. See test/agrad/fwd/matrix/value_of_test.cpp for fvar and var usage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type in matrix </td></tr>
    <tr><td class="paramname">R</td><td>Rows of matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Matrix to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of values </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2value__of__rec_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2matrix_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a99d6e8d6986fffb421e859770560bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified scalar argument converted to a double value. </p>
<p>See the <code><a class="el" href="namespacestan_1_1math.html#af8cbc3a490edf340544fb12df544269e" title="Return the value of the specified arithmetic argument unmodified with its own declared type...">stan::math::primitive_value</a></code> function to extract values without casting to <code>double</code>.</p>
<p>This function is meant to cover the primitive types. For types requiring pass-by-reference, this template function should be specialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar to convert to double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar cast to a double. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of__rec_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2functions_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb47fffd6ec0b1864d5e8bf0b99cf55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacestan_1_1math.html#a7a99d6e8d6986fffb421e859770560bc">stan::math::value_of_rec</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">value_of(T)</a></code> for a polymorphic implementation using static casts.</p>
<p>This inline pass-through no-op should be compiled away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of__rec_8hpp_source.html#l00040">40</a> of file <a class="el" href="math_2functions_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa433ac2fc47bbd40a6d87f62574dff85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2variance_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f055da8754c2215aac70d7787692f54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2variance_8hpp_source.html#l00046">46</a> of file <a class="el" href="math_2matrix_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aece739c5a2672028f0c7848045b89f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::CONSTRAINT_TOLERANCE = 1E-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tolerance for checking arithmetic bounds In rank and in simplexes. </p>
<p>The default value is <code>1E-8</code>. </p>

<p>Definition at line <a class="el" href="constraint__tolerance_8hpp_source.html#l00011">11</a> of file <a class="el" href="constraint__tolerance_8hpp_source.html">constraint_tolerance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66f94e47c6dc073bbd3929903b4431fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::E = boost::math::constants::e&lt;double&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_270.png"/>. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ffd625c2083751d7ccabb7dbe39cbe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::EPSILON = std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smallest positive value. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00058">58</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f2ac8ebf3095e9934715bb34f0669b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INFTY = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Positive infinity. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00043">43</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5491e346d5a812af988f8de4a5948c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_2 = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_272.png"/>. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44d54686aa26009d0e9101be42afd877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_TWO_PI = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00150">150</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab773773e2db53015eb48ab1730816fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_10 = std::log(10.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_274.png"/>. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00038">38</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43fb48f0a7f26bc60c1dfb572283b149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_2 = std::log(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_273.png"/>. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00032">32</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a177764626d2378e0d7bdfb26aac187b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_PI_OVER_FOUR = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00070">70</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a344504ea0c1f4f956c85ea8027a07ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_TWO_OVER_SQRT_PI = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00148">148</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dcea3a9752d079c9f972040b873b704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_EPSILON = - std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Largest negative value (i.e., smallest absolute value). </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00063">63</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa37d0f67f02e0a0b5797ed9f4df56bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_INFTY = - std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negative infinity. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00048">48</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf147700a2e38335abc618b2c913b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NOT_A_NUMBER = std::numeric_limits&lt;double&gt;::quiet_NaN()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Quiet) not-a-number value. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a491d6e40aaa2a3e205ea6708dc3c75dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::SQRT_2 = std::sqrt(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_271.png"/>. </p>

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a935530f53a026ebb80fcd9006059e9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::TWO_OVER_SQRT_PI = 2.0 / std::sqrt(boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2constants_8hpp_source.html#l00146">146</a> of file <a class="el" href="math_2functions_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2014,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
