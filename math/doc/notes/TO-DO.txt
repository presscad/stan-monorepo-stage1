TO DO
=================================================

* stop NUTS from running away without coming back

* parallel RNG
  - use L'Ecuyer
  - specify chain id & num_chains to get offset
  - make sure Boost's is efficient
    - boost rng discard() method
  - Ben's alternative reco:
    http://numbercrunch.de/trng/

* range checks for accesses
  - std::vector accesses in model to better code gen
  - Eigen vectors to use () like matrices

* error/exception policy throughout
  - remove memory overhead from numeric_limits<stan::agrad::var>
  - maths
  - matrix

* exceptions handled by samplers
  - rejection or restart?

* HMC Sampler
  - set step size, number of steps
  - allowing random variation +/-%
  - tune step size (optional)

* discrete samplers: 
  - Gibbs for small intervals
  - slice for others
  - what about multinomial with constraints?

* R interface
 - simple process-level calls
   + compile model
   + dump data
   + dump inits
   + run model
   + load results
 - built-in from Rcpp
 - functions
 - attach.stan(fit)
   + traceplot(fit)
   + plot.stan(fit)
   + dump.stan(fit)
   + read.stan(file_path)

* refactor probability distributions to use stan/maths/error_handling. 
  1) change include. 
  2) use stan::maths::default_policy 
  3) add usings for the error handling.
  4) remove propto for cumulative function
 - multi_normal
 - categorical
 - multinomial

* add constants like PI to Stan as expressions
  - perhaps just make them globally defined vars?

* const declarations wherever possible
  - work bottom up, but it's tricky at this late date

* return log probability as parameter?
  - compute lp__ and sampling statements for output

* multi-t propto code and tests, error tests

* convert unsigned int return types to signed long
  or size_t

* divide parser's grammar into multiple files to help compiler

* clean up dependencies
  - only include as much as necessary
  - no namespace or file-level includes
  - typedefs for matrix, vector, row vector
  - simplify model includes with higher-level ones
  - chart out remaining deps

* remaining doc
  - API doc
  - reference manual
  - getting started guide
  - R interface

* distribution engineering
  - eliminate tabs from code
  - tarball
  - basic distro site
  - check cross-platform compilation

* make sure we don't go up to generic new handler but
  throw bad_alloc from our arena


Stan-R
=================================================

* SPIN (smallest posterior interval)

* plot(stan.object)

* print(stan.object)

* variogram ESS calcs

* split R-hat convergence calcs

* WAIC
  - need p(y[i]|theta) for all "data" y[i]
  - multivariate can be single point
  - binomial one or more points depending on interp


EXTENSIONS
=================================================

* add special op for multivariate norm:
  -  wrapped_multiply(y,Sigma) 
     = y' * Sigma * y
     = SUM_{m in 1:K} SUM_{n in 1:K} y[m] * y[n] * Sigma[m,n]
  - check that my algebra's right
  - specialize to Cholesky factor instead of Sigma

* figure out some way to have var constants
  - const would prohibit many of their unwanted uses, like
    assignment
  - can't afford virtual function lookup on adjoint props

* deal with autocorrelation model params where require
  all roots of 1 - SUM_i rho[i]**i to be within unit
  complex circle

* convert for loops with size bounds to approp iterators

* make sure std::less<T*> and std::swap<T*> 
  does right thing for our types (like var and vari), as
  these are used in "algorithms".

* use our arena-based alloc as STL allocator
  - http://www.cplusplus.com/reference/std/memory/allocator/
  - what do we need to do for dtor to work?

* Allow normal_log<true> and normal_log<false> to be accessed
  directly;

* Allow normal_log(y|0,1) as parser synonym for normal_log(y,0,1)

* Add matrix/vector/scalar operators to compiler
  - binary (*,/,+,-), unary (+,-)
  - translate down to our overloaded promotion-based lib
  - find operator for transpose? 

* more matrix tests (for all ops w. gradients)

* More matrix functions from Eigen:
  - norm()
  - squaredNorm()
  - lpNorm<1>
  - lpNorm<Eigen::Infinity>

* Watanabe's WAIC: Widely applicable information criterion

* Ben's implicit function idea -- iterative solver,
  analytic derivative

* smallest posterior interval (SPIn) as default 

* complement to the current foo<false> propto, so that
  normal_log<false>(...)
    = normal_log_adj_propto(...) + normal_log<true>(...)

* merging and monitoring several threads/processes

* remove all [] Eigen vector accesses and replace with ()
  the range check for which is configurable through the -NDEBUG 
  compiler option

* precompiled headers for model compilation speed

* cumulative densities and derivatives for truncations

* reparameterize simplex transform using hyperspherical coordinates
  - use Weirstrass trick to avoid numerical trig
  - use log_sum_exp to prevent underflow in products
  - use inverse logit to map back to full (-inf,inf)
  - OR, use my own hack using logit with diagonal 
       theta[1] = inv_logit(x[1]);
       theta[2] = (1 - theta[1]) * inv_logit(x[2])
       theta[3] = (1 - theta[1] - theta[2]) * inv_logit(x[3])
       theta[N] = (1 - theta[1] - theta[2] - ... - theta[N-1])
  - or better yet, adjust so that x[n] = 0 leads to uniform
    just need to look at arity and shift first down by constants
       theta[1] = inv_logit(logit(1/N) + x[1])
       theta[2] = (1 - theta[1]) * inv_logit(logit(1/(N-1)) + x[2])
    could easily store table of first 100 of these, say
  - not sure what expected value is in last -- is it 1/N per entry
    or does asymmetry of inv_logit cause problems?


* special positive-definiteness-preserving operations
  - basic data type (or trait)
  - operations that preserve well-formedness, perhaps
    by fudging boundary conditions

* optimization
  - functor-based concept design with templates 
  - easily pluggable with log prob in model for MAP 

* convergence monitoring
  - R-hat
  - n.eff (variogram, at least)
  - mean and variance of samples (per chain & across)

* forward-mode simulation
  - use when nodes can be ordered and sampled with
    all parents in graphical model defined

* benchmarks
  - agrad vs. RAD/Sacado, CppAD, ... ?
  - stan vs. MCMCpack, R, BUGS, JAGS, OpenBUGS, ...

* compiler for R's linear model notation

* threading
  - rewrite memory arena as thread-local object

* interface to Python

* interface to MATLAB

* Riemannian manifold sampling
 - Girolami's method with auto-diff Hessians

* mapped distributions
  - foo(x|theta) ==> foo(xs|theta)
  - C style: x*, int size
  - iterator concept: (x.start(),x.end())
  - array concept: (x[n], x.size())

* special functions
  - inv(x) = 1/x
  - inv_square(x) = 1/(x * x)
  - dot_self(vector v);  dot_self(row_vector v);  
  - log_sum_exp_ratio(vector<double> log_ratios, 
                      vector<double> log_probs);
  - rank(v,s): number of components of v less than v[s]
  - ranked(v,s): s-th smallest component of v
  - interp_ln(e,v1,v2) from BUGS (whatever for?)
  
* random generation functions
  - rnorm(),...

* type inference & propagation
  - variable vs. constant
  - local/nuisance vs. written

* multiple imputation
  - can't do each leapfrog step
  - generated quantitities before leapfrogs

* warnings
  - a <- foo(theta) if LHS contains variable: overwrite var
  - a ~ foo(theta)  if LHS is complex expression: need Jacobian

* integer subtypes
  - integer(-inf,inf), count(1,inf), natural(0,inf)
  - boolean(0,1), categorical(1,K), ordinal(1,K),

* double subtypes
  - probability(0,1), correlation(-1,1)
  - positive(0,inf), negative(-inf,0)

* vector subtypes
  - ordered (vs. positive ordered)

* monitor/sampler interface
  - sampler, filter, aggregator, buffer
  - online means and variances
  - rHat, and split rHat
  - run in second process as we go?

* matrix slice and assign
  - index m
  - range-indexes :, a:, :b, a:b
  - e.g., matrix(M,N) m; vector(M) v;  m[,1] = v;
  
* conditionals
  - conditional expression
  - ternary op: cond ? x : y
  - if (cond) statement else if (cond) statement ... else statement;
  - while (cond) statement;
  - repeat statement until cond;
  
* multi-returns and array literals
  - (a,b,c) = foo();  // function returns array
  - (m,n,p) = (1,2,3);   // (1,2,3) is array literal

* multiple declarations
  - e.g., double a, b, c[N];

* declare and assign
  - e.g., double x = 5.0;

* extensions
  - declare file paths to #include
  - declare namespace usings
  - declare function sigs for parser

* ragged arrays
  - ready to use with vec<...<vec<x>...> pattern
  - not clear how to declare (follow C?)

* constant vari values
  - avoid placing on stack
  - how to deal with adjoints?
  - use for numeric traits
  - units 0 and 1 (scalar, vector, matrix)

* alternative distribution parameterizations
  - e.g., precision for (multi) normal
  - inverse_sqrt_gamma(...)

* subroutines
  - user-defined functions in StanGM
  - user-defined densities (how much to require?)

* compound op-assigns in StanGM
  - +=, *=, etc.

* blocking updates
  - only update subset of parameters
  - use more than one instance per sampler
  - specify blocks in program?

* complete math robustness and limits review

* restart from where command left off a la R2jags

* auto convergence monitoring -- just keep doubling (or other ratio)

* parallel random number generation necessary for MCMC?

* cut out last derivative step in leapfrog if not nec.
  - only saves if very small number of leapfrog steps

* precompiled headers to speed up model compiles

* speed measurement
  - to converge
  - time per effective sample once converged
  - time to 4 chains at 25 ESS/chain, rHat < 1.1 for all
    parameters theta[k] and theta[k]*theta[k]
  - discarding first half of samples too many if fast to converge

* automatic Jacobians
  - just specify transform
  - requires 2nd-order diff

* check each parameter shows up on LHS of ~
  - true check is run-time based on data, etc.

* allow +/- propto flag in densities in Stan-GM

* forward mode auto-dif
  - last revision 548: 
  - src/stan/agrad/ad.hpp

* bring back specialized auto-dif for densities
  - bring up to speed with new templates for densities & propto
  - last revision 549:  ag_distributions.hpp & test 

* whole new auto-dif.  stack consists of entries per expression
  containing
  - adjoint for expression
  - for each argument
    + partial 
    + ptr to subexpression  
  - less space for constants, equal for unary, more for binary+
  - no virtual ops

* code gen auto-dif
  - just for Stan GM models

* could template stan::agrad::var with <unsigned int n>
  indicating thread.  typedef var to var<0>
  - runs in multiple threads with no speed overhead
  - code bloat multiples code size by # of threads
    + may in turn slow down everything due to mem traffic

* lazy init for var
  - if vari* is accessed and empty, return new var(0) equiv.
  - can't afford test to see if it's defined

* elim stan/maths/matrix lib by adding implicit ctor
  for Matrix<var,...> based on Matrix<double,...>

Stan GM MANUAL
=================================================

1.  Intro
2.  Modeling Language
    a.  basic organization
    b.  variable types
    c.  expressions: operator precedence, associativity
    d.  statements: precedence, associativity
    e.  programs
    f.  full BNF
3.  Reference
    a.  special functions
    b.  distributions
    c.  built-in variable transforms
4.  Stan Command Line 
5.  Extending Stan
6.  C++ Code Generated
    a.  auto-dif
A.  Examples 
    References

MODELS
=================================================

http://stat-athens.aueb.gr/~jbn/winbugs_book/
