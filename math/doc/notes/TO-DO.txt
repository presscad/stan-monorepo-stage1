TO DO FOR V1
=================================================

* discrete samplers: 
  - Gibbs for small intervals -- test
  - slice for others -- Matt
  - what about multinomial with constraints?

* NUTS II
  - diagonal mass adaptation during warmup

* remaining doc
  - API doc
  - reference manual
  - getting started guide

* distribution engineering
  - eliminate tabs from code
  - tarball
  - basic distro site
  - check cross-platform compilation:
     + goal: make OS={win,linux,mac} CC={clang++,g++} O={0,3}
     + remove useless warnings
       * unused functions, specifically

* speed tests relative to BUGS

 
CLEANUP (ONGOING)
=================================================

* distributions: bounds checking
  - weibull

* convert unsigned int return types to signed long
  or size_t
  - generated leuk.cpp: 168, 207
  - change "zu" to "lu"
  - math/error_handling.hpp: 201. comparison of unsigned int.

* const declarations wherever possible
  - work bottom up, but it's tricky at this late date

* divide parser's grammar into multiple files to help compiler

* clean up dependencies
  - only include as much as necessary
  - no namespace or file-level includes
  - typedefs for matrix, vector, row vector
  - simplify model includes with higher-level ones
  - chart out remaining deps

* convert for loops with size bounds to approp iterators


Stan-R
=================================================

* R interface
- simple process-level calls
  + compile model
  + dump data
  + dump inits
  + run model
  + load results
- built-in from Rcpp
- functions
- attach.stan(fit)
  + traceplot(fit)
  + plot.stan(fit)
  + dump.stan(fit)
  + read.stan(file_path)

* SPIN (smallest posterior interval)

* plot(stan.object)

* print(stan.object)

* variogram ESS calcs

* split R-hat convergence calcs

* WAIC
  - need p(y[i]|theta) for all "data" y[i]
  - just generate in "generated quantities" block; have all params
  - multivariate can be single point
  - binomial one or more points depending on interp


EXTENSIONS
=================================================

* precompiled headers for model compilation speed

* auto testing of sampler
  - Cook/Gelman/Rubin-style interval tests
  - needs effective sample size calc to bound intervals
  - needs simulated parameters to test estimators
  - push ESS "measurement error" through the interval tests

* error/exception policy throughout
  - maths

* stop NUTS from running away without coming back
 -- limit number of steps
    + command-line param
    + instrumenting NUTS loops (adaptation, leapfrog)
 -- limit time
    + start recording time at beginning, check loops inside
 -- bomb with report if exceed these steps
 -- print out adaptation phase step size 
 -- print out number of steps (average and sd?)
    (bring in Boost accumulator package)


* control decimal places in output 
  - set a variable on the writer or stream

* add special op for multivariate norm:
  -  wrapped_multiply(y,Sigma) 
     = y' * Sigma * y
     = SUM_{m in 1:K} SUM_{n in 1:K} y[m] * y[n] * Sigma[m,n]
  - check that my algebra's right
  - specialize to Cholesky factor instead of Sigma

* deal with autocorrelation model params where require
  all roots of 1 - SUM_i rho[i]**i to be within unit
  complex circle

* make sure std::less<T*> and std::swap<T*> 
  does right thing for our types (like var and vari), as
  these are used in "algorithms".

* use our arena-based alloc as STL allocator
  - http://www.cplusplus.com/reference/std/memory/allocator/
  - what do we need to do for dtor to work?

* Allow normal_log<true> and normal_log<false> to be accessed
  directly;

* Allow normal_log(y|0,1) as parser synonym for normal_log(y,0,1)

* Add matrix/vector/scalar operators to compiler
  - binary (*,/,+,-), unary (+,-)
  - translate down to our overloaded promotion-based lib
  - find operator for transpose? 

* more matrix tests (for all ops w. gradients)

* More matrix functions from Eigen:
  - norm()
  - squaredNorm()
  - lpNorm<1>
  - lpNorm<Eigen::Infinity>

* Watanabe's WAIC: Widely applicable information criterion

* Ben's implicit function idea -- iterative solver,
  analytic derivative

* smallest posterior interval (SPIn) as default 

* reparameterize simplex transform using hyperspherical coordinates
  - use Weirstrass trick to avoid numerical trig
  - use log_sum_exp to prevent underflow in products
  - use inverse logit to map back to full (-inf,inf)
  - OR, use my own hack using logit with diagonal 
       theta[1] = inv_logit(x[1]);
       theta[2] = (1 - theta[1]) * inv_logit(x[2])
       theta[3] = (1 - theta[1] - theta[2]) * inv_logit(x[3])
       theta[N] = (1 - theta[1] - theta[2] - ... - theta[N-1])
  - or better yet, adjust so that x[n] = 0 leads to uniform
    just need to look at arity and shift first down by constants
       theta[1] = inv_logit(logit(1/N) + x[1])
       theta[2] = (1 - theta[1]) * inv_logit(logit(1/(N-1)) + x[2])
    could easily store table of first 100 of these, say
  - not sure what expected value is in last -- is it 1/N per entry
    or does asymmetry of inv_logit cause problems?


* special positive-definiteness-preserving operations
  - basic data type (or trait)
  - operations that preserve well-formedness, perhaps
    by fudging boundary conditions

* optimization
  - functor-based concept design with templates 
  - easily pluggable with log prob in model for MAP 

* convergence monitoring
  - R-hat
  - n.eff (variogram, at least)
  - mean and variance of samples (per chain & across)

* forward-mode simulation
  - use when nodes can be ordered and sampled with
    all parents in graphical model defined

* benchmarks
  - agrad vs. RAD/Sacado, CppAD, ... ?
  - stan vs. MCMCpack, R, BUGS, JAGS, OpenBUGS, ...

* compiler for R's linear model notation

* threading
  - rewrite memory arena as thread-local object
  - merging and monitoring several threads/processes

* interface to Python

* interface to MATLAB

* Riemannian manifold sampling
 - Girolami's method with auto-diff Hessians

* mapped distributions
  - foo(x|theta) ==> foo(xs|theta)
  - C style: x*, int size
  - iterator concept: (x.start(),x.end())
  - array concept: (x[n], x.size())

* special functions
  - inv(x) = 1/x
  - inv_square(x) = 1/(x * x)
  - dot_self(vector v);  dot_self(row_vector v);  
  - log_sum_exp_ratio(vector<double> log_ratios, 
                      vector<double> log_probs);
  - rank(v,s): number of components of v less than v[s]
  - ranked(v,s): s-th smallest component of v
  - interp_ln(e,v1,v2) from BUGS (whatever for?)
  
* random generation functions
  - rnorm(),...

* type inference & propagation
  - variable vs. constant
  - local/nuisance vs. written

* multiple imputation
  - can't do each leapfrog step
  - generated quantitities before leapfrogs

* warnings
  - a <- foo(theta) if LHS contains variable: overwrite var
  - a ~ foo(theta)  if LHS is complex expression: need Jacobian

* integer subtypes
  - integer(-inf,inf), count(1,inf), natural(0,inf)
  - boolean(0,1), categorical(1,K), ordinal(1,K),

* double subtypes
  - probability(0,1), correlation(-1,1)
  - positive(0,inf), negative(-inf,0)

* vector subtypes
  - ordered (vs. positive ordered)

* monitor/sampler interface
  - sampler, filter, aggregator, buffer
  - online means and variances
  - rHat, and split rHat
  - run in second process as we go?

* matrix slice and assign
  - index m
  - range-indexes :, a:, :b, a:b
  - e.g., matrix(M,N) m; vector(M) v;  m[,1] = v;
  
* conditionals
  - conditional expression
  - ternary op: cond ? x : y
  - if (cond) statement else if (cond) statement ... else statement;
  - while (cond) statement;
  - repeat statement until cond;
  
* multi-returns and array literals
  - (a,b,c) = foo();  // function returns array
  - (m,n,p) = (1,2,3);   // (1,2,3) is array literal

* multiple declarations
  - e.g., double a, b, c[N];

* declare and assign
  - e.g., double x = 5.0;

* extensions
  - declare file paths to #include
  - declare namespace usings
  - declare function sigs for parser

* ragged arrays
  - ready to use with vec<...<vec<x>...> pattern
  - not clear how to declare (follow C?)

* constant vari values
  - avoid placing on stack
  - how to deal with adjoints?
  - use for numeric traits
  - units 0 and 1 (scalar, vector, matrix)

* alternative distribution parameterizations
  - e.g., precision for (multi) normal
  - inverse_sqrt_gamma(...)

* subroutines
  - user-defined functions in StanGM
  - user-defined densities (how much to require?)

* compound op-assigns in StanGM
  - +=, *=, etc.

* blocking updates
  - only update subset of parameters
  - use more than one instance per sampler
  - specify blocks in program?

* complete math robustness and limits review

* restart from where command left off a la R2jags

* auto convergence monitoring -- just keep doubling (or other ratio)

* cut out last derivative step in leapfrog if not nec.
  - only saves if very small number of leapfrog steps

* precompiled headers to speed up model compiles

* speed measurement
  - to converge
  - time per effective sample once converged
  - time to 4 chains at 25 ESS/chain, rHat < 1.1 for all
    parameters theta[k] and theta[k]*theta[k]
  - discarding first half of samples too many if fast to converge

* automatic Jacobians
  - just specify transform
  - requires 2nd-order diff

* check each parameter shows up on LHS of ~
  - true check is run-time based on data, etc.

* allow +/- propto flag in densities in Stan-GM

* forward mode auto-dif
  - last revision 548: 
  - src/stan/agrad/ad.hpp

* bring back specialized auto-dif for densities
  - bring up to speed with new templates for densities & propto
  - last revision 549:  ag_distributions.hpp & test 

* whole new auto-dif.  stack consists of entries per expression
  containing
  - adjoint for expression
  - for each argument
    + partial 
    + ptr to subexpression  
  - less space for constants, equal for unary, more for binary+
  - no virtual ops

Longer-Term Ideas
=================================================

* code gen auto-dif
  - just for Stan GM models

* lazy init for var
  - if vari* is accessed and empty, return new var(0) equiv.
  - can't afford test to see if it's defined

* elim stan/maths/matrix lib by adding implicit ctor
  for Matrix<var,...> based on Matrix<double,...>

* could template stan::agrad::var with <unsigned int n>
  indicating thread.  typedef var to var<0>
  - runs in multiple threads with no speed overhead
  - code bloat multiples code size by # of threads
    + may in turn slow down everything due to mem traffic



Stan GM MANUAL
=================================================

1.  Intro
2.  Modeling Language
    a.  basic organization
    b.  variable types
    c.  expressions: operator precedence, associativity
    d.  statements: precedence, associativity
    e.  programs
    f.  full BNF
3.  Reference
    a.  special functions
    b.  distributions
    c.  built-in variable transforms
4.  Stan Command Line 
5.  Extending Stan
6.  C++ Code Generated
    a.  auto-dif
A.  Examples 
    References

MODELS
=================================================

http://stat-athens.aueb.gr/~jbn/winbugs_book/
