TO DO
=================================================

* range checks for std::vector accesses in model

* error/exception policy throughout
  - remove memory overhead from numeric_limits<stan::agrad::var>
  - maths
  - matrix
  - rewrite raise_domain_error to make use of return type.

* exceptions handled by samplers
  - rejection or restart?

* HMC Sampler
  - set step size, number of steps
  - tune step size (optional)

* clean up dependencies
  - only include as much as necessary
  - no namespace or file-level includes
  - typedefs for matrix, vector, row vector
  - simplify model includes with higher-level ones

* remaining doc
  - API doc
  - reference manual
  - getting started guide
  - R interface

* distribution engineering
  - eliminate tabs from code
  - tarball
  - basic distro site
  - check cross-platform compilation

* discrete samplers: 
  - Gibbs for small intervals
  - slice for others
  - what about multinomial with constraints?

* R interface
 - simple process-level calls
   + compile model
   + dump data
   + dump inits
   + run model
   + load results
 - built-in from Rcpp
 - functions
 - attach.stan(fit)
   + traceplot(fit)
   + plot.stan(fit)
   + dump.stan(fit)
   + read.stan(file_path)



* refactor probability distributions to use stan/maths/error_handling. 
  1) change include. 
  2) use stan::maths::default_policy 
  3) add usings for the error handling.
  4) remove propto for cumulative function
 - hypergeometric
 - multinomial
 - normal
 - multi_normal
 - wishart
 - inv_wishart
 - dirichlet
 - lkj_corr
 - lkj_cov
 - categorical

EXTENSIONS
=================================================

* Allow normal_log(y|0,1) as parser synonym for normal_log(y,0,1)

* Add matrix/vector/scalar operators to compiler
  - binary (*,/,+,-), unary (+,-)
  - translate down to our overloaded promotion-based lib
  - find operator for transpose? 

* more matrix tests (for all ops w. gradients)

* More matrix functions from Eigen:
  - norm()
  - squaredNorm()
  - lpNorm<1>
  - lpNorm<Eigen::Infinity>



* Watanabe's WAIC: Widely applicable information criterion

* Ben's implicit function idea -- iterative solver,
  analytic derivative

* smallest posterior interval (SPIn) as default 

* complement to the current foo<false> propto, so that
  normal_log<false>(...)
    = normal_log_adj_propto(...) + normal_log<true>(...)

* merging and monitoring several threads/processes

* remove all [] Eigen vector accesses and replace with ()
  the range check for which is configurable through the -NDEBUG 
  compiler option

* precompiled headers for model compilation speed

* cumulative densities and derivatives for truncations

* reparameterize simplex transform using hyperspherical coordinates
  - use Weirstrass trick to avoid numerical trig
  - use log_sum_exp to prevent underflow in products

* special positive-definiteness-preserving operations
  - basic data type (or trait)
  - operations that preserve well-formedness, perhaps
    by fudging boundary conditions

* optimization
  - functor-based concept design with templates 
  - easily pluggable with log prob in model for MAP 

* convergence monitoring
  - R-hat
  - n.eff (variogram, at least)
  - mean and variance of samples (per chain & across)

* forward-mode simulation
  - use when nodes can be ordered and sampled with
    all parents in graphical model defined

* benchmarks
  - agrad vs. RAD/Sacado, CppAD, ... ?
  - stan vs. MCMCpack, R, BUGS, JAGS, OpenBUGS, ...

* compiler for R's linear model notation

* threading
  - rewrite memory arena as thread-local object

* interface to Python

* interface to MATLAB

* Riemannian manifold sampling
 - Girolami's method with auto-diff Hessians

* mapped distributions
  - foo(x|theta) ==> foo(xs|theta)
  - C style: x*, int size
  - iterator concept: (x.start(),x.end())
  - array concept: (x[n], x.size())

* special functions
  - inv(x) = 1/x
  - inv_square(x) = 1/(x * x)
  - dot_self(vector v);  dot_self(row_vector v);  
  - log_sum_exp_ratio(vector<double> log_ratios, 
                      vector<double> log_probs);
  - rank(v,s): number of components of v less than v[s]
  - ranked(v,s): s-th smallest component of v
  - interp_ln(e,v1,v2) from BUGS (whatever for?)
  
* random generation functions
  - rnorm(),...

* type inference & propagation
  - variable vs. constant
  - local/nuisance vs. written

* multiple imputation
  - can't do each leapfrog step
  - generated quantitities before leapfrogs

* warnings
  - a <- foo(theta) if LHS contains variable: overwrite var
  - a ~ foo(theta)  if LHS is complex expression: need Jacobian

* integer subtypes
  - integer(-inf,inf), count(1,inf), natural(0,inf)
  - boolean(0,1), categorical(1,K), ordinal(1,K),

* double subtypes
  - probability(0,1), correlation(-1,1)
  - positive(0,inf), negative(-inf,0)

* vector subtypes
  - ordered (vs. positive ordered)

* monitor/sampler interface
  - sampler, filter, aggregator, buffer
  - online means and variances
  - rHat, and split rHat
  - run in second process as we go?

* matrix slice and assign
  - index m
  - range-indexes :, a:, :b, a:b
  - e.g., matrix(M,N) m; vector(M) v;  m[,1] = v;
  
* conditionals
  - conditional expression
  - ternary op: cond ? x : y
  - if (cond) statement else if (cond) statement ... else statement;
  - while (cond) statement;
  - repeat statement until cond;
  
* multi-returns and array literals
  - (a,b,c) = foo();  // function returns array
  - (m,n,p) = (1,2,3);   // (1,2,3) is array literal

* multiple declarations
  - e.g., double a, b, c[N];

* declare and assign
  - e.g., double x = 5.0;

* extensions
  - declare file paths to #include
  - declare namespace usings
  - declare function sigs for parser

* ragged arrays
  - ready to use with vec<...<vec<x>...> pattern
  - not clear how to declare (follow C?)

* constant vari values
  - avoid placing on stack
  - how to deal with adjoints?
  - use for numeric traits
  - units 0 and 1 (scalar, vector, matrix)

* alternative distribution parameterizations
  - e.g., precision for (multi) normal
  - inverse_sqrt_gamma(...)

* subroutines
  - user-defined functions in StanGM
  - user-defined densities (how much to require?)

* compound op-assigns in StanGM
  - +=, *=, etc.

* blocking updates
  - only update subset of parameters
  - use more than one instance per sampler
  - specify blocks in program?

* complete math robustness and limits review

* restart from where command left off a la R2jags

* auto convergence monitoring -- just keep doubling (or other ratio)

* parallel random number generation necessary for MCMC?

* cut out last derivative step in leapfrog if not nec.
  - only saves if very small number of leapfrog steps

* precompiled headers to speed up model compiles

* speed measurement
  - to converge
  - time per effective sample once converged
  - time to 4 chains at 25 ESS/chain, rHat < 1.1 for all
    parameters theta[k] and theta[k]*theta[k]
  - discarding first half of samples too many if fast to converge

* automatic Jacobians
  - just specify transform
  - requires 2nd-order diff

* check each parameter shows up on LHS of ~
  - true check is run-time based on data, etc.

* allow +/- propto flag in densities in Stan-GM

* forward mode auto-dif
  - last revision 548: 
  - src/stan/agrad/ad.hpp

* bring back specialized auto-dif for densities
  - bring up to speed with new templates for densities & propto
  - last revision 549:  ag_distributions.hpp & test 

Stan GM MANUAL
=================================================

1.  Intro
2.  Modeling Language
    a.  basic organization
    b.  variable types
    c.  expressions: operator precedence, associativity
    d.  statements: precedence, associativity
    e.  programs
    f.  full BNF
3.  Reference
    a.  special functions
    b.  distributions
    c.  built-in variable transforms
4.  Stan Command Line 
5.  Extending Stan
6.  C++ Code Generated
    a.  auto-dif
A.  Examples 
    References

MODELS
=================================================

http://stat-athens.aueb.gr/~jbn/winbugs_book/
