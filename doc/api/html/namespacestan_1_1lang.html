<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan: stan::lang Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Stan
   &#160;<span id="projectnumber">2.15.0</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1lang.html">lang</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stan::lang Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__conditional__body.html">add_conditional_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__conditional__condition.html">add_conditional_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__expression__dimss.html">add_expression_dimss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__fun__var.html">add_fun_var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__function__signature.html">add_function_signature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__idxs.html">add_idxs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__line__number.html">add_line_number</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__loop__identifier.html">add_loop_identifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__params__var.html">add_params_var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__var.html">add_var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__while__body.html">add_while_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1add__while__condition.html">add_while_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1addition__expr3.html">addition_expr3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1arg__decl.html">arg_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for the type delclaration for function arguments.  <a href="structstan_1_1lang_1_1arg__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1array__expr.html">array_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold an array expression.  <a href="structstan_1_1lang_1_1array__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1assgn.html">assgn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for assignment to variable with multi-indexing.  <a href="structstan_1_1lang_1_1assgn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1assign__lhs.html">assign_lhs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1assignment.html">assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for assignment statements.  <a href="structstan_1_1lang_1_1assignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1bare__type__grammar.html">bare_type_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1base__var__decl.html">base_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST base class for variable declarations, which share most of their structure.  <a href="structstan_1_1lang_1_1base__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1binary__op.html">binary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for storing binary operations consisting of an operation and left and right arguments.  <a href="structstan_1_1lang_1_1binary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1binary__op__expr.html">binary_op_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1break__continue__statement.html">break_continue_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for break and continue statements.  <a href="structstan_1_1lang_1_1break__continue__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1cholesky__corr__var__decl.html">cholesky_corr_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a Cholesky factor for a correlation matrix variable declaration.  <a href="structstan_1_1lang_1_1cholesky__corr__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1cholesky__factor__var__decl.html">cholesky_factor_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a Cholesky factor variable declaration.  <a href="structstan_1_1lang_1_1cholesky__factor__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1conditional__op.html">conditional_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the conditional operator.  <a href="structstan_1_1lang_1_1conditional__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1conditional__statement.html">conditional_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for conditional statements.  <a href="structstan_1_1lang_1_1conditional__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1constrained__param__names__visgen.html">constrained_param_names_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to push constrained parameter names onto <code>param_names__</code>  <a href="structstan_1_1lang_1_1constrained__param__names__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1copy__square__cholesky__dimension__if__necessary.html">copy_square_cholesky_dimension_if_necessary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1corr__matrix__var__decl.html">corr_matrix_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a correlation matrix variable declaration.  <a href="structstan_1_1lang_1_1corr__matrix__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1cov__matrix__var__decl.html">cov_matrix_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a covariance matrix variable declaration.  <a href="structstan_1_1lang_1_1cov__matrix__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1data__only__expression.html">data_only_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1deprecate__increment__log__prob.html">deprecate_increment_log_prob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1deprecate__old__assignment__op.html">deprecate_old_assignment_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1deprecated__integrate__ode.html">deprecated_integrate_ode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1distribution.html">distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for a distribution with parameters.  <a href="structstan_1_1lang_1_1distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1division__expr.html">division_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1double__literal.html">double_literal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for holding a double literal.  <a href="structstan_1_1lang_1_1double__literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1double__var__decl.html">double_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer variable declaration and optional definition.  <a href="structstan_1_1lang_1_1double__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1dump__member__var__visgen.html">dump_member_var_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating code to read member variables (data) from the dump format through a variable context.  <a href="structstan_1_1lang_1_1dump__member__var__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1elt__division__expr.html">elt_division_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1elt__multiplication__expr.html">elt_multiplication_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1empty__range.html">empty_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1exponentiation__expr.html">exponentiation_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of the type of an expression, which consists of a base type and a number of dimensions.  <a href="structstan_1_1lang_1_1expr__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression07__grammar.html">expression07_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression__as__statement.html">expression_as_statement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression__grammar.html">expression_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression__type__vis.html">expression_type_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback functor for calculating expression types from the variant types making up an expression.  <a href="structstan_1_1lang_1_1expression__type__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1expression__visgen.html">expression_visgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1for__statement.html">for_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for representing a for statement.  <a href="structstan_1_1lang_1_1for__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for function application.  <a href="structstan_1_1lang_1_1fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for a function declaration and definition including return type name, arguments, and body.  <a href="structstan_1_1lang_1_1function__decl__def.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1function__decl__defs.html">function_decl_defs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for a sequence of function declarations and definitions.  <a href="structstan_1_1lang_1_1function__decl__defs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1lang_1_1function__signatures.html">function_signatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a singleton used to store the available functions in the Stan object language and their signatures.  <a href="classstan_1_1lang_1_1function__signatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1functions__grammar.html">functions_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1has__non__param__var__vis.html">has_non_param_var_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to determine if an expression contains a variable that is not declared as a parameter.  <a href="structstan_1_1lang_1_1has__non__param__var__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1has__var__vis.html">has_var_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to detect if an expression contains a non-data variable.  <a href="structstan_1_1lang_1_1has__var__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1idx.html">idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST variant structure for indexes, holding any of a unary, multi, omni, lower-bound, upper-bound, or lower- and upper-bound index.  <a href="structstan_1_1lang_1_1idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1idx__user__visgen.html">idx_user_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating user-facing multiple index.  <a href="structstan_1_1lang_1_1idx__user__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1idx__visgen.html">idx_visgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1increment__log__prob__statement.html">increment_log_prob_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for the increment log prob (deprecated) and target increment statements.  <a href="structstan_1_1lang_1_1increment__log__prob__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1increment__size__t.html">increment_size_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1index__op.html">index_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexed expression.  <a href="structstan_1_1lang_1_1index__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1index__op__sliced.html">index_op_sliced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for holding an expression with a sequence of indexes.  <a href="structstan_1_1lang_1_1index__op__sliced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1indexes__grammar.html">indexes_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1infer__array__expr__type.html">infer_array_expr_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1infer__vec__or__matrix__expr__type.html">infer_vec_or_matrix_expr_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1init__local__var__visgen.html">init_local_var_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to initialize local variables.  <a href="structstan_1_1lang_1_1init__local__var__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1init__vars__visgen.html">init_vars_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable initialization visitor.  <a href="structstan_1_1lang_1_1init__vars__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1init__visgen.html">init_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating code to initialize data variables from an underying <code>var_context</code> in variable <code>context__</code>.  <a href="structstan_1_1lang_1_1init__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1int__literal.html">int_literal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1int__var__decl.html">int_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer variable declaration and optional definition.  <a href="structstan_1_1lang_1_1int__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1integrate__ode.html">integrate_ode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for integrate diff eq statement.  <a href="structstan_1_1lang_1_1integrate__ode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1integrate__ode__control.html">integrate_ode_control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for a diff eq integration statement with control parameters for the integrator.  <a href="structstan_1_1lang_1_1integrate__ode__control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1is__multi__index__vis.html">is_multi_index_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for callback to determine if an index is a multiple index or a single index.  <a href="structstan_1_1lang_1_1is__multi__index__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1is__nil__vis.html">is_nil_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback functor for determining if one of the variant types making up an expression is nil.  <a href="structstan_1_1lang_1_1is__nil__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1is__no__op__statement__vis.html">is_no_op_statement_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to determine if a statement is a no-op statement.  <a href="structstan_1_1lang_1_1is__no__op__statement__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1is__numbered__statement__vis.html">is_numbered_statement_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to return true if the statement is numbered for error reporting.  <a href="structstan_1_1lang_1_1is__numbered__statement__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1is__prob__fun.html">is_prob_fun</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1lb__idx.html">lb_idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for holding a lower-bound index.  <a href="structstan_1_1lang_1_1lb__idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1left__division__expr.html">left_division_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1local__var__decl__visgen.html">local_var_decl_visgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1local__var__init__nan__visgen.html">local_var_init_nan_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to generate local variable initializations.  <a href="structstan_1_1lang_1_1local__var__init__nan__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1located__exception.html">located_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for a located exception for standard library exception types that have no what-based constructors.  <a href="structstan_1_1lang_1_1located__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1logical__negate__expr.html">logical_negate_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1lub__idx.html">lub_idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for lower and upper bounds.  <a href="structstan_1_1lang_1_1lub__idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1matrix__expr.html">matrix_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a matrix expression.  <a href="structstan_1_1lang_1_1matrix__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1matrix__var__decl.html">matrix_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a matrix variable declaration.  <a href="structstan_1_1lang_1_1matrix__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1member__var__decl__visgen.html">member_var_decl_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating code to declare member variables.  <a href="structstan_1_1lang_1_1member__var__decl__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1modulus__expr.html">modulus_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1multi__idx.html">multi_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1multiplication__expr.html">multiplication_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1name__vis.html">name_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the variant type of variable declarations that returns the name of the variable.  <a href="structstan_1_1lang_1_1name__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1negate__expr.html">negate_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1nil.html">nil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nil structure used as a placeholder for undefined or empty values in several structures.  <a href="structstan_1_1lang_1_1nil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1no__op__statement.html">no_op_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for the no-operation statement.  <a href="structstan_1_1lang_1_1no__op__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1non__void__expression.html">non_void_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1omni__idx.html">omni_idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for representing all legal indexes.  <a href="structstan_1_1lang_1_1omni__idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1ordered__var__decl.html">ordered_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold the declaration of an ordered vector.  <a href="structstan_1_1lang_1_1ordered__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__binary.html">phoenix_functor_binary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for binary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__binary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__quaternary.html">phoenix_functor_quaternary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for quatenary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__quaternary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__quinary.html">phoenix_functor_quinary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for quinary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__quinary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__senary.html">phoenix_functor_senary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for senary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__senary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__septenary.html">phoenix_functor_septenary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for septenary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__septenary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__ternary.html">phoenix_functor_ternary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for ternary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__ternary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1phoenix__functor__unary.html">phoenix_functor_unary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for unnary functors that are adapted to lazy semantic actions by boost::phoenix.  <a href="structstan_1_1lang_1_1phoenix__functor__unary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1positive__ordered__var__decl.html">positive_ordered_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold the declaration of a positive ordered vector.  <a href="structstan_1_1lang_1_1positive__ordered__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1print__statement.html">print_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for print statements.  <a href="structstan_1_1lang_1_1print__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1printable.html">printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A printable object is either an expression or a string.  <a href="structstan_1_1lang_1_1printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1printable__visgen.html">printable_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for generating strings and expressions, printing them for C++.  <a href="structstan_1_1lang_1_1printable__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1program.html">program</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for a complete Stan program.  <a href="structstan_1_1lang_1_1program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1program__error.html">program_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1program__grammar.html">program_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for a range object with a low and high value.  <a href="structstan_1_1lang_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1reject__statement.html">reject_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for the reject statement.  <a href="structstan_1_1lang_1_1reject__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1remove__loop__identifier.html">remove_loop_identifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1remove__params__var.html">remove_params_var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1require__vbar.html">require_vbar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1reset__var__scope.html">reset_var_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1return__statement.html">return_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for the return statement.  <a href="structstan_1_1lang_1_1return__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1returns__type__vis.html">returns_type_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for reporting an error message if the statement is not a return statement with a type specified at construction time.  <a href="structstan_1_1lang_1_1returns__type__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1row__vector__expr.html">row_vector_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a row_vector expression.  <a href="structstan_1_1lang_1_1row__vector__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1row__vector__var__decl.html">row_vector_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a row vector variable declaration.  <a href="structstan_1_1lang_1_1row__vector__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1sample.html">sample</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for sampling statements.  <a href="structstan_1_1lang_1_1sample.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1lang_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which tracks enclosing program block(s) encountered by parser.  <a href="classstan_1_1lang_1_1scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__allows__sampling__origin.html">set_allows_sampling_origin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__double__range__lower.html">set_double_range_lower</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__double__range__upper.html">set_double_range_upper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__fun__params__scope.html">set_fun_params_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__fun__type__named.html">set_fun_type_named</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__int__range__lower.html">set_int_range_lower</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__int__range__upper.html">set_int_range_upper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__no__op.html">set_no_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__omni__idx.html">set_omni_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__param__ranges__visgen.html">set_param_ranges_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating ranges output for parameters used to set local variables <code>param_ranges_i__</code> and <code>param_ranges_r__</code> and <code>num_params_i__</code> and <code>num_params_r__</code>.  <a href="structstan_1_1lang_1_1set__param__ranges__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__var__scope.html">set_var_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__var__scope__local.html">set_var_scope_local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__var__type.html">set_var_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__void__function.html">set_void_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1set__void__return.html">set_void_return</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1simplex__var__decl.html">simplex_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold the declaration of a simplex.  <a href="structstan_1_1lang_1_1simplex__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1statement.html">statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap the variant type of statements.  <a href="structstan_1_1lang_1_1statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1statement__2__grammar.html">statement_2_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1statement__grammar.html">statement_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1statement__visgen.html">statement_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating statements.  <a href="structstan_1_1lang_1_1statement__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1statements.html">statements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holder for local variable declarations and a sequence of statements.  <a href="structstan_1_1lang_1_1statements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1subtraction__expr3.html">subtraction_expr3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1term__grammar.html">term_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1trace.html">trace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1transpose__expr.html">transpose_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1ub__idx.html">ub_idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for holding an upper-bound index.  <a href="structstan_1_1lang_1_1ub__idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1unary__op.html">unary_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure for unary operations consisting of an operation and argument.  <a href="structstan_1_1lang_1_1unary__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1unconstrained__param__names__visgen.html">unconstrained_param_names_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for adding unconstrained parameter names to the name accumulator <code>param_names__</code>.  <a href="structstan_1_1lang_1_1unconstrained__param__names__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1uni__idx.html">uni_idx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST structure to hold a single array or matrix/vector index.  <a href="structstan_1_1lang_1_1uni__idx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1unit__vector__var__decl.html">unit_vector_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold the declaration of a unit vector.  <a href="structstan_1_1lang_1_1unit__vector__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1unscope__locals.html">unscope_locals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1unscope__variables.html">unscope_variables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__allow__sample.html">validate_allow_sample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__assgn.html">validate_assgn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__assignment.html">validate_assignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__conditional__op.html">validate_conditional_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__decl__constraints.html">validate_decl_constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__declarations.html">validate_declarations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__definition.html">validate_definition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__double__expr.html">validate_double_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__expr__type3.html">validate_expr_type3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__identifier.html">validate_identifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__in__loop.html">validate_in_loop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__int__data__expr.html">validate_int_data_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__int__expr.html">validate_int_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__int__expr__silent.html">validate_int_expr_silent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__int__expression__warn.html">validate_int_expression_warn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__integrate__ode.html">validate_integrate_ode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__integrate__ode__control.html">validate_integrate_ode_control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__ints__expression.html">validate_ints_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__lhs__var__assgn.html">validate_lhs_var_assgn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__no__constraints__vis.html">validate_no_constraints_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__non__void__arg__function.html">validate_non_void_arg_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__non__void__expression.html">validate_non_void_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__pmf__pdf__variate.html">validate_pmf_pdf_variate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__prob__fun.html">validate_prob_fun</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__return__allowed.html">validate_return_allowed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__return__type.html">validate_return_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__sample.html">validate_sample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__transformed__params__visgen.html">validate_transformed_params_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating code to validate transformed parameters.  <a href="structstan_1_1lang_1_1validate__transformed__params__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__var__decl__visgen.html">validate_var_decl_visgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1validate__void__return__allowed.html">validate_void_return_allowed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variant structure to hold a variable declaration.  <a href="structstan_1_1lang_1_1var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decl__base__type__vis.html">var_decl_base_type_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to extract base variable declaration from the variant types of a variable declaration.  <a href="structstan_1_1lang_1_1var__decl__base__type__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decl__def__vis.html">var_decl_def_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to return the definition in a variable declaration.  <a href="structstan_1_1lang_1_1var__decl__def__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decl__dims__vis.html">var_decl_dims_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for visitor to extract the dimension sizes in a variable declaration variant type.  <a href="structstan_1_1lang_1_1var__decl__dims__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decl__has__def__vis.html">var_decl_has_def_vis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable declaration visitor functor for determining if a variable declaration includes a definition.  <a href="structstan_1_1lang_1_1var__decl__has__def__vis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__decls__grammar.html">var_decls_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__occurs__vis.html">var_occurs_vis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__resizing__visgen.html">var_resizing_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to generate code to resize variables.  <a href="structstan_1_1lang_1_1var__resizing__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1var__size__validating__visgen.html">var_size_validating_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for validating variable sizes.  <a href="structstan_1_1lang_1_1var__size__validating__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1variable.html">variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a variable.  <a href="structstan_1_1lang_1_1variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1variable__dims.html">variable_dims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for holding a variable with its dimension declarations.  <a href="structstan_1_1lang_1_1variable__dims.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from function names to their base declarations and their scope.  <a href="structstan_1_1lang_1_1variable__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1vector__var__decl.html">vector_var_decl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold a column vector variable declaration.  <a href="structstan_1_1lang_1_1vector__var__decl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1visgen.html">visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for variant type visitor that generates output by writing to an output stream.  <a href="structstan_1_1lang_1_1visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1while__statement.html">while_statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AST node for representing while statements.  <a href="structstan_1_1lang_1_1while__statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1whitespace__grammar.html">whitespace_grammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1write__array__vars__visgen.html">write_array_vars_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for generating code to fill the <code>vars__</code> accumulator with variable names.  <a href="structstan_1_1lang_1_1write__array__vars__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1write__array__visgen.html">write_array_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for wirting an array initialization.  <a href="structstan_1_1lang_1_1write__array__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1write__dims__visgen.html">write_dims_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for writing the dimensions of variables.  <a href="structstan_1_1lang_1_1write__dims__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1lang_1_1write__param__names__visgen.html">write_param_names_visgen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to write parameter names into string vector <code>names__</code>.  <a href="structstan_1_1lang_1_1write__param__names__visgen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a68e0a56b53eff799154af42b5f6e79d2"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a></td></tr>
<tr class="memdesc:a68e0a56b53eff799154af42b5f6e79d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a base expression.  <a href="#a68e0a56b53eff799154af42b5f6e79d2">More...</a><br /></td></tr>
<tr class="separator:a68e0a56b53eff799154af42b5f6e79d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4ce75c6098aad77e950b21dd184aae"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#abf4ce75c6098aad77e950b21dd184aae">origin_block</a></td></tr>
<tr class="memdesc:abf4ce75c6098aad77e950b21dd184aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a variable indicating where a variable was declared.  <a href="#abf4ce75c6098aad77e950b21dd184aae">More...</a><br /></td></tr>
<tr class="separator:abf4ce75c6098aad77e950b21dd184aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d35e31b83b79f49db2a5d012d8bddf"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>, std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">function_signature_t</a></td></tr>
<tr class="memdesc:a97d35e31b83b79f49db2a5d012d8bddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a function signature, mapping a vector of argument expression types to a result expression type.  <a href="#a97d35e31b83b79f49db2a5d012d8bddf">More...</a><br /></td></tr>
<tr class="separator:a97d35e31b83b79f49db2a5d012d8bddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae782260f5a96de91250c10d1ef3b3545"><td class="memItemLeft" align="right" valign="top">typedef std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae782260f5a96de91250c10d1ef3b3545">input_iterator_t</a></td></tr>
<tr class="separator:ae782260f5a96de91250c10d1ef3b3545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a29d1a3569cd97a97b22c4003d018a1"><td class="memItemLeft" align="right" valign="top">typedef boost::spirit::line_pos_iterator&lt; <a class="el" href="namespacestan_1_1lang.html#ae782260f5a96de91250c10d1ef3b3545">input_iterator_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9a29d1a3569cd97a97b22c4003d018a1">pos_iterator_t</a></td></tr>
<tr class="separator:a9a29d1a3569cd97a97b22c4003d018a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d8c19e05423f019874999bfca2d18ac"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9d8c19e05423f019874999bfca2d18ac">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;et)</td></tr>
<tr class="memdesc:a9d8c19e05423f019874999bfca2d18ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream a user-readable version of the expression type to the specified output stream, returning the speicifed argument output stream to allow chaining.  <a href="#a9d8c19e05423f019874999bfca2d18ac">More...</a><br /></td></tr>
<tr class="separator:a9d8c19e05423f019874999bfca2d18ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614834662faa194706352ca2fb07d6bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a614834662faa194706352ca2fb07d6bb">ends_with</a> (const std::string &amp;suffix, const std::string &amp;s)</td></tr>
<tr class="memdesc:a614834662faa194706352ca2fb07d6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified suffix appears at the end of the specified string.  <a href="#a614834662faa194706352ca2fb07d6bb">More...</a><br /></td></tr>
<tr class="separator:a614834662faa194706352ca2fb07d6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5155974322ade65e45e8719841ec58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0d5155974322ade65e45e8719841ec58">fun_name_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a0d5155974322ade65e45e8719841ec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function name has been declared as a built-in or by the user.  <a href="#a0d5155974322ade65e45e8719841ec58">More...</a><br /></td></tr>
<tr class="separator:a0d5155974322ade65e45e8719841ec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da949fcdecb7cfab1f8494620671cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a5da949fcdecb7cfab1f8494620671cfa">generate_expression</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a5da949fcdecb7cfab1f8494620671cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the code generated by the specified expression to the specified output stream.  <a href="#a5da949fcdecb7cfab1f8494620671cfa">More...</a><br /></td></tr>
<tr class="separator:a5da949fcdecb7cfab1f8494620671cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d14a8cb1e25c388b521528771906b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6d14a8cb1e25c388b521528771906b48">generate_expression</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, bool user_facing, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a6d14a8cb1e25c388b521528771906b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the code generated by the specified expression to the specified output stream, putting it in a user-readable format if the user-facing flag is true.  <a href="#a6d14a8cb1e25c388b521528771906b48">More...</a><br /></td></tr>
<tr class="separator:a6d14a8cb1e25c388b521528771906b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fd3dfe5cfcb36920b948c5fef3a35a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a73fd3dfe5cfcb36920b948c5fef3a35a">get_ccdf</a> (const std::string &amp;dist_name)</td></tr>
<tr class="memdesc:a73fd3dfe5cfcb36920b948c5fef3a35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CCDF for the specified distribution.  <a href="#a73fd3dfe5cfcb36920b948c5fef3a35a">More...</a><br /></td></tr>
<tr class="separator:a73fd3dfe5cfcb36920b948c5fef3a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ff82ea83b8859ab132717e01daa12f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a98ff82ea83b8859ab132717e01daa12f">get_cdf</a> (const std::string &amp;dist_name)</td></tr>
<tr class="memdesc:a98ff82ea83b8859ab132717e01daa12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the CDF for the specified distribution name.  <a href="#a98ff82ea83b8859ab132717e01daa12f">More...</a><br /></td></tr>
<tr class="separator:a98ff82ea83b8859ab132717e01daa12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e57a6bb661f555faa3d4ff0969488f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2e57a6bb661f555faa3d4ff0969488f8">get_prob_fun</a> (const std::string &amp;dist_name)</td></tr>
<tr class="memdesc:a2e57a6bb661f555faa3d4ff0969488f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the probability function (density or mass) for the specified distribution name.  <a href="#a2e57a6bb661f555faa3d4ff0969488f8">More...</a><br /></td></tr>
<tr class="separator:a2e57a6bb661f555faa3d4ff0969488f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da6a6f3383dae56a6e7cfba3fd3a15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae7da6a6f3383dae56a6e7cfba3fd3a15">has_ccdf_suffix</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae7da6a6f3383dae56a6e7cfba3fd3a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified function name has a suffix indicating it is a CCDF.  <a href="#ae7da6a6f3383dae56a6e7cfba3fd3a15">More...</a><br /></td></tr>
<tr class="separator:ae7da6a6f3383dae56a6e7cfba3fd3a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b6b47e3d523cd5f2d527e08849098e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad3b6b47e3d523cd5f2d527e08849098e">has_cdf_suffix</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad3b6b47e3d523cd5f2d527e08849098e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified function name has a suffix indicating it is a CDF.  <a href="#ad3b6b47e3d523cd5f2d527e08849098e">More...</a><br /></td></tr>
<tr class="separator:ad3b6b47e3d523cd5f2d527e08849098e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b85b03ca1407e08468dd579fe307724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2b85b03ca1407e08468dd579fe307724">has_lp_suffix</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2b85b03ca1407e08468dd579fe307724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified string has the suffix "_lp".  <a href="#a2b85b03ca1407e08468dd579fe307724">More...</a><br /></td></tr>
<tr class="separator:a2b85b03ca1407e08468dd579fe307724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12445f29328788d14a292974c22f6f53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a12445f29328788d14a292974c22f6f53">has_non_param_var</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;var_map)</td></tr>
<tr class="memdesc:a12445f29328788d14a292974c22f6f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified expression contains a variable that requires a Jacobian warning.  <a href="#a12445f29328788d14a292974c22f6f53">More...</a><br /></td></tr>
<tr class="separator:a12445f29328788d14a292974c22f6f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7f940afd153a816c0c4114e58bac9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2b7f940afd153a816c0c4114e58bac9d">is_linear_function</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a2b7f940afd153a816c0c4114e58bac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accac1652ebed390c3e84e58b169cf593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#accac1652ebed390c3e84e58b169cf593">has_prob_fun_suffix</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:accac1652ebed390c3e84e58b169cf593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function with the specified name has a suffix indicating it is a probability function.  <a href="#accac1652ebed390c3e84e58b169cf593">More...</a><br /></td></tr>
<tr class="separator:accac1652ebed390c3e84e58b169cf593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c73eb1b88dc808ccef61c25d3bdf3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac9c73eb1b88dc808ccef61c25d3bdf3c">has_rng_suffix</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ac9c73eb1b88dc808ccef61c25d3bdf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified string has the suffix "_rng".  <a href="#ac9c73eb1b88dc808ccef61c25d3bdf3c">More...</a><br /></td></tr>
<tr class="separator:ac9c73eb1b88dc808ccef61c25d3bdf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7ee6aa6282ef4e6b2662783145a087"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#abf7ee6aa6282ef4e6b2662783145a087">has_var</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;var_map)</td></tr>
<tr class="memdesc:abf7ee6aa6282ef4e6b2662783145a087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified expression contains a variable that is defined as a parameter, defined as a transformed parameter, or is a local variable that is not an integer.  <a href="#abf7ee6aa6282ef4e6b2662783145a087">More...</a><br /></td></tr>
<tr class="separator:abf7ee6aa6282ef4e6b2662783145a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36003a9c077e1f0e846235fcb26b9a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a36003a9c077e1f0e846235fcb26b9a01">indexed_type</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;idxs)</td></tr>
<tr class="memdesc:a36003a9c077e1f0e846235fcb26b9a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the expression indexed by the generalized index sequence.  <a href="#a36003a9c077e1f0e846235fcb26b9a01">More...</a><br /></td></tr>
<tr class="separator:a36003a9c077e1f0e846235fcb26b9a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb09b61f971c94c7c1429249933906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad7fb09b61f971c94c7c1429249933906">infer_type_indexing</a> (const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;base_type, std::size_t dims, std::size_t num_indexes)</td></tr>
<tr class="memdesc:ad7fb09b61f971c94c7c1429249933906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expression type resulting from indexing an expression of the specified base type and number of dimensions with the specified number of indexes.  <a href="#ad7fb09b61f971c94c7c1429249933906">More...</a><br /></td></tr>
<tr class="separator:ad7fb09b61f971c94c7c1429249933906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7466f117e09649c22649efdebec2fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af7466f117e09649c22649efdebec2fe1">infer_type_indexing</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;expr, std::size_t num_indexes)</td></tr>
<tr class="memdesc:af7466f117e09649c22649efdebec2fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expression type resulting from indexing the specified expression with the specified number of indexes.  <a href="#af7466f117e09649c22649efdebec2fe1">More...</a><br /></td></tr>
<tr class="separator:af7466f117e09649c22649efdebec2fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc632c04d1dcb7418bfd0afa199e02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4fc632c04d1dcb7418bfd0afa199e02d">infer_type_indexing</a> (const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;expr_base_type, size_t num_expr_dims, size_t num_index_dims)</td></tr>
<tr class="separator:a4fc632c04d1dcb7418bfd0afa199e02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701776c4b46d1aced9b9b32c0b5ee29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a701776c4b46d1aced9b9b32c0b5ee29c">infer_type_indexing</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;expr, size_t num_index_dims)</td></tr>
<tr class="separator:a701776c4b46d1aced9b9b32c0b5ee29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeddc18b2b07e4dfdfda4ad88e8b9a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adaeddc18b2b07e4dfdfda4ad88e8b9a3">is_assignable</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;l_type, const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;r_type, const std::string &amp;failure_message, std::ostream &amp;error_msgs)</td></tr>
<tr class="memdesc:adaeddc18b2b07e4dfdfda4ad88e8b9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if an expression of the right-hand side type is assignable to a variable of the left-hand side type, writing the failure message to the error messages if the asisgnment is not legal.  <a href="#adaeddc18b2b07e4dfdfda4ad88e8b9a3">More...</a><br /></td></tr>
<tr class="separator:adaeddc18b2b07e4dfdfda4ad88e8b9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5613d178abb61fdaadf44c405e5cd556"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a5613d178abb61fdaadf44c405e5cd556">is_multi_index</a> (const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;<a class="el" href="structstan_1_1lang_1_1idx.html">idx</a>)</td></tr>
<tr class="memdesc:a5613d178abb61fdaadf44c405e5cd556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified index potentially takes more than one value.  <a href="#a5613d178abb61fdaadf44c405e5cd556">More...</a><br /></td></tr>
<tr class="separator:a5613d178abb61fdaadf44c405e5cd556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3464b73e4e976ed85f3faf2554611826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3464b73e4e976ed85f3faf2554611826">is_nil</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3464b73e4e976ed85f3faf2554611826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified expression is nil.  <a href="#a3464b73e4e976ed85f3faf2554611826">More...</a><br /></td></tr>
<tr class="separator:a3464b73e4e976ed85f3faf2554611826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8b4ce523118153a33565cc27afcc03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8b8b4ce523118153a33565cc27afcc03">is_user_defined</a> (const <a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;fx)</td></tr>
<tr class="memdesc:a8b8b4ce523118153a33565cc27afcc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified function was declared in the functions block.  <a href="#a8b8b4ce523118153a33565cc27afcc03">More...</a><br /></td></tr>
<tr class="separator:a8b8b4ce523118153a33565cc27afcc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff40a7a2ce84d02e5b4fe69a11277e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3ff40a7a2ce84d02e5b4fe69a11277e3">is_user_defined</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a3ff40a7a2ce84d02e5b4fe69a11277e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a function with the specified name and arguments was defined in the functions block.  <a href="#a3ff40a7a2ce84d02e5b4fe69a11277e3">More...</a><br /></td></tr>
<tr class="separator:a3ff40a7a2ce84d02e5b4fe69a11277e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2491b5c8b3cc203be2acfefdd4650c39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2491b5c8b3cc203be2acfefdd4650c39">is_user_defined_prob_function</a> (const std::string &amp;name, const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;variate, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;params)</td></tr>
<tr class="memdesc:a2491b5c8b3cc203be2acfefdd4650c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a probability function with the specified name, random variate and parameters is user defined.  <a href="#a2491b5c8b3cc203be2acfefdd4650c39">More...</a><br /></td></tr>
<tr class="separator:a2491b5c8b3cc203be2acfefdd4650c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911f61cb03332694c4aa42d5788237d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a911f61cb03332694c4aa42d5788237d3">print_scope</a> (std::ostream &amp;o, const <a class="el" href="classstan_1_1lang_1_1scope.html">scope</a> &amp;var_scope)</td></tr>
<tr class="memdesc:a911f61cb03332694c4aa42d5788237d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a user-readable version of the specified variable scope to the specified output stream.  <a href="#a911f61cb03332694c4aa42d5788237d3">More...</a><br /></td></tr>
<tr class="separator:a911f61cb03332694c4aa42d5788237d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68eacf4ea9f2c64c869c72c55cc649b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af68eacf4ea9f2c64c869c72c55cc649b">promote_primitive</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;et)</td></tr>
<tr class="separator:af68eacf4ea9f2c64c869c72c55cc649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46109ea20ae5db396814aa9f54677d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a46109ea20ae5db396814aa9f54677d05">promote_primitive</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;et1, const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;et2)</td></tr>
<tr class="separator:a46109ea20ae5db396814aa9f54677d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c62e86ae5453b817e25b2bec9e6be5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a04c62e86ae5453b817e25b2bec9e6be5">returns_type</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;return_type, const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;<a class="el" href="structstan_1_1lang_1_1statement.html">statement</a>, std::ostream &amp;error_msgs)</td></tr>
<tr class="memdesc:a04c62e86ae5453b817e25b2bec9e6be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified statement is a return statement returning an expression of the specified type, otherwise return false and write an error message to the specified error stream.  <a href="#a04c62e86ae5453b817e25b2bec9e6be5">More...</a><br /></td></tr>
<tr class="separator:a04c62e86ae5453b817e25b2bec9e6be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba82cc67a33a3ae5a7c6b4be7a72317d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aba82cc67a33a3ae5a7c6b4be7a72317d">strip_ccdf_suffix</a> (const std::string &amp;dist_fun)</td></tr>
<tr class="memdesc:aba82cc67a33a3ae5a7c6b4be7a72317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of removing the suffix from the specified function name indicating it is a CCDF.  <a href="#aba82cc67a33a3ae5a7c6b4be7a72317d">More...</a><br /></td></tr>
<tr class="separator:aba82cc67a33a3ae5a7c6b4be7a72317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a048ae36d5e5777cdc41e97e21728e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab0a048ae36d5e5777cdc41e97e21728e">strip_cdf_suffix</a> (const std::string &amp;dist_fun)</td></tr>
<tr class="memdesc:ab0a048ae36d5e5777cdc41e97e21728e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of removing the suffix from the specified function name indicating it is a CDF.  <a href="#ab0a048ae36d5e5777cdc41e97e21728e">More...</a><br /></td></tr>
<tr class="separator:ab0a048ae36d5e5777cdc41e97e21728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748131852a7c29bb713fad843fdd209"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0748131852a7c29bb713fad843fdd209">strip_prob_fun_suffix</a> (const std::string &amp;dist_fun)</td></tr>
<tr class="memdesc:a0748131852a7c29bb713fad843fdd209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stripping the suffix indicating it is a probability function from the specified function name.  <a href="#a0748131852a7c29bb713fad843fdd209">More...</a><br /></td></tr>
<tr class="separator:a0748131852a7c29bb713fad843fdd209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add818c85ac1c2c2d11dd9d25c26ed7aa"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#add818c85ac1c2c2d11dd9d25c26ed7aa">total_dims</a> (const std::vector&lt; std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &gt; &amp;dimss)</td></tr>
<tr class="memdesc:add818c85ac1c2c2d11dd9d25c26ed7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of dimensions when the specified vectors of expressions are concatenated.  <a href="#add818c85ac1c2c2d11dd9d25c26ed7aa">More...</a><br /></td></tr>
<tr class="separator:add818c85ac1c2c2d11dd9d25c26ed7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff27aba1e70ef30121a6abc7901a23a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0ff27aba1e70ef30121a6abc7901a23a">write_base_expr_type</a> (std::ostream &amp;o, <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> type)</td></tr>
<tr class="memdesc:a0ff27aba1e70ef30121a6abc7901a23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a user-readable version of the specified base expression type to the specified output stream.  <a href="#a0ff27aba1e70ef30121a6abc7901a23a">More...</a><br /></td></tr>
<tr class="separator:a0ff27aba1e70ef30121a6abc7901a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332386935a5f4361be00138c19451388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a332386935a5f4361be00138c19451388">is_binary_operator</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a332386935a5f4361be00138c19451388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff1096677d578c3ddd33ca62a89b82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a28ff1096677d578c3ddd33ca62a89b82">is_unary_operator</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a28ff1096677d578c3ddd33ca62a89b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1b8580f14b027763a642552f9b106d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aba1b8580f14b027763a642552f9b106d">is_unary_postfix_operator</a> (const std::string &amp;name)</td></tr>
<tr class="separator:aba1b8580f14b027763a642552f9b106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466e505467b9317523280cfc19bbf61e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a466e505467b9317523280cfc19bbf61e">is_operator</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a466e505467b9317523280cfc19bbf61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d8819742055bf9d16992c982324f50"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a04d8819742055bf9d16992c982324f50">fun_name_to_operator</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a04d8819742055bf9d16992c982324f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca1c8d93ce4f50d8cff58259c420fd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a5ca1c8d93ce4f50d8cff58259c420fd0">print_signature</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;arg_types, bool sampling_error_style, std::ostream &amp;msgs)</td></tr>
<tr class="separator:a5ca1c8d93ce4f50d8cff58259c420fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dd711498fe233f329ea6731f4b172a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a28dd711498fe233f329ea6731f4b172a">compile</a> (std::ostream *msgs, std::istream &amp;stan_lang_in, std::ostream &amp;cpp_out, const std::string &amp;model_name, const bool allow_undefined=false)</td></tr>
<tr class="memdesc:a28dd711498fe233f329ea6731f4b172a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a Stan model specification from the specified input, parse it, and write the C++ code for it to the specified output.  <a href="#a28dd711498fe233f329ea6731f4b172a">More...</a><br /></td></tr>
<tr class="separator:a28dd711498fe233f329ea6731f4b172a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e249a01efcee62d98c9333f26092907"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8e249a01efcee62d98c9333f26092907">EOL</a> (&quot;\)</td></tr>
<tr class="memdesc:a8e249a01efcee62d98c9333f26092907"><td class="mdescLeft">&#160;</td><td class="mdescRight">End-of-line marker.  <a href="#a8e249a01efcee62d98c9333f26092907">More...</a><br /></td></tr>
<tr class="separator:a8e249a01efcee62d98c9333f26092907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f46cd29cd827ff1c2eb20e9683e50"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a5b6f46cd29cd827ff1c2eb20e9683e50">EOL2</a> (&quot;\&quot;)</td></tr>
<tr class="memdesc:a5b6f46cd29cd827ff1c2eb20e9683e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of two end-of-line markers.  <a href="#a5b6f46cd29cd827ff1c2eb20e9683e50">More...</a><br /></td></tr>
<tr class="separator:a5b6f46cd29cd827ff1c2eb20e9683e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae849e8dda2ae020630ac0751ff7b69ff"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae849e8dda2ae020630ac0751ff7b69ff">INDENT</a> (&quot;    &quot;)</td></tr>
<tr class="memdesc:ae849e8dda2ae020630ac0751ff7b69ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single indentation.  <a href="#ae849e8dda2ae020630ac0751ff7b69ff">More...</a><br /></td></tr>
<tr class="separator:ae849e8dda2ae020630ac0751ff7b69ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea198423296d857fb1c541ab4932bd3"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a7ea198423296d857fb1c541ab4932bd3">INDENT2</a> (&quot;        &quot;)</td></tr>
<tr class="memdesc:a7ea198423296d857fb1c541ab4932bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double indentation.  <a href="#a7ea198423296d857fb1c541ab4932bd3">More...</a><br /></td></tr>
<tr class="separator:a7ea198423296d857fb1c541ab4932bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d665b3ed813d4eee09d29d9e806d247"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9d665b3ed813d4eee09d29d9e806d247">INDENT3</a> (&quot;            &quot;)</td></tr>
<tr class="memdesc:a9d665b3ed813d4eee09d29d9e806d247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triple indentation.  <a href="#a9d665b3ed813d4eee09d29d9e806d247">More...</a><br /></td></tr>
<tr class="separator:a9d665b3ed813d4eee09d29d9e806d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcae71a41014b85e241fc775002e59ff"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#afcae71a41014b85e241fc775002e59ff">EMPTY_EXP_VECTOR</a> (0)</td></tr>
<tr class="memdesc:afcae71a41014b85e241fc775002e59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size zero vector of expressions.  <a href="#afcae71a41014b85e241fc775002e59ff">More...</a><br /></td></tr>
<tr class="separator:afcae71a41014b85e241fc775002e59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e6cf03ffa13649391b5bf0c8d1a1f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae0e6cf03ffa13649391b5bf0c8d1a1f6">generate_expression</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, bool user_facing, bool is_var_context, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ae0e6cf03ffa13649391b5bf0c8d1a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified expression to the specified stream with user-facing/C++ format and parameter/data format controlled by the flags.  <a href="#ae0e6cf03ffa13649391b5bf0c8d1a1f6">More...</a><br /></td></tr>
<tr class="separator:ae0e6cf03ffa13649391b5bf0c8d1a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15ec31c717d4d4e4ffee7cc988c582b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab15ec31c717d4d4e4ffee7cc988c582b">generate_array_builder_adds</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;elements, bool user_facing, bool is_var_context, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab15ec31c717d4d4e4ffee7cc988c582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive helper function for array, matrix, and row_vector expressions which generates chain of calls to math lib array_builder add function for each of the contained elements.  <a href="#ab15ec31c717d4d4e4ffee7cc988c582b">More...</a><br /></td></tr>
<tr class="separator:ab15ec31c717d4d4e4ffee7cc988c582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558596f434a26337e759cd95be9f0d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a558596f434a26337e759cd95be9f0d5c">generate_idxs</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;idxs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a558596f434a26337e759cd95be9f0d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified multiple indexes on the specified stream.  <a href="#a558596f434a26337e759cd95be9f0d5c">More...</a><br /></td></tr>
<tr class="separator:a558596f434a26337e759cd95be9f0d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73af326a080a06530f59ea933c25964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab73af326a080a06530f59ea933c25964">generate_idxs_user</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;idxs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab73af326a080a06530f59ea933c25964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified multiple indexes for users to the specified stream.  <a href="#ab73af326a080a06530f59ea933c25964">More...</a><br /></td></tr>
<tr class="separator:ab73af326a080a06530f59ea933c25964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e5f5be53bf433949c8dd0887e968f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adc5e5f5be53bf433949c8dd0887e968f">fun_scalar_type</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, bool is_lp)</td></tr>
<tr class="memdesc:adc5e5f5be53bf433949c8dd0887e968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string representing the scalar type to use in the body of the specified function declaration, with a flag indicating if the function is a log probability function.  <a href="#adc5e5f5be53bf433949c8dd0887e968f">More...</a><br /></td></tr>
<tr class="separator:adc5e5f5be53bf433949c8dd0887e968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411fd9c7ef8d79b328232ba1326b70b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a411fd9c7ef8d79b328232ba1326b70b0">generate_idx_user</a> (const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;i, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a411fd9c7ef8d79b328232ba1326b70b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified multiple index for users to the specified stream.  <a href="#a411fd9c7ef8d79b328232ba1326b70b0">More...</a><br /></td></tr>
<tr class="separator:a411fd9c7ef8d79b328232ba1326b70b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a41b5cf8abe0f58039a8b4136c8118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a77a41b5cf8abe0f58039a8b4136c8118">generate_arg_decl</a> (bool gen_const, bool gen_ref, const <a class="el" href="structstan_1_1lang_1_1arg__decl.html">arg_decl</a> &amp;decl, const std::string &amp;scalar_t_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a77a41b5cf8abe0f58039a8b4136c8118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the argument declaration for a function with flags indicating whether to generate a <code>const</code> qualifer and whether to make the variable a reference, for the specified declaration and scalar type name from context, writing to the specified stream.  <a href="#a77a41b5cf8abe0f58039a8b4136c8118">More...</a><br /></td></tr>
<tr class="separator:a77a41b5cf8abe0f58039a8b4136c8118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6319c212bc5bd8b1b22048793bad68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aab6319c212bc5bd8b1b22048793bad68">generate_array_var_type</a> (const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;base_type, const std::string &amp;real_var_type, bool is_var_context, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aab6319c212bc5bd8b1b22048793bad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate C++ type for array expressions according to context in which expression appears.  <a href="#aab6319c212bc5bd8b1b22048793bad68">More...</a><br /></td></tr>
<tr class="separator:aab6319c212bc5bd8b1b22048793bad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2280469462eba80d78bb6b9eb24e307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae2280469462eba80d78bb6b9eb24e307">generate_bare_type</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;t, const std::string &amp;scalar_t_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ae2280469462eba80d78bb6b9eb24e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the basic type for the specified expression type without dimensions, using the specified scalar type string, writing to the specified stream.  <a href="#ae2280469462eba80d78bb6b9eb24e307">More...</a><br /></td></tr>
<tr class="separator:ae2280469462eba80d78bb6b9eb24e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d8ed85e4f5a9dfb3552583fa5990ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a67d8ed85e4f5a9dfb3552583fa5990ac">generate_catch_throw_located</a> (int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a67d8ed85e4f5a9dfb3552583fa5990ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to catch and rethrow an exception that includes location information read out of the generated context.  <a href="#a67d8ed85e4f5a9dfb3552583fa5990ac">More...</a><br /></td></tr>
<tr class="separator:a67d8ed85e4f5a9dfb3552583fa5990ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50daa15f4ec54c35a9336a9909afd8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a50daa15f4ec54c35a9336a9909afd8b9">generate_class_decl</a> (const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a50daa15f4ec54c35a9336a9909afd8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified name for the model class to the specified stream.  <a href="#a50daa15f4ec54c35a9336a9909afd8b9">More...</a><br /></td></tr>
<tr class="separator:a50daa15f4ec54c35a9336a9909afd8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c976d48e6aa89bd4fff8f17d502491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a04c976d48e6aa89bd4fff8f17d502491">generate_class_decl_end</a> (std::ostream &amp;o)</td></tr>
<tr class="separator:a04c976d48e6aa89bd4fff8f17d502491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640628072fa1df38b50d6da1c8aad335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a640628072fa1df38b50d6da1c8aad335">generate_comment</a> (const std::string &amp;msg, int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a640628072fa1df38b50d6da1c8aad335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified message as a comment with the specified indentation and an end-of-line.  <a href="#a640628072fa1df38b50d6da1c8aad335">More...</a><br /></td></tr>
<tr class="separator:a640628072fa1df38b50d6da1c8aad335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ece5a45b8104d4e13031573101e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a7e1ece5a45b8104d4e13031573101e18">generate_constrained_param_names_method</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a7e1ece5a45b8104d4e13031573101e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the <code>constrained_param_names</code> method for the specified program on the specified stream.  <a href="#a7e1ece5a45b8104d4e13031573101e18">More...</a><br /></td></tr>
<tr class="separator:a7e1ece5a45b8104d4e13031573101e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c55cdcf09d7956ddc16eb09247f452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a70c55cdcf09d7956ddc16eb09247f452">generate_constructor</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a70c55cdcf09d7956ddc16eb09247f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the constructors for the specified program with the specified model name to the specified stream.  <a href="#a70c55cdcf09d7956ddc16eb09247f452">More...</a><br /></td></tr>
<tr class="separator:a70c55cdcf09d7956ddc16eb09247f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6f03b03bc788d2fec7bd888e7a46b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adc6f03b03bc788d2fec7bd888e7a46b3">generate_cpp</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:adc6f03b03bc788d2fec7bd888e7a46b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generae the C++ code for the specified program, generating it in a class and namespace derived from the specified model name, writing to the specified stream.  <a href="#adc6f03b03bc788d2fec7bd888e7a46b3">More...</a><br /></td></tr>
<tr class="separator:adc6f03b03bc788d2fec7bd888e7a46b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7b229aa2cae75bd8eff548b441818e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aac7b229aa2cae75bd8eff548b441818e">generate_destructor</a> (const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aac7b229aa2cae75bd8eff548b441818e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the destructor for the class with name specified by the model name to the specified stream.  <a href="#aac7b229aa2cae75bd8eff548b441818e">More...</a><br /></td></tr>
<tr class="separator:aac7b229aa2cae75bd8eff548b441818e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0315c0d23213e76df1df99bbd4c36f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac0315c0d23213e76df1df99bbd4c36f0">generate_dims_method</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ac0315c0d23213e76df1df99bbd4c36f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the <code>get_dims</code> method for the parameters, transformed parameters, and generated quantities, using the specified program and generating to the specified stream.  <a href="#ac0315c0d23213e76df1df99bbd4c36f0">More...</a><br /></td></tr>
<tr class="separator:ac0315c0d23213e76df1df99bbd4c36f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17f8b86415e9f8fccb1920b8ea61c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af17f8b86415e9f8fccb1920b8ea61c35">generate_eigen_index_expression</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, std::ostream &amp;o)</td></tr>
<tr class="memdesc:af17f8b86415e9f8fccb1920b8ea61c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified expression cast to an Eigen index to disambiguate from pointer.  <a href="#af17f8b86415e9f8fccb1920b8ea61c35">More...</a><br /></td></tr>
<tr class="separator:af17f8b86415e9f8fccb1920b8ea61c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf0d21bf10a57dc8c28ecd805a8616f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2cf0d21bf10a57dc8c28ecd805a8616f">generate_function</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a2cf0d21bf10a57dc8c28ecd805a8616f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified function and optionally its default for propto=false for functions ending in _log.  <a href="#a2cf0d21bf10a57dc8c28ecd805a8616f">More...</a><br /></td></tr>
<tr class="separator:a2cf0d21bf10a57dc8c28ecd805a8616f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103540a88b344eb45dd57bc8f9da3777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a103540a88b344eb45dd57bc8f9da3777">generate_function_arguments</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, bool is_rng, bool is_lp, bool is_log, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a103540a88b344eb45dd57bc8f9da3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the arguments for the specified function, with precalculated flags for whether it is an RNG, uses the log density accumulator or is a probability function, to the specified stream.  <a href="#a103540a88b344eb45dd57bc8f9da3777">More...</a><br /></td></tr>
<tr class="separator:a103540a88b344eb45dd57bc8f9da3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ae82422c29218477c8a8b8d24b4346"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a06ae82422c29218477c8a8b8d24b4346">generate_function_body</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, const std::string &amp;scalar_t_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a06ae82422c29218477c8a8b8d24b4346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the body of the specified function, with the specified local scalar type, writing to the specified stream.  <a href="#a06ae82422c29218477c8a8b8d24b4346">More...</a><br /></td></tr>
<tr class="separator:a06ae82422c29218477c8a8b8d24b4346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaaf3b731002b35d79d2825059383ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adeaaf3b731002b35d79d2825059383ba">generate_function_functor</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, std::ostream &amp;o)</td></tr>
<tr class="memdesc:adeaaf3b731002b35d79d2825059383ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the functor to accompnay a function with the specified declaration, writing to the specified stream.  <a href="#adeaaf3b731002b35d79d2825059383ba">More...</a><br /></td></tr>
<tr class="separator:adeaaf3b731002b35d79d2825059383ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00021796ae676077e725024a0cab7963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a00021796ae676077e725024a0cab7963">generate_function_inline_return_type</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, const std::string &amp;scalar_t_name, int indent, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a00021796ae676077e725024a0cab7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the return type for the specified function declaration in the context of the specified scalar type at the specified indentation level on the specified stream.  <a href="#a00021796ae676077e725024a0cab7963">More...</a><br /></td></tr>
<tr class="separator:a00021796ae676077e725024a0cab7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557fe521a05aa73dfc28ec87eea01d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a557fe521a05aa73dfc28ec87eea01d8d">generate_function_name</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a557fe521a05aa73dfc28ec87eea01d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the function name from the specified declaration on the specified stream.  <a href="#a557fe521a05aa73dfc28ec87eea01d8d">More...</a><br /></td></tr>
<tr class="separator:a557fe521a05aa73dfc28ec87eea01d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5232450d142d99c03d87f04de0ff8e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad5232450d142d99c03d87f04de0ff8e2">generate_function_template_parameters</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, bool is_rng, bool is_lp, bool is_log, std::ostream &amp;out)</td></tr>
<tr class="memdesc:ad5232450d142d99c03d87f04de0ff8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the template declaration for functions.  <a href="#ad5232450d142d99c03d87f04de0ff8e2">More...</a><br /></td></tr>
<tr class="separator:ad5232450d142d99c03d87f04de0ff8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0173ab4487bd74c062ae05befe6fdb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad0173ab4487bd74c062ae05befe6fdb3">generate_functions</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &gt; &amp;funs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ad0173ab4487bd74c062ae05befe6fdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate function forward declarations, definitions, and functors for the the specified sequence of function declarations and definitions, writing to the specified stream.  <a href="#ad0173ab4487bd74c062ae05befe6fdb3">More...</a><br /></td></tr>
<tr class="separator:ad0173ab4487bd74c062ae05befe6fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fbdf2906fe6c56acffdaacee9fa175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a25fbdf2906fe6c56acffdaacee9fa175">generate_functor_arguments</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, bool is_rng, bool is_lp, bool is_log, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a25fbdf2906fe6c56acffdaacee9fa175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the arguments for the functor for the specified function declaration, with flags indicating whether it is a random number generator, accesses the log density accumulator, or is a probability function, writing to the specified stream.  <a href="#a25fbdf2906fe6c56acffdaacee9fa175">More...</a><br /></td></tr>
<tr class="separator:a25fbdf2906fe6c56acffdaacee9fa175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b789c9de67418b1aa4204f6ad5300e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4b789c9de67418b1aa4204f6ad5300e6">generate_globals</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a4b789c9de67418b1aa4204f6ad5300e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the global variables to the specified stream.  <a href="#a4b789c9de67418b1aa4204f6ad5300e6">More...</a><br /></td></tr>
<tr class="separator:a4b789c9de67418b1aa4204f6ad5300e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8354e7eccc24f136d9be9ce19c7d528f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8354e7eccc24f136d9be9ce19c7d528f">generate_idx</a> (const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;i, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a8354e7eccc24f136d9be9ce19c7d528f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified multiple index on the specified stream.  <a href="#a8354e7eccc24f136d9be9ce19c7d528f">More...</a><br /></td></tr>
<tr class="separator:a8354e7eccc24f136d9be9ce19c7d528f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eba9e27aeae326aae7fd9f80174e158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3eba9e27aeae326aae7fd9f80174e158">generate_idxs</a> (size_t pos, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;idxs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a3eba9e27aeae326aae7fd9f80174e158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive helper function tracking position to generate specified multiple indexes on the specified stream in order to terminate with a nil index properly.  <a href="#a3eba9e27aeae326aae7fd9f80174e158">More...</a><br /></td></tr>
<tr class="separator:a3eba9e27aeae326aae7fd9f80174e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d4b9ca2bca9e972330e62d57ad733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac84d4b9ca2bca9e972330e62d57ad733">generate_include</a> (const std::string &amp;lib_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ac84d4b9ca2bca9e972330e62d57ad733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an include statement for the specified library path.  <a href="#ac84d4b9ca2bca9e972330e62d57ad733">More...</a><br /></td></tr>
<tr class="separator:ac84d4b9ca2bca9e972330e62d57ad733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5b57ae08bfa77edfa3588e7ea8090b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9a5b57ae08bfa77edfa3588e7ea8090b">generate_includes</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a9a5b57ae08bfa77edfa3588e7ea8090b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate include statements for a Stan model class to the specified stream.  <a href="#a9a5b57ae08bfa77edfa3588e7ea8090b">More...</a><br /></td></tr>
<tr class="separator:a9a5b57ae08bfa77edfa3588e7ea8090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3279591c00e285d4690f8b759b471a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3279591c00e285d4690f8b759b471a29">generate_indent</a> (size_t indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a3279591c00e285d4690f8b759b471a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified number of indentations to the specified output stream.  <a href="#a3279591c00e285d4690f8b759b471a29">More...</a><br /></td></tr>
<tr class="separator:a3279591c00e285d4690f8b759b471a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d00069bae8e0a8f6ccbc3b26f9cf85"><td class="memTemplParams" colspan="2">template&lt;bool isLHS&gt; </td></tr>
<tr class="memitem:a79d00069bae8e0a8f6ccbc3b26f9cf85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a79d00069bae8e0a8f6ccbc3b26f9cf85">generate_indexed_expr</a> (const std::string &amp;expr, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;indexes, <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> base_type, size_t e_num_dims, bool user_facing, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a79d00069bae8e0a8f6ccbc3b26f9cf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified expression indexed with the specified indices with the specified base type of expression being indexed, number of dimensions, and a flag indicating whether the generation is for user output or C++ compilation.  <a href="#a79d00069bae8e0a8f6ccbc3b26f9cf85">More...</a><br /></td></tr>
<tr class="separator:a79d00069bae8e0a8f6ccbc3b26f9cf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc3df38f59506641e2ad112bf1c1326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aafc3df38f59506641e2ad112bf1c1326">generate_indexed_expr_user</a> (const std::string &amp;expr, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; indexes, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aafc3df38f59506641e2ad112bf1c1326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an expression with indices, writing brackets around indices and commas in between as necessary.  <a href="#aafc3df38f59506641e2ad112bf1c1326">More...</a><br /></td></tr>
<tr class="separator:aafc3df38f59506641e2ad112bf1c1326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1074b75e80ae57c872a5dae545b2fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a7b1074b75e80ae57c872a5dae545b2fe">generate_init_method</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a7b1074b75e80ae57c872a5dae545b2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the <code>transform_inits</code> method for the specified variable declarations to the specified stream.  <a href="#a7b1074b75e80ae57c872a5dae545b2fe">More...</a><br /></td></tr>
<tr class="separator:a7b1074b75e80ae57c872a5dae545b2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd4fe85b5c9aae01ac8854e49b90456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#acfd4fe85b5c9aae01ac8854e49b90456">generate_initialization</a> (std::ostream &amp;o, const std::string &amp;var_name, const std::string &amp;base_type, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;dims, const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg1=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>(), const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg2=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>())</td></tr>
<tr class="memdesc:acfd4fe85b5c9aae01ac8854e49b90456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate varaible initialization, checking dimension sizes are all positive, gnerating to the specified stream for a variable with the specified name, type, dimension sizes, and optional matrix/vector size declarations.  <a href="#acfd4fe85b5c9aae01ac8854e49b90456">More...</a><br /></td></tr>
<tr class="separator:acfd4fe85b5c9aae01ac8854e49b90456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75edae9628bb2df4e757983c2f89b180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a75edae9628bb2df4e757983c2f89b180">generate_initializer</a> (std::ostream &amp;o, const std::string &amp;base_type, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;dims, const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg1=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>(), const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg2=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>())</td></tr>
<tr class="memdesc:a75edae9628bb2df4e757983c2f89b180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an initializer for a variable of the specified base type with the specified dimension sizes with an additional size for vectors and row vectors and two additional sizes for matrices.  <a href="#a75edae9628bb2df4e757983c2f89b180">More...</a><br /></td></tr>
<tr class="separator:a75edae9628bb2df4e757983c2f89b180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59716735a34a8d1fa3c42e8c0d38ad94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a59716735a34a8d1fa3c42e8c0d38ad94">generate_local_var_decls</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, int indent, std::ostream &amp;o, bool is_var_context, bool is_fun_return)</td></tr>
<tr class="memdesc:a59716735a34a8d1fa3c42e8c0d38ad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate local variable declarations, including initializations, for the specified declarations, indentation level, writing to the specified stream, with flags indicating if its in a variable context or function return environment.  <a href="#a59716735a34a8d1fa3c42e8c0d38ad94">More...</a><br /></td></tr>
<tr class="separator:a59716735a34a8d1fa3c42e8c0d38ad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fec5f324807b4ad869cf8e317d434c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab7fec5f324807b4ad869cf8e317d434c">generate_local_var_inits</a> (std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; vs, bool is_var_context, bool declare_vars, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab7fec5f324807b4ad869cf8e317d434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate initializations for the specified local variables, with flags indicating whether the generation is in a variable context and whether variables need to be declared, writing to the specified stream.  <a href="#ab7fec5f324807b4ad869cf8e317d434c">More...</a><br /></td></tr>
<tr class="separator:ab7fec5f324807b4ad869cf8e317d434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5e3ec1ab32219b9f45d2e2c2ded738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1e5e3ec1ab32219b9f45d2e2c2ded738">generate_located_statement</a> (const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;s, int indent, std::ostream &amp;o, bool include_sampling, bool is_var_context, bool is_fun_return)</td></tr>
<tr class="memdesc:a1e5e3ec1ab32219b9f45d2e2c2ded738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified statement at the specified indentation level to the specified stream, with flags indicating if sampling should be included and if the context requires generating variables or function return types.  <a href="#a1e5e3ec1ab32219b9f45d2e2c2ded738">More...</a><br /></td></tr>
<tr class="separator:a1e5e3ec1ab32219b9f45d2e2c2ded738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fff5a6159d21a8fa197ffcdcb3436ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9fff5a6159d21a8fa197ffcdcb3436ab">generate_located_statements</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &gt; &amp;ss, int indent, std::ostream &amp;o, bool include_sampling, bool is_var_context, bool is_fun_return)</td></tr>
<tr class="memdesc:a9fff5a6159d21a8fa197ffcdcb3436ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified sequence of statements at the specified indentation level to the specified stream, with flags indicating if sampling should be included and if the context requires generating variables or function return types.  <a href="#a9fff5a6159d21a8fa197ffcdcb3436ab">More...</a><br /></td></tr>
<tr class="separator:a9fff5a6159d21a8fa197ffcdcb3436ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab531586be7dc69b398308b1f20a9c19e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab531586be7dc69b398308b1f20a9c19e">generate_log_prob</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;p, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab531586be7dc69b398308b1f20a9c19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the log_prob method for the model class for the specified program on the specified stream.  <a href="#ab531586be7dc69b398308b1f20a9c19e">More...</a><br /></td></tr>
<tr class="separator:ab531586be7dc69b398308b1f20a9c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0089eb06122fd9e9d0165a229ed97355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0089eb06122fd9e9d0165a229ed97355">generate_member_var_decls</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a0089eb06122fd9e9d0165a229ed97355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate member variable declarations for the specified variable declarations at the specified indentation level to the specified stream.  <a href="#a0089eb06122fd9e9d0165a229ed97355">More...</a><br /></td></tr>
<tr class="separator:a0089eb06122fd9e9d0165a229ed97355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a7fc8358db90341990d229edb86ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a22a7fc8358db90341990d229edb86ed4">generate_member_var_decls_all</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a22a7fc8358db90341990d229edb86ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate member variable declarations for the data and transformed data blocks for the specified program, writing to the specified stream.  <a href="#a22a7fc8358db90341990d229edb86ed4">More...</a><br /></td></tr>
<tr class="separator:a22a7fc8358db90341990d229edb86ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf65848bd87529b0958d0e7ac55abdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aadf65848bd87529b0958d0e7ac55abdb">generate_member_var_inits</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aadf65848bd87529b0958d0e7ac55abdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate initializations for member variables by reading from constructor variable context.  <a href="#aadf65848bd87529b0958d0e7ac55abdb">More...</a><br /></td></tr>
<tr class="separator:aadf65848bd87529b0958d0e7ac55abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc76ee0cb31bcb69deaf7fc67bce377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2dc76ee0cb31bcb69deaf7fc67bce377">generate_model_name_method</a> (const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a2dc76ee0cb31bcb69deaf7fc67bce377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the <code>model_name</code> method for the specified name on the specified stream.  <a href="#a2dc76ee0cb31bcb69deaf7fc67bce377">More...</a><br /></td></tr>
<tr class="separator:a2dc76ee0cb31bcb69deaf7fc67bce377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fed58a730c099b59ca4ac4e6778bdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab2fed58a730c099b59ca4ac4e6778bdc">generate_model_typedef</a> (const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab2fed58a730c099b59ca4ac4e6778bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate reusable typedef of <code>stan_model</code> for specified model name writing to the specified stream.  <a href="#ab2fed58a730c099b59ca4ac4e6778bdc">More...</a><br /></td></tr>
<tr class="separator:ab2fed58a730c099b59ca4ac4e6778bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8103aeae7073bd8e7c181b40418262d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8103aeae7073bd8e7c181b40418262d2">generate_namespace_end</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a8103aeae7073bd8e7c181b40418262d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the end of a namespace to the specified stream.  <a href="#a8103aeae7073bd8e7c181b40418262d2">More...</a><br /></td></tr>
<tr class="separator:a8103aeae7073bd8e7c181b40418262d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43178c547dea8dad5e42b022cd9e8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa43178c547dea8dad5e42b022cd9e8f1">generate_namespace_start</a> (const std::string &amp;name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aa43178c547dea8dad5e42b022cd9e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the opening name and brace for a namespace, with two end of lines.  <a href="#aa43178c547dea8dad5e42b022cd9e8f1">More...</a><br /></td></tr>
<tr class="separator:aa43178c547dea8dad5e42b022cd9e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c5cdb9a251d32b1ffcebc9f96d6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#afd7c5cdb9a251d32b1ffcebc9f96d6e0">generate_param_names_method</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, std::ostream &amp;o)</td></tr>
<tr class="memdesc:afd7c5cdb9a251d32b1ffcebc9f96d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the method to <code>get_param_names</code>, which retrieves the parameter names for the specified program on the specified stream.  <a href="#afd7c5cdb9a251d32b1ffcebc9f96d6e0">More...</a><br /></td></tr>
<tr class="separator:afd7c5cdb9a251d32b1ffcebc9f96d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28b6847110427ad1b82bbe0cbac7132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af28b6847110427ad1b82bbe0cbac7132">generate_printable</a> (const <a class="el" href="structstan_1_1lang_1_1printable.html">printable</a> &amp;p, std::ostream &amp;o)</td></tr>
<tr class="memdesc:af28b6847110427ad1b82bbe0cbac7132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified printable object to the specified stream.  <a href="#af28b6847110427ad1b82bbe0cbac7132">More...</a><br /></td></tr>
<tr class="separator:af28b6847110427ad1b82bbe0cbac7132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952f4acdc9bc76c726aecef4dffb5e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a952f4acdc9bc76c726aecef4dffb5e0c">generate_private_decl</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a952f4acdc9bc76c726aecef4dffb5e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the private declaration scope for a class to the specified stream.  <a href="#a952f4acdc9bc76c726aecef4dffb5e0c">More...</a><br /></td></tr>
<tr class="separator:a952f4acdc9bc76c726aecef4dffb5e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189d3e07ef4de1c3d0d392722f68aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab189d3e07ef4de1c3d0d392722f68aed">generate_propto_default_function</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, const std::string &amp;scalar_t_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab189d3e07ef4de1c3d0d392722f68aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a version of the specified function with propto set to false, with the specified local scalar type, writing to the specified stream.  <a href="#ab189d3e07ef4de1c3d0d392722f68aed">More...</a><br /></td></tr>
<tr class="separator:ab189d3e07ef4de1c3d0d392722f68aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa631dfbaa3b71fbc2863e10c4cf8200a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa631dfbaa3b71fbc2863e10c4cf8200a">generate_propto_default_function_body</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aa631dfbaa3b71fbc2863e10c4cf8200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the body of the specified function with <code>propto</code> set to false, writing to the specified stream.  <a href="#aa631dfbaa3b71fbc2863e10c4cf8200a">More...</a><br /></td></tr>
<tr class="separator:aa631dfbaa3b71fbc2863e10c4cf8200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab043da56c6ea6b53ebe7e8f4935aaba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab043da56c6ea6b53ebe7e8f4935aaba2">generate_public_decl</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:ab043da56c6ea6b53ebe7e8f4935aaba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the public declaration scope for a class to the specified stream.  <a href="#ab043da56c6ea6b53ebe7e8f4935aaba2">More...</a><br /></td></tr>
<tr class="separator:ab043da56c6ea6b53ebe7e8f4935aaba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdbcb0f7754e8399276987ba3318897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aefdbcb0f7754e8399276987ba3318897">generate_quoted_expression</a> (const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;e, std::ostream &amp;o)</td></tr>
<tr class="separator:aefdbcb0f7754e8399276987ba3318897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76a2997e923ebcba918cdb060b27a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2e76a2997e923ebcba918cdb060b27a8">generate_quoted_string</a> (const std::string &amp;s, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a2e76a2997e923ebcba918cdb060b27a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the specified string to the specified output stream, wrapping in double quotes (") and inserting a backslash to escape double quotes, single quotes, and backslashes.  <a href="#a2e76a2997e923ebcba918cdb060b27a8">More...</a><br /></td></tr>
<tr class="separator:a2e76a2997e923ebcba918cdb060b27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8cedf0cb701b87f6ed1ec35ab4c53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4d8cedf0cb701b87f6ed1ec35ab4c53a">generate_real_var_type</a> (const <a class="el" href="classstan_1_1lang_1_1scope.html">scope</a> &amp;var_scope, bool <a class="el" href="namespacestan_1_1lang.html#abf7ee6aa6282ef4e6b2662783145a087">has_var</a>, bool is_var_context, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a4d8cedf0cb701b87f6ed1ec35ab4c53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate correct C++ type for expressions which contain a Stan <code>real</code> variable according to context in which expression is used and expression contents.  <a href="#a4d8cedf0cb701b87f6ed1ec35ab4c53a">More...</a><br /></td></tr>
<tr class="separator:a4d8cedf0cb701b87f6ed1ec35ab4c53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6990ffb5427dd0305be01a248e1283b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae6990ffb5427dd0305be01a248e1283b">generate_set_param_ranges</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;var_decls, std::ostream &amp;o)</td></tr>
<tr class="separator:ae6990ffb5427dd0305be01a248e1283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56886da3c87c6cd1be0dfac0a94fb1cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a56886da3c87c6cd1be0dfac0a94fb1cd">generate_statement</a> (const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;s, int indent, std::ostream &amp;o, bool include_sampling, bool is_var_context, bool is_fun_return)</td></tr>
<tr class="memdesc:a56886da3c87c6cd1be0dfac0a94fb1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the specified statement with the specified indentation level on the specified output stream with flags indicating whether sampling statements are allowed and whether the generation is in a variable context or function return context.  <a href="#a56886da3c87c6cd1be0dfac0a94fb1cd">More...</a><br /></td></tr>
<tr class="separator:a56886da3c87c6cd1be0dfac0a94fb1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04dae29366c8d3b1b288e84fa63b693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae04dae29366c8d3b1b288e84fa63b693">generate_try</a> (int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ae04dae29366c8d3b1b288e84fa63b693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the opening for a try statement at the specified indentation level on the specified stream.  <a href="#ae04dae29366c8d3b1b288e84fa63b693">More...</a><br /></td></tr>
<tr class="separator:ae04dae29366c8d3b1b288e84fa63b693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960dab8641f4f21ef44fc8b14e588178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a960dab8641f4f21ef44fc8b14e588178">generate_type</a> (const std::string &amp;base_type, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;, size_t end, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a960dab8641f4f21ef44fc8b14e588178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the base type for multi-dimensional arrays.  <a href="#a960dab8641f4f21ef44fc8b14e588178">More...</a><br /></td></tr>
<tr class="separator:a960dab8641f4f21ef44fc8b14e588178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0437f9441ee3598b7852a6b14b3d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2e0437f9441ee3598b7852a6b14b3d16">generate_typedef</a> (const std::string &amp;type, const std::string &amp;abbrev, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a2e0437f9441ee3598b7852a6b14b3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a typedef statement for the specified type and abbreviation to the specified stream.  <a href="#a2e0437f9441ee3598b7852a6b14b3d16">More...</a><br /></td></tr>
<tr class="separator:a2e0437f9441ee3598b7852a6b14b3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6060f517680103fb357786016e73799e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6060f517680103fb357786016e73799e">generate_typedefs</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a6060f517680103fb357786016e73799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the typedefs required for the Stan model class to the specified stream.  <a href="#a6060f517680103fb357786016e73799e">More...</a><br /></td></tr>
<tr class="separator:a6060f517680103fb357786016e73799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d6c610edb406c616dcb84561e104a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a462d6c610edb406c616dcb84561e104a">generate_unconstrained_param_names_method</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a462d6c610edb406c616dcb84561e104a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the method <code>unconstrained_param_names</code> for the specified program on the specified stream.  <a href="#a462d6c610edb406c616dcb84561e104a">More...</a><br /></td></tr>
<tr class="separator:a462d6c610edb406c616dcb84561e104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccf71e3d97ac9c27569afee06828c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1ccf71e3d97ac9c27569afee06828c47">generate_using</a> (const std::string &amp;type, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a1ccf71e3d97ac9c27569afee06828c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a using statement for the specified type to the specified stream.  <a href="#a1ccf71e3d97ac9c27569afee06828c47">More...</a><br /></td></tr>
<tr class="separator:a1ccf71e3d97ac9c27569afee06828c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3574bbaa4099cb3361fcfefa625488b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3574bbaa4099cb3361fcfefa625488b2">generate_using_namespace</a> (const std::string &amp;ns, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a3574bbaa4099cb3361fcfefa625488b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate using statement for the specified namespace to the specfied stream.  <a href="#a3574bbaa4099cb3361fcfefa625488b2">More...</a><br /></td></tr>
<tr class="separator:a3574bbaa4099cb3361fcfefa625488b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627cc86c84d1bce30b0f4aef8f5bfc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a627cc86c84d1bce30b0f4aef8f5bfc64">generate_usings</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a627cc86c84d1bce30b0f4aef8f5bfc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the using statements for a Stan model.  <a href="#a627cc86c84d1bce30b0f4aef8f5bfc64">More...</a><br /></td></tr>
<tr class="separator:a627cc86c84d1bce30b0f4aef8f5bfc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb80ed1268d2d938718e7eea1a5ef9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8fb80ed1268d2d938718e7eea1a5ef9d">generate_validate_context_size</a> (std::ostream &amp;o, const std::string &amp;stage, const std::string &amp;var_name, const std::string &amp;base_type, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;dims, const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg1=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>(), const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;type_arg2=<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>())</td></tr>
<tr class="separator:a8fb80ed1268d2d938718e7eea1a5ef9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa079c530ddd844645eb91de16cc21736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa079c530ddd844645eb91de16cc21736">generate_validate_positive</a> (const std::string &amp;var_name, const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;expr, int indents, std::ostream &amp;o)</td></tr>
<tr class="memdesc:aa079c530ddd844645eb91de16cc21736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate call to stan_math lib function validate_non_negative_index which will throw an informative error if dim size is &lt; 0.  <a href="#aa079c530ddd844645eb91de16cc21736">More...</a><br /></td></tr>
<tr class="separator:aa079c530ddd844645eb91de16cc21736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f6f343eb242b917e2ae9ef35a7c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9a3f6f343eb242b917e2ae9ef35a7c0c">generate_validate_transformed_params</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a9a3f6f343eb242b917e2ae9ef35a7c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to validate the specified transformed parameters, generating at the specified indentation level to the specified stream.  <a href="#a9a3f6f343eb242b917e2ae9ef35a7c0c">More...</a><br /></td></tr>
<tr class="separator:a9a3f6f343eb242b917e2ae9ef35a7c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f68fd556e3a70a67bdb0cba8456d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a30f68fd556e3a70a67bdb0cba8456d37">generate_validate_var_decl</a> (const <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &amp;decl, int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a30f68fd556e3a70a67bdb0cba8456d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to validate the specified variable declaration at the specified indentation level to the specified stream.  <a href="#a30f68fd556e3a70a67bdb0cba8456d37">More...</a><br /></td></tr>
<tr class="separator:a30f68fd556e3a70a67bdb0cba8456d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac697de175dffd2a594113160200a793a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac697de175dffd2a594113160200a793a">generate_validate_var_decls</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; decls, int indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ac697de175dffd2a594113160200a793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to validate the specified variable declarations at the specified indentation level to the specified stream.  <a href="#ac697de175dffd2a594113160200a793a">More...</a><br /></td></tr>
<tr class="separator:ac697de175dffd2a594113160200a793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2341909a4024920c02ce4a307c43171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac2341909a4024920c02ce4a307c43171">generate_var_resizing</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;vs, std::ostream &amp;o)</td></tr>
<tr class="memdesc:ac2341909a4024920c02ce4a307c43171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to to the specified stream to resize the variables in the specified declarations and fill them with dummy values.  <a href="#ac2341909a4024920c02ce4a307c43171">More...</a><br /></td></tr>
<tr class="separator:ac2341909a4024920c02ce4a307c43171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecd1271b3c82648546113d3c5a6bbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adecd1271b3c82648546113d3c5a6bbd9">generate_version_comment</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:adecd1271b3c82648546113d3c5a6bbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a comment indicating which version of Stan generated the model code to the specified stream.  <a href="#adecd1271b3c82648546113d3c5a6bbd9">More...</a><br /></td></tr>
<tr class="separator:adecd1271b3c82648546113d3c5a6bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e12bb2bb3feba762be053b83ad0fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af80e12bb2bb3feba762be053b83ad0fa">generate_void_statement</a> (const std::string &amp;name, const size_t indent, std::ostream &amp;o)</td></tr>
<tr class="memdesc:af80e12bb2bb3feba762be053b83ad0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a dummy void-cast statement for a variable of the specified name at the specified indentation level to the specified output stream.  <a href="#af80e12bb2bb3feba762be053b83ad0fa">More...</a><br /></td></tr>
<tr class="separator:af80e12bb2bb3feba762be053b83ad0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d378c308e28684825330054a9da228b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8d378c308e28684825330054a9da228b">generate_write_array_method</a> (const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;prog, const std::string &amp;model_name, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a8d378c308e28684825330054a9da228b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the <code>write_array</code> method for the specified program, with specified model name to the specified stream.  <a href="#a8d378c308e28684825330054a9da228b">More...</a><br /></td></tr>
<tr class="separator:a8d378c308e28684825330054a9da228b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ccd21f3cccb2f1bfe9ca9fa41ea946"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:a48ccd21f3cccb2f1bfe9ca9fa41ea946"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a48ccd21f3cccb2f1bfe9ca9fa41ea946">has_lb</a> (const D &amp;x)</td></tr>
<tr class="memdesc:a48ccd21f3cccb2f1bfe9ca9fa41ea946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the specified declaration has a lower bound range constraint but not an upper bound range constraint.  <a href="#a48ccd21f3cccb2f1bfe9ca9fa41ea946">More...</a><br /></td></tr>
<tr class="separator:a48ccd21f3cccb2f1bfe9ca9fa41ea946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdebaa5910c1e0ecb41e247186a0079"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:a6cdebaa5910c1e0ecb41e247186a0079"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6cdebaa5910c1e0ecb41e247186a0079">has_lub</a> (const D &amp;x)</td></tr>
<tr class="memdesc:a6cdebaa5910c1e0ecb41e247186a0079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the specified declaration has a lower bound and upper bound range constraint.  <a href="#a6cdebaa5910c1e0ecb41e247186a0079">More...</a><br /></td></tr>
<tr class="separator:a6cdebaa5910c1e0ecb41e247186a0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8544df0c4a5d6a17bbf462527445bebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8544df0c4a5d6a17bbf462527445bebb">has_only_int_args</a> (const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>)</td></tr>
<tr class="memdesc:a8544df0c4a5d6a17bbf462527445bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified function has only integer arguments.  <a href="#a8544df0c4a5d6a17bbf462527445bebb">More...</a><br /></td></tr>
<tr class="separator:a8544df0c4a5d6a17bbf462527445bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9534baee0f138bf625dc226433f47f89"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:a9534baee0f138bf625dc226433f47f89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9534baee0f138bf625dc226433f47f89">has_ub</a> (const D &amp;x)</td></tr>
<tr class="memdesc:a9534baee0f138bf625dc226433f47f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the specified declaration has an upper bound range constraint but not a lower bound range constraint.  <a href="#a9534baee0f138bf625dc226433f47f89">More...</a><br /></td></tr>
<tr class="separator:a9534baee0f138bf625dc226433f47f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1c495ab574219279dae19ace9cd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aedd1c495ab574219279dae19ace9cd31">generate_statement</a> (const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &gt; &amp;ss, int indent, std::ostream &amp;o, bool include_sampling, bool is_var_context, bool is_fun_return)</td></tr>
<tr class="separator:aedd1c495ab574219279dae19ace9cd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a4a3a6a1a8f85822c65940bb01801c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95a4a3a6a1a8f85822c65940bb01801c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a95a4a3a6a1a8f85822c65940bb01801c">to_string</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a95a4a3a6a1a8f85822c65940bb01801c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string resulting from streaming the specified argument to a default <code>std::stringstream</code>.  <a href="#a95a4a3a6a1a8f85822c65940bb01801c">More...</a><br /></td></tr>
<tr class="separator:a95a4a3a6a1a8f85822c65940bb01801c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b758f597c04dd15deb5b577e2c4c0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a74b758f597c04dd15deb5b577e2c4c0a">has_prob_suffix</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a74b758f597c04dd15deb5b577e2c4c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d054318947617826a426deffadab61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2d054318947617826a426deffadab61a">replace_suffix</a> (const std::string &amp;old_suffix, const std::string &amp;new_suffix, <a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f)</td></tr>
<tr class="separator:a2d054318947617826a426deffadab61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3046d88d7cb39daff937b50ab8cb03c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3046d88d7cb39daff937b50ab8cb03c5">set_fun_type</a> (<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a>, std::ostream &amp;error_msgs)</td></tr>
<tr class="separator:a3046d88d7cb39daff937b50ab8cb03c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1d44bc5e384562a72befaddf7ccb3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aec1d44bc5e384562a72befaddf7ccb3e">num_dimss</a> (std::vector&lt; std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">stan::lang::expression</a> &gt; &gt; &amp;dimss)</td></tr>
<tr class="separator:aec1d44bc5e384562a72befaddf7ccb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec1b4d734a768e0ddce6d117498086"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4ec1b4d734a768e0ddce6d117498086"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af4ec1b4d734a768e0ddce6d117498086">validate_integrate_ode_non_control_args</a> (const T &amp;ode_fun, const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;var_map, bool &amp;pass, std::ostream &amp;error_msgs)</td></tr>
<tr class="separator:af4ec1b4d734a768e0ddce6d117498086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11de2e113c82999d121de8c5e43b298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab11de2e113c82999d121de8c5e43b298">qualify</a> (<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f)</td></tr>
<tr class="memdesc:ab11de2e113c82999d121de8c5e43b298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set original name of specified function to name and add "stan::math::" namespace qualifier to name.  <a href="#ab11de2e113c82999d121de8c5e43b298">More...</a><br /></td></tr>
<tr class="separator:ab11de2e113c82999d121de8c5e43b298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87260e8936a69f25768009bce33c4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af87260e8936a69f25768009bce33c4d4">qualify_builtins</a> (<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f)</td></tr>
<tr class="memdesc:af87260e8936a69f25768009bce33c4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add qualifier "stan::math::" to nullary functions defined in the Stan language.  <a href="#af87260e8936a69f25768009bce33c4d4">More...</a><br /></td></tr>
<tr class="separator:af87260e8936a69f25768009bce33c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7f6afa9f2598380e313ca819942c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4ad7f6afa9f2598380e313ca819942c3">qualify_cpp11_builtins</a> (<a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f)</td></tr>
<tr class="memdesc:a4ad7f6afa9f2598380e313ca819942c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add namespace qualifier <a class="el" href="namespacestan_1_1math.html" title="Matrices and templated mathematical functions. ">stan::math</a>:: to specify Stan versions of functions to avoid ambiguities with versions defined in math.h in the top-level namespace.  <a href="#a4ad7f6afa9f2598380e313ca819942c3">More...</a><br /></td></tr>
<tr class="separator:a4ad7f6afa9f2598380e313ca819942c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250eeb4cda6a3bb97295ee2d800e38b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a250eeb4cda6a3bb97295ee2d800e38b9">deprecate_fun</a> (const std::string &amp;old_name, const std::string &amp;new_name, <a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f, std::ostream &amp;msgs)</td></tr>
<tr class="separator:a250eeb4cda6a3bb97295ee2d800e38b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac76887c545a71d370d5fa8c2199b3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2ac76887c545a71d370d5fa8c2199b3f">deprecate_suffix</a> (const std::string &amp;deprecated_suffix, const std::string &amp;replacement, <a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;f, std::ostream &amp;msgs)</td></tr>
<tr class="separator:a2ac76887c545a71d370d5fa8c2199b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af024f6a6dbb6ef8720bdf8e01092b3ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af024f6a6dbb6ef8720bdf8e01092b3ca">fun_exists</a> (const std::set&lt; std::pair&lt; std::string, <a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">function_signature_t</a> &gt; &gt; &amp;existing, const std::pair&lt; std::string, <a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">function_signature_t</a> &gt; &amp;name_sig, bool name_only=true)</td></tr>
<tr class="separator:af024f6a6dbb6ef8720bdf8e01092b3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4136c84f86c5c60d8e11005a78516075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4136c84f86c5c60d8e11005a78516075">is_defined</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;arg_types)</td></tr>
<tr class="separator:a4136c84f86c5c60d8e11005a78516075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84bd96c2954db4474805a06eaeb3b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad84bd96c2954db4474805a06eaeb3b14">is_double_return</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;arg_types, std::ostream &amp;error_msgs)</td></tr>
<tr class="separator:ad84bd96c2954db4474805a06eaeb3b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84a3990582f5c439e655bc039d22d82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac84a3990582f5c439e655bc039d22d82">is_univariate</a> (const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;et)</td></tr>
<tr class="separator:ac84a3990582f5c439e655bc039d22d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2061b9f3e0e3c17cf5fc9c53c9c1fc45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2061b9f3e0e3c17cf5fc9c53c9c1fc45">is_space</a> (char c)</td></tr>
<tr class="separator:a2061b9f3e0e3c17cf5fc9c53c9c1fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f14dcfd1c3959fb168642a88b1b1241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a9f14dcfd1c3959fb168642a88b1b1241">is_nonempty</a> (std::string &amp;s)</td></tr>
<tr class="separator:a9f14dcfd1c3959fb168642a88b1b1241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce966334660208046cbfaf72e1c1d5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3ce966334660208046cbfaf72e1c1d5f">parse</a> (std::ostream *output_stream, std::istream &amp;input, const std::string &amp;model_name, <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;result, const bool allow_undefined=false)</td></tr>
<tr class="separator:a3ce966334660208046cbfaf72e1c1d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db96048c52e496af42ae879a6c6b8cb"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a2db96048c52e496af42ae879a6c6b8cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2db96048c52e496af42ae879a6c6b8cb">is_type</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a2db96048c52e496af42ae879a6c6b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified exception can be dynamically cast to the template parameter type.  <a href="#a2db96048c52e496af42ae879a6c6b8cb">More...</a><br /></td></tr>
<tr class="separator:a2db96048c52e496af42ae879a6c6b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90284258a07c639d7b3bfb285317819a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a90284258a07c639d7b3bfb285317819a">rethrow_located</a> (const std::exception &amp;e, int line)</td></tr>
<tr class="memdesc:a90284258a07c639d7b3bfb285317819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rethrow an exception of type specified by the dynamic type of the specified exception, adding the specified line number to the specified exception's message.  <a href="#a90284258a07c639d7b3bfb285317819a">More...</a><br /></td></tr>
<tr class="separator:a90284258a07c639d7b3bfb285317819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2678c64adf505d36884a7f125d475bdc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2678c64adf505d36884a7f125d475bdc">VOID_T</a> = 0</td></tr>
<tr class="memdesc:a2678c64adf505d36884a7f125d475bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void type.  <a href="#a2678c64adf505d36884a7f125d475bdc">More...</a><br /></td></tr>
<tr class="separator:a2678c64adf505d36884a7f125d475bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00b6c726776401eae900f6c6dd60dab"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac00b6c726776401eae900f6c6dd60dab">INT_T</a> = 1</td></tr>
<tr class="memdesc:ac00b6c726776401eae900f6c6dd60dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type.  <a href="#ac00b6c726776401eae900f6c6dd60dab">More...</a><br /></td></tr>
<tr class="separator:ac00b6c726776401eae900f6c6dd60dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e14b560c2617f85fbbe54139df5a3d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae0e14b560c2617f85fbbe54139df5a3d">DOUBLE_T</a> = 2</td></tr>
<tr class="memdesc:ae0e14b560c2617f85fbbe54139df5a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real scalar type.  <a href="#ae0e14b560c2617f85fbbe54139df5a3d">More...</a><br /></td></tr>
<tr class="separator:ae0e14b560c2617f85fbbe54139df5a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b3d1879af4b4b8b3d3b43d77db0bd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a841b3d1879af4b4b8b3d3b43d77db0bd">VECTOR_T</a> = 3</td></tr>
<tr class="memdesc:a841b3d1879af4b4b8b3d3b43d77db0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column vector type; scalar type is real.  <a href="#a841b3d1879af4b4b8b3d3b43d77db0bd">More...</a><br /></td></tr>
<tr class="separator:a841b3d1879af4b4b8b3d3b43d77db0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a8b7a8c4ab9815be757a5ed109869"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#afa3a8b7a8c4ab9815be757a5ed109869">ROW_VECTOR_T</a> = 4</td></tr>
<tr class="memdesc:afa3a8b7a8c4ab9815be757a5ed109869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row vector type; scalar type is real.  <a href="#afa3a8b7a8c4ab9815be757a5ed109869">More...</a><br /></td></tr>
<tr class="separator:afa3a8b7a8c4ab9815be757a5ed109869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213c08e33cb349a160b248e291ed3ae"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac213c08e33cb349a160b248e291ed3ae">MATRIX_T</a> = 5</td></tr>
<tr class="memdesc:ac213c08e33cb349a160b248e291ed3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type; scalar type is real.  <a href="#ac213c08e33cb349a160b248e291ed3ae">More...</a><br /></td></tr>
<tr class="separator:ac213c08e33cb349a160b248e291ed3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a80cac3a51a41052542a8475977c066"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1a80cac3a51a41052542a8475977c066">ILL_FORMED_T</a> = 6</td></tr>
<tr class="memdesc:a1a80cac3a51a41052542a8475977c066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type denoting an ill-formed expression.  <a href="#a1a80cac3a51a41052542a8475977c066">More...</a><br /></td></tr>
<tr class="separator:a1a80cac3a51a41052542a8475977c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cb4481262c785e442001be02576d3a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a71cb4481262c785e442001be02576d3a">model_name_origin</a> = 0</td></tr>
<tr class="memdesc:a71cb4481262c785e442001be02576d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Origin of variable is the name of the model.  <a href="#a71cb4481262c785e442001be02576d3a">More...</a><br /></td></tr>
<tr class="separator:a71cb4481262c785e442001be02576d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac786a03a29d55c493357af5ecbca3b10"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac786a03a29d55c493357af5ecbca3b10">data_origin</a> = 1</td></tr>
<tr class="memdesc:ac786a03a29d55c493357af5ecbca3b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The origin of the variable is the data block.  <a href="#ac786a03a29d55c493357af5ecbca3b10">More...</a><br /></td></tr>
<tr class="separator:ac786a03a29d55c493357af5ecbca3b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf327d8b9e76bf1eb0781a8c808aa5f3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aaf327d8b9e76bf1eb0781a8c808aa5f3">transformed_data_origin</a> = 2</td></tr>
<tr class="memdesc:aaf327d8b9e76bf1eb0781a8c808aa5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The origin of the variable is the transformed data block.  <a href="#aaf327d8b9e76bf1eb0781a8c808aa5f3">More...</a><br /></td></tr>
<tr class="separator:aaf327d8b9e76bf1eb0781a8c808aa5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba0b81288df957fc7088fcfd6a21f7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4bba0b81288df957fc7088fcfd6a21f7">parameter_origin</a> = 3</td></tr>
<tr class="memdesc:a4bba0b81288df957fc7088fcfd6a21f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The origin of the variable is the parameter block.  <a href="#a4bba0b81288df957fc7088fcfd6a21f7">More...</a><br /></td></tr>
<tr class="separator:a4bba0b81288df957fc7088fcfd6a21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb7bcf9b67e2213196b02eb0d11af5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8cdb7bcf9b67e2213196b02eb0d11af5">transformed_parameter_origin</a> = 4</td></tr>
<tr class="memdesc:a8cdb7bcf9b67e2213196b02eb0d11af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The origin of the variable is the transformed parameter block.  <a href="#a8cdb7bcf9b67e2213196b02eb0d11af5">More...</a><br /></td></tr>
<tr class="separator:a8cdb7bcf9b67e2213196b02eb0d11af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eadba622a7e472de3ff6a882edd615"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a91eadba622a7e472de3ff6a882edd615">derived_origin</a> = 5</td></tr>
<tr class="memdesc:a91eadba622a7e472de3ff6a882edd615"><td class="mdescLeft">&#160;</td><td class="mdescRight">The origin of the variable is generated quantities.  <a href="#a91eadba622a7e472de3ff6a882edd615">More...</a><br /></td></tr>
<tr class="separator:a91eadba622a7e472de3ff6a882edd615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf67def8ef0f503f15d35fc7048ef9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a5ebf67def8ef0f503f15d35fc7048ef9">function_argument_origin</a> = 6</td></tr>
<tr class="memdesc:a5ebf67def8ef0f503f15d35fc7048ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as a function argument to a non-void function that does not end in _lp or _rng.  <a href="#a5ebf67def8ef0f503f15d35fc7048ef9">More...</a><br /></td></tr>
<tr class="separator:a5ebf67def8ef0f503f15d35fc7048ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bba07d76f7bf223e67aae4b9e28fd8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a85bba07d76f7bf223e67aae4b9e28fd8">function_argument_origin_lp</a> = 7</td></tr>
<tr class="memdesc:a85bba07d76f7bf223e67aae4b9e28fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as an argument to a non-void function with the _lp suffix.  <a href="#a85bba07d76f7bf223e67aae4b9e28fd8">More...</a><br /></td></tr>
<tr class="separator:a85bba07d76f7bf223e67aae4b9e28fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6f3011d4676d30cbc264fee2cc1cc2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3a6f3011d4676d30cbc264fee2cc1cc2">function_argument_origin_rng</a> = 8</td></tr>
<tr class="memdesc:a3a6f3011d4676d30cbc264fee2cc1cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as an argument to a non-void function with the _rng suffix.  <a href="#a3a6f3011d4676d30cbc264fee2cc1cc2">More...</a><br /></td></tr>
<tr class="separator:a3a6f3011d4676d30cbc264fee2cc1cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58187b5ad062f7c82e69e1d412a30add"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a58187b5ad062f7c82e69e1d412a30add">void_function_argument_origin</a> = 9</td></tr>
<tr class="memdesc:a58187b5ad062f7c82e69e1d412a30add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as an argument to a function returning void that does not have the _lp or _rng suffix.  <a href="#a58187b5ad062f7c82e69e1d412a30add">More...</a><br /></td></tr>
<tr class="separator:a58187b5ad062f7c82e69e1d412a30add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5dba01e3d62fb23a5a32954cfc0782"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#abb5dba01e3d62fb23a5a32954cfc0782">void_function_argument_origin_lp</a> = 10</td></tr>
<tr class="memdesc:abb5dba01e3d62fb23a5a32954cfc0782"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as an argument to a function returning void with _lp suffix.  <a href="#abb5dba01e3d62fb23a5a32954cfc0782">More...</a><br /></td></tr>
<tr class="separator:abb5dba01e3d62fb23a5a32954cfc0782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257a85740af8a9bd2b42328c42b35d4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3257a85740af8a9bd2b42328c42b35d4">void_function_argument_origin_rng</a> = 11</td></tr>
<tr class="memdesc:a3257a85740af8a9bd2b42328c42b35d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable arose as an argument to a function returning void with an _rng suffix.  <a href="#a3257a85740af8a9bd2b42328c42b35d4">More...</a><br /></td></tr>
<tr class="separator:a3257a85740af8a9bd2b42328c42b35d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092cb2640be87937380477f8bc4502be"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1assign__lhs.html">assign_lhs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a092cb2640be87937380477f8bc4502be">assign_lhs_f</a></td></tr>
<tr class="separator:a092cb2640be87937380477f8bc4502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a0d7b66a80f971af0f9d3428a28937"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__expr__type3.html">validate_expr_type3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa6a0d7b66a80f971af0f9d3428a28937">validate_expr_type3_f</a></td></tr>
<tr class="separator:aa6a0d7b66a80f971af0f9d3428a28937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be25f1771bd1501888b206ab06404f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1is__prob__fun.html">is_prob_fun</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac5be25f1771bd1501888b206ab06404f">is_prob_fun_f</a></td></tr>
<tr class="separator:ac5be25f1771bd1501888b206ab06404f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6330e5eb1772572f21d1deaabcb75f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1addition__expr3.html">addition_expr3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8c6330e5eb1772572f21d1deaabcb75f">addition3_f</a></td></tr>
<tr class="separator:a8c6330e5eb1772572f21d1deaabcb75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7665b6ef58bda5e9641037e203c3e9b8"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1subtraction__expr3.html">subtraction_expr3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a7665b6ef58bda5e9641037e203c3e9b8">subtraction3_f</a></td></tr>
<tr class="separator:a7665b6ef58bda5e9641037e203c3e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8f01052bb3786de5fe0926d8e9cfcc"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1increment__size__t.html">increment_size_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1d8f01052bb3786de5fe0926d8e9cfcc">increment_size_t_f</a></td></tr>
<tr class="separator:a1d8f01052bb3786de5fe0926d8e9cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb8c5e33d9977c96f8de6d537feb374"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__conditional__op.html">validate_conditional_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a2bb8c5e33d9977c96f8de6d537feb374">validate_conditional_op_f</a></td></tr>
<tr class="separator:a2bb8c5e33d9977c96f8de6d537feb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f822a45db85a7a2b530f3c532e35b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1binary__op__expr.html">binary_op_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a318f822a45db85a7a2b530f3c532e35b">binary_op_f</a></td></tr>
<tr class="separator:a318f822a45db85a7a2b530f3c532e35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78701a79b0b34a22201b086137de5f4c"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__non__void__arg__function.html">validate_non_void_arg_function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a78701a79b0b34a22201b086137de5f4c">validate_non_void_arg_f</a></td></tr>
<tr class="separator:a78701a79b0b34a22201b086137de5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9220ac98f9466d939c27fef1ca47b2"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__void__function.html">set_void_function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aeb9220ac98f9466d939c27fef1ca47b2">set_void_function_f</a></td></tr>
<tr class="separator:aeb9220ac98f9466d939c27fef1ca47b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aa6fbb9a1e738c3440f4d64c38fabf"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__allows__sampling__origin.html">set_allows_sampling_origin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af7aa6fbb9a1e738c3440f4d64c38fabf">set_allows_sampling_origin_f</a></td></tr>
<tr class="separator:af7aa6fbb9a1e738c3440f4d64c38fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c3e9a528d25fa426c6b2c5c106882"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__declarations.html">validate_declarations</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a187c3e9a528d25fa426c6b2c5c106882">validate_declarations_f</a></td></tr>
<tr class="separator:a187c3e9a528d25fa426c6b2c5c106882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38e2868b4e8d8bd5932c265e1240360"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__function__signature.html">add_function_signature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac38e2868b4e8d8bd5932c265e1240360">add_function_signature_f</a></td></tr>
<tr class="separator:ac38e2868b4e8d8bd5932c265e1240360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e8be11f3ca753622ca4cd10aec2c9f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__return__type.html">validate_return_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a20e8be11f3ca753622ca4cd10aec2c9f">validate_return_type_f</a></td></tr>
<tr class="separator:a20e8be11f3ca753622ca4cd10aec2c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4620ce8dfc5b63868ec172c4f11ac2"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__pmf__pdf__variate.html">validate_pmf_pdf_variate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aba4620ce8dfc5b63868ec172c4f11ac2">validate_pmf_pdf_variate_f</a></td></tr>
<tr class="separator:aba4620ce8dfc5b63868ec172c4f11ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebceb67c6597d9918b888b50fea9fd44"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__prob__fun.html">validate_prob_fun</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aebceb67c6597d9918b888b50fea9fd44">validate_prob_fun_f</a></td></tr>
<tr class="separator:aebceb67c6597d9918b888b50fea9fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ef4b50a6aff209870870afc10e7152"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__fun__params__scope.html">set_fun_params_scope</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af2ef4b50a6aff209870870afc10e7152">set_fun_params_scope_f</a></td></tr>
<tr class="separator:af2ef4b50a6aff209870870afc10e7152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf05375acf268ff006abc8422f3cc8bb"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1unscope__variables.html">unscope_variables</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aaf05375acf268ff006abc8422f3cc8bb">unscope_variables_f</a></td></tr>
<tr class="separator:aaf05375acf268ff006abc8422f3cc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b253cdba26aa1abc973fefa71ab76"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__fun__var.html">add_fun_var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a205b253cdba26aa1abc973fefa71ab76">add_fun_var_f</a></td></tr>
<tr class="separator:a205b253cdba26aa1abc973fefa71ab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862217ec402048e344cd00bbace5a7f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__omni__idx.html">set_omni_idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6862217ec402048e344cd00bbace5a7f">set_omni_idx_f</a></td></tr>
<tr class="separator:a6862217ec402048e344cd00bbace5a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ead8684da9881c21e69230281c376f0"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expr__silent.html">validate_int_expr_silent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8ead8684da9881c21e69230281c376f0">validate_int_expr_silent_f</a></td></tr>
<tr class="separator:a8ead8684da9881c21e69230281c376f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a71795d7dbf64e63de484ce77e93be"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expression__warn.html">validate_int_expression_warn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a07a71795d7dbf64e63de484ce77e93be">validate_int_expression_warn_f</a></td></tr>
<tr class="separator:a07a71795d7dbf64e63de484ce77e93be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7dfe3a600cc67284fe3c37a9040bc8"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__ints__expression.html">validate_ints_expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#acb7dfe3a600cc67284fe3c37a9040bc8">validate_ints_expression_f</a></td></tr>
<tr class="separator:acb7dfe3a600cc67284fe3c37a9040bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d68283cf8598be450993ff7d116a11"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__params__var.html">add_params_var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa1d68283cf8598be450993ff7d116a11">add_params_var_f</a></td></tr>
<tr class="separator:aa1d68283cf8598be450993ff7d116a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6069db2edc4d4bb6283e9631bdf81a7"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1remove__params__var.html">remove_params_var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab6069db2edc4d4bb6283e9631bdf81a7">remove_params_var_f</a></td></tr>
<tr class="separator:ab6069db2edc4d4bb6283e9631bdf81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822df83f09c698b97761142503c7c0ee"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1program__error.html">program_error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a822df83f09c698b97761142503c7c0ee">program_error_f</a></td></tr>
<tr class="separator:a822df83f09c698b97761142503c7c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa887a72ee764faf7b02b9a19cfb7415a"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__conditional__condition.html">add_conditional_condition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa887a72ee764faf7b02b9a19cfb7415a">add_conditional_condition_f</a></td></tr>
<tr class="separator:aa887a72ee764faf7b02b9a19cfb7415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef45be44c4e6b944a4a7fa209806da9"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__conditional__body.html">add_conditional_body</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6ef45be44c4e6b944a4a7fa209806da9">add_conditional_body_f</a></td></tr>
<tr class="separator:a6ef45be44c4e6b944a4a7fa209806da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bb1c827e026f924e1d041ec9e0bbc7"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecate__old__assignment__op.html">deprecate_old_assignment_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a95bb1c827e026f924e1d041ec9e0bbc7">deprecate_old_assignment_op_f</a></td></tr>
<tr class="separator:a95bb1c827e026f924e1d041ec9e0bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7d836a48376f1e40360215748fe04"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__return__allowed.html">validate_return_allowed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aa1e7d836a48376f1e40360215748fe04">validate_return_allowed_f</a></td></tr>
<tr class="separator:aa1e7d836a48376f1e40360215748fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4fdb7c445c2e5b75c02eee9062fee"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__void__return__allowed.html">validate_void_return_allowed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1fe4fdb7c445c2e5b75c02eee9062fee">validate_void_return_allowed_f</a></td></tr>
<tr class="separator:a1fe4fdb7c445c2e5b75c02eee9062fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06879f3f1ecd5812dd477955b5cd0051"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__lhs__var__assgn.html">validate_lhs_var_assgn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a06879f3f1ecd5812dd477955b5cd0051">validate_lhs_var_assgn_f</a></td></tr>
<tr class="separator:a06879f3f1ecd5812dd477955b5cd0051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e5ff6477ea53b1a2278f6d7421429e"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__assgn.html">validate_assgn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae9e5ff6477ea53b1a2278f6d7421429e">validate_assgn_f</a></td></tr>
<tr class="separator:ae9e5ff6477ea53b1a2278f6d7421429e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f10724e3adb4a1eaad4291b6b6b6a6d"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__assignment.html">validate_assignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3f10724e3adb4a1eaad4291b6b6b6a6d">validate_assignment_f</a></td></tr>
<tr class="separator:a3f10724e3adb4a1eaad4291b6b6b6a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577d284c7eeb93563c4c83a17c261c48"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__sample.html">validate_sample</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a577d284c7eeb93563c4c83a17c261c48">validate_sample_f</a></td></tr>
<tr class="separator:a577d284c7eeb93563c4c83a17c261c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0a0e2f8b766b9808b70cd3a4ee7fc6"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1expression__as__statement.html">expression_as_statement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adc0a0e2f8b766b9808b70cd3a4ee7fc6">expression_as_statement_f</a></td></tr>
<tr class="separator:adc0a0e2f8b766b9808b70cd3a4ee7fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc55167da5686aa43fc31649e98468"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1unscope__locals.html">unscope_locals</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adcfc55167da5686aa43fc31649e98468">unscope_locals_f</a></td></tr>
<tr class="separator:adcfc55167da5686aa43fc31649e98468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfef57b170334b47c3c3323a1efa6c8a"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__while__condition.html">add_while_condition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#adfef57b170334b47c3c3323a1efa6c8a">add_while_condition_f</a></td></tr>
<tr class="separator:adfef57b170334b47c3c3323a1efa6c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113b28c041b2d695d365846978a38a9b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__while__body.html">add_while_body</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a113b28c041b2d695d365846978a38a9b">add_while_body_f</a></td></tr>
<tr class="separator:a113b28c041b2d695d365846978a38a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad5ad9629a5592fae8976ee79caaf92"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__loop__identifier.html">add_loop_identifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8ad5ad9629a5592fae8976ee79caaf92">add_loop_identifier_f</a></td></tr>
<tr class="separator:a8ad5ad9629a5592fae8976ee79caaf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20023baf9ffb97b5007e25d08136fb5"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1remove__loop__identifier.html">remove_loop_identifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae20023baf9ffb97b5007e25d08136fb5">remove_loop_identifier_f</a></td></tr>
<tr class="separator:ae20023baf9ffb97b5007e25d08136fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70036a4078612af7ba5b229da7bdb60"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecate__increment__log__prob.html">deprecate_increment_log_prob</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab70036a4078612af7ba5b229da7bdb60">deprecate_increment_log_prob_f</a></td></tr>
<tr class="separator:ab70036a4078612af7ba5b229da7bdb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0510f05000ee933eecb99ce2eaa62c5e"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__allow__sample.html">validate_allow_sample</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0510f05000ee933eecb99ce2eaa62c5e">validate_allow_sample_f</a></td></tr>
<tr class="separator:a0510f05000ee933eecb99ce2eaa62c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c5bedfc8ee2287070770e1fb209e2f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__non__void__expression.html">validate_non_void_expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a19c5bedfc8ee2287070770e1fb209e2f">validate_non_void_expression_f</a></td></tr>
<tr class="separator:a19c5bedfc8ee2287070770e1fb209e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096b22606e504822f8f0b8773b8aa3e"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__line__number.html">add_line_number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a0096b22606e504822f8f0b8773b8aa3e">add_line_number_f</a></td></tr>
<tr class="separator:a0096b22606e504822f8f0b8773b8aa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be8b1afb1b474b54f8c382973d8df3"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__void__return.html">set_void_return</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a24be8b1afb1b474b54f8c382973d8df3">set_void_return_f</a></td></tr>
<tr class="separator:a24be8b1afb1b474b54f8c382973d8df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3945c1fba849047c2db85b45d5d732"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__no__op.html">set_no_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aac3945c1fba849047c2db85b45d5d732">set_no_op_f</a></td></tr>
<tr class="separator:aac3945c1fba849047c2db85b45d5d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19064c96cb0d5c1a61cc21e0e6cd2cf9"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecated__integrate__ode.html">deprecated_integrate_ode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a19064c96cb0d5c1a61cc21e0e6cd2cf9">deprecated_integrate_ode_f</a></td></tr>
<tr class="separator:a19064c96cb0d5c1a61cc21e0e6cd2cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833d6cd0ab6cad306ca6d76d711d343"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__integrate__ode.html">validate_integrate_ode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4833d6cd0ab6cad306ca6d76d711d343">validate_integrate_ode_f</a></td></tr>
<tr class="separator:a4833d6cd0ab6cad306ca6d76d711d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e85866bb6db6eaebb8d07af8dbd13"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__integrate__ode__control.html">validate_integrate_ode_control</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#acc5e85866bb6db6eaebb8d07af8dbd13">validate_integrate_ode_control_f</a></td></tr>
<tr class="separator:acc5e85866bb6db6eaebb8d07af8dbd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f710ffe658533b2718168aefab419d5"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__fun__type__named.html">set_fun_type_named</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a7f710ffe658533b2718168aefab419d5">set_fun_type_named_f</a></td></tr>
<tr class="separator:a7f710ffe658533b2718168aefab419d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3634fd0eaf803aa6c8242293d7ea844"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1infer__array__expr__type.html">infer_array_expr_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad3634fd0eaf803aa6c8242293d7ea844">infer_array_expr_type_f</a></td></tr>
<tr class="separator:ad3634fd0eaf803aa6c8242293d7ea844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9969faf112e7a023977ad8bd94efeff"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1infer__vec__or__matrix__expr__type.html">infer_vec_or_matrix_expr_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac9969faf112e7a023977ad8bd94efeff">infer_vec_or_matrix_expr_type_f</a></td></tr>
<tr class="separator:ac9969faf112e7a023977ad8bd94efeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14ea43635049df71e5c88b07fb61ca"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1exponentiation__expr.html">exponentiation_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a8d14ea43635049df71e5c88b07fb61ca">exponentiation_f</a></td></tr>
<tr class="separator:a8d14ea43635049df71e5c88b07fb61ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7f42deee9c1172f1d9911715f47202"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1multiplication__expr.html">multiplication_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aaa7f42deee9c1172f1d9911715f47202">multiplication_f</a></td></tr>
<tr class="separator:aaa7f42deee9c1172f1d9911715f47202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a51434f84a41a8f9a28b8c0ce407b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1division__expr.html">division_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a681a51434f84a41a8f9a28b8c0ce407b">division_f</a></td></tr>
<tr class="separator:a681a51434f84a41a8f9a28b8c0ce407b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea16d18d77239e5e3c094dc75ece04bb"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1modulus__expr.html">modulus_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aea16d18d77239e5e3c094dc75ece04bb">modulus_f</a></td></tr>
<tr class="separator:aea16d18d77239e5e3c094dc75ece04bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c36ec7374e414afb6aa22c566e82e7"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1left__division__expr.html">left_division_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a85c36ec7374e414afb6aa22c566e82e7">left_division_f</a></td></tr>
<tr class="separator:a85c36ec7374e414afb6aa22c566e82e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4102ac311ae6ef9d63c63ae8f2afe7"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1elt__multiplication__expr.html">elt_multiplication_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#add4102ac311ae6ef9d63c63ae8f2afe7">elt_multiplication_f</a></td></tr>
<tr class="separator:add4102ac311ae6ef9d63c63ae8f2afe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c66d9e820714cdc709fdae189ee7587"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1elt__division__expr.html">elt_division_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1c66d9e820714cdc709fdae189ee7587">elt_division_f</a></td></tr>
<tr class="separator:a1c66d9e820714cdc709fdae189ee7587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb67c8b21205ec3389a5bcd06aef2b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1negate__expr.html">negate_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aadfb67c8b21205ec3389a5bcd06aef2b">negate_expr_f</a></td></tr>
<tr class="separator:aadfb67c8b21205ec3389a5bcd06aef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c15073b0f14ae44d221d76f73148155"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1logical__negate__expr.html">logical_negate_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3c15073b0f14ae44d221d76f73148155">logical_negate_expr_f</a></td></tr>
<tr class="separator:a3c15073b0f14ae44d221d76f73148155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1ae7da2c1c71f10f5254fc4f15f929"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1transpose__expr.html">transpose_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#aec1ae7da2c1c71f10f5254fc4f15f929">transpose_f</a></td></tr>
<tr class="separator:aec1ae7da2c1c71f10f5254fc4f15f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72baabb2672a243ac50dbf1f2030b563"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__idxs.html">add_idxs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a72baabb2672a243ac50dbf1f2030b563">add_idxs_f</a></td></tr>
<tr class="separator:a72baabb2672a243ac50dbf1f2030b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a1f248f0360b34de079b0b227990b2"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__expression__dimss.html">add_expression_dimss</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a18a1f248f0360b34de079b0b227990b2">add_expression_dimss_f</a></td></tr>
<tr class="separator:a18a1f248f0360b34de079b0b227990b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9c0f133baab40945c6cde3945285f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__type.html">set_var_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a85d9c0f133baab40945c6cde3945285f">set_var_type_f</a></td></tr>
<tr class="separator:a85d9c0f133baab40945c6cde3945285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c972bb350b41a53b8ffdaf328f321a"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1require__vbar.html">require_vbar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad8c972bb350b41a53b8ffdaf328f321a">require_vbar_f</a></td></tr>
<tr class="separator:ad8c972bb350b41a53b8ffdaf328f321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ebca80cc3f2cda24e75e7d8086c717"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__decl__constraints.html">validate_decl_constraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af5ebca80cc3f2cda24e75e7d8086c717">validate_decl_constraints_f</a></td></tr>
<tr class="separator:af5ebca80cc3f2cda24e75e7d8086c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac651a6d28d82e2afa0b37a731229c495"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__definition.html">validate_definition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ac651a6d28d82e2afa0b37a731229c495">validate_definition_f</a></td></tr>
<tr class="separator:ac651a6d28d82e2afa0b37a731229c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e90231eaf5c1f9750c90e88a09dff91"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__identifier.html">validate_identifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a6e90231eaf5c1f9750c90e88a09dff91">validate_identifier_f</a></td></tr>
<tr class="separator:a6e90231eaf5c1f9750c90e88a09dff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479900846afd139ed5fd5e8941641e0e"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1copy__square__cholesky__dimension__if__necessary.html">copy_square_cholesky_dimension_if_necessary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a479900846afd139ed5fd5e8941641e0e">copy_square_cholesky_dimension_if_necessary_f</a></td></tr>
<tr class="separator:a479900846afd139ed5fd5e8941641e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc573429b8e343036eaf2749dde1a985"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1empty__range.html">empty_range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#afc573429b8e343036eaf2749dde1a985">empty_range_f</a></td></tr>
<tr class="separator:afc573429b8e343036eaf2749dde1a985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273e836f53ba4e0280a4e9a5bc1a3f56"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expr.html">validate_int_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a273e836f53ba4e0280a4e9a5bc1a3f56">validate_int_expr_f</a></td></tr>
<tr class="separator:a273e836f53ba4e0280a4e9a5bc1a3f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12551895e6c99a14f548cb42e7b664b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__int__range__lower.html">set_int_range_lower</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ab12551895e6c99a14f548cb42e7b664b">set_int_range_lower_f</a></td></tr>
<tr class="separator:ab12551895e6c99a14f548cb42e7b664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0b30d7cdd3fe9b98d7f592a96a4c58"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__int__range__upper.html">set_int_range_upper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1b0b30d7cdd3fe9b98d7f592a96a4c58">set_int_range_upper_f</a></td></tr>
<tr class="separator:a1b0b30d7cdd3fe9b98d7f592a96a4c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807b1b32623789e2bedc4a6941a56d91"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__data__expr.html">validate_int_data_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a807b1b32623789e2bedc4a6941a56d91">validate_int_data_expr_f</a></td></tr>
<tr class="separator:a807b1b32623789e2bedc4a6941a56d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41398df14999df6529df448a61263d48"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__double__expr.html">validate_double_expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a41398df14999df6529df448a61263d48">validate_double_expr_f</a></td></tr>
<tr class="separator:a41398df14999df6529df448a61263d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fc25e409fa8d66c78ab745dc81358b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__double__range__lower.html">set_double_range_lower</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ad9fc25e409fa8d66c78ab745dc81358b">set_double_range_lower_f</a></td></tr>
<tr class="separator:ad9fc25e409fa8d66c78ab745dc81358b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2072724f6b35272d8f926ab82675aa2"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__double__range__upper.html">set_double_range_upper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#af2072724f6b35272d8f926ab82675aa2">set_double_range_upper_f</a></td></tr>
<tr class="separator:af2072724f6b35272d8f926ab82675aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f052a77427e0ab381643084bbab6da"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__var.html">add_var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a90f052a77427e0ab381643084bbab6da">add_var_f</a></td></tr>
<tr class="separator:a90f052a77427e0ab381643084bbab6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92d5b4efbca7a0bc51eab1784a3359f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__in__loop.html">validate_in_loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#ae92d5b4efbca7a0bc51eab1784a3359f">validate_in_loop_f</a></td></tr>
<tr class="separator:ae92d5b4efbca7a0bc51eab1784a3359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3704f701d2d71f4da2d26a0a092bf661"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1non__void__expression.html">non_void_expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a3704f701d2d71f4da2d26a0a092bf661">non_void_expression_f</a></td></tr>
<tr class="separator:a3704f701d2d71f4da2d26a0a092bf661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4502cb805b38efd45a3fc6ba121f8b"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__scope.html">set_var_scope</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a4f4502cb805b38efd45a3fc6ba121f8b">set_var_scope_f</a></td></tr>
<tr class="separator:a4f4502cb805b38efd45a3fc6ba121f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be86553295d8b1db06b4d9e6a9fdd33"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__scope__local.html">set_var_scope_local</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1be86553295d8b1db06b4d9e6a9fdd33">set_var_scope_local_f</a></td></tr>
<tr class="separator:a1be86553295d8b1db06b4d9e6a9fdd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c363c60bc1c580f8a46396386ca22f"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1reset__var__scope.html">reset_var_scope</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a62c363c60bc1c580f8a46396386ca22f">reset_var_scope_f</a></td></tr>
<tr class="separator:a62c363c60bc1c580f8a46396386ca22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa09f67196eac19446448aaa2520980"><td class="memItemLeft" align="right" valign="top">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1trace.html">trace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1lang.html#a1fa09f67196eac19446448aaa2520980">trace_f</a></td></tr>
<tr class="separator:a1fa09f67196eac19446448aaa2520980"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a68e0a56b53eff799154af42b5f6e79d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e0a56b53eff799154af42b5f6e79d2">&#9670;&nbsp;</a></span>base_expr_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">stan::lang::base_expr_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a base expression. </p>
<p>This is a typedef rather than an enum to get around forward declaration issues with enums in header files. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00012">12</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="a97d35e31b83b79f49db2a5d012d8bddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d35e31b83b79f49db2a5d012d8bddf">&#9670;&nbsp;</a></span>function_signature_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>, std::vector&lt;<a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a>&gt; &gt; <a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">stan::lang::function_signature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a function signature, mapping a vector of argument expression types to a result expression type. </p>

<p class="definition">Definition at line <a class="el" href="function__signature__t_8hpp_source.html#l00015">15</a> of file <a class="el" href="function__signature__t_8hpp_source.html">function_signature_t.hpp</a>.</p>

</div>
</div>
<a id="ae782260f5a96de91250c10d1ef3b3545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae782260f5a96de91250c10d1ef3b3545">&#9670;&nbsp;</a></span>input_iterator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::string::const_iterator <a class="el" href="namespacestan_1_1lang.html#ae782260f5a96de91250c10d1ef3b3545">stan::lang::input_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iterator__typedefs_8hpp_source.html#l00010">10</a> of file <a class="el" href="iterator__typedefs_8hpp_source.html">iterator_typedefs.hpp</a>.</p>

</div>
</div>
<a id="abf4ce75c6098aad77e950b21dd184aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4ce75c6098aad77e950b21dd184aae">&#9670;&nbsp;</a></span>origin_block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacestan_1_1lang.html#abf4ce75c6098aad77e950b21dd184aae">stan::lang::origin_block</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a variable indicating where a variable was declared. </p>
<p>This is a typedef rather than an enum to get around forward declaration issues with enums in header files. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00011">11</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a9a29d1a3569cd97a97b22c4003d018a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a29d1a3569cd97a97b22c4003d018a1">&#9670;&nbsp;</a></span>pos_iterator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::spirit::line_pos_iterator&lt;<a class="el" href="namespacestan_1_1lang.html#ae782260f5a96de91250c10d1ef3b3545">input_iterator_t</a>&gt; <a class="el" href="namespacestan_1_1lang.html#a9a29d1a3569cd97a97b22c4003d018a1">stan::lang::pos_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iterator__typedefs_8hpp_source.html#l00011">11</a> of file <a class="el" href="iterator__typedefs_8hpp_source.html">iterator_typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a28dd711498fe233f329ea6731f4b172a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dd711498fe233f329ea6731f4b172a">&#9670;&nbsp;</a></span>compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::compile </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stan_lang_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cpp_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a Stan model specification from the specified input, parse it, and write the C++ code for it to the specified output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgs</td><td>Output stream for warning messages </td></tr>
    <tr><td class="paramname">stan_lang_in</td><td>Stan model specification </td></tr>
    <tr><td class="paramname">cpp_out</td><td>C++ code output stream </td></tr>
    <tr><td class="paramname">model_name</td><td>Name of model class </td></tr>
    <tr><td class="paramname">allow_undefined</td><td>Permit undefined functions?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if code could not be generated due to syntax error in the Stan model; <code>true</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="compiler_8hpp_source.html#l00029">29</a> of file <a class="el" href="compiler_8hpp_source.html">compiler.hpp</a>.</p>

</div>
</div>
<a id="a250eeb4cda6a3bb97295ee2d800e38b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250eeb4cda6a3bb97295ee2d800e38b9">&#9670;&nbsp;</a></span>deprecate_fun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::deprecate_fun </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00092">92</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a2ac76887c545a71d370d5fa8c2199b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac76887c545a71d370d5fa8c2199b3f">&#9670;&nbsp;</a></span>deprecate_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::deprecate_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>deprecated_suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00103">103</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="afcae71a41014b85e241fc775002e59ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcae71a41014b85e241fc775002e59ff">&#9670;&nbsp;</a></span>EMPTY_EXP_VECTOR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>&gt; stan::lang::EMPTY_EXP_VECTOR </td>
          <td>(</td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size zero vector of expressions. </p>

</div>
</div>
<a id="a614834662faa194706352ca2fb07d6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614834662faa194706352ca2fb07d6bb">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified suffix appears at the end of the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suffix</td><td>suffix to test </td></tr>
    <tr><td class="paramname">s</td><td>string in which to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string ends with the suffix </dd></dl>

<p class="definition">Definition at line <a class="el" href="ends__with__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="ends__with__def_8hpp_source.html">ends_with_def.hpp</a>.</p>

</div>
</div>
<a id="a8e249a01efcee62d98c9333f26092907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e249a01efcee62d98c9333f26092907">&#9670;&nbsp;</a></span>EOL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::lang::EOL </td>
          <td>(</td>
          <td class="paramtype">&quot;\&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End-of-line marker. </p>

</div>
</div>
<a id="a5b6f46cd29cd827ff1c2eb20e9683e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6f46cd29cd827ff1c2eb20e9683e50">&#9670;&nbsp;</a></span>EOL2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::lang::EOL2 </td>
          <td>(</td>
          <td class="paramtype">&quot;\&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence of two end-of-line markers. </p>

</div>
</div>
<a id="af024f6a6dbb6ef8720bdf8e01092b3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af024f6a6dbb6ef8720bdf8e01092b3ca">&#9670;&nbsp;</a></span>fun_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::fun_exists </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::pair&lt; std::string, <a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">function_signature_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::string, <a class="el" href="namespacestan_1_1lang.html#a97d35e31b83b79f49db2a5d012d8bddf">function_signature_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>name_sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>name_only</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00381">381</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a0d5155974322ade65e45e8719841ec58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5155974322ade65e45e8719841ec58">&#9670;&nbsp;</a></span>fun_name_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::fun_name_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the function name has been declared as a built-in or by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it has been declared </dd></dl>

<p class="definition">Definition at line <a class="el" href="fun__name__exists__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="fun__name__exists__def_8hpp_source.html">fun_name_exists_def.hpp</a>.</p>

</div>
</div>
<a id="a04d8819742055bf9d16992c982324f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d8819742055bf9d16992c982324f50">&#9670;&nbsp;</a></span>fun_name_to_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::fun_name_to_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00282">282</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="adc5e5f5be53bf433949c8dd0887e968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5e5f5be53bf433949c8dd0887e968f">&#9670;&nbsp;</a></span>fun_scalar_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::fun_scalar_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string representing the scalar type to use in the body of the specified function declaration, with a flag indicating if the function is a log probability function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_lp</td><td>true if the function is a log probability function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representing scalar type to use within the function body </dd></dl>

<p class="definition">Definition at line <a class="el" href="fun__scalar__type_8hpp_source.html#l00024">24</a> of file <a class="el" href="fun__scalar__type_8hpp_source.html">fun_scalar_type.hpp</a>.</p>

</div>
</div>
<a id="a77a41b5cf8abe0f58039a8b4136c8118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a41b5cf8abe0f58039a8b4136c8118">&#9670;&nbsp;</a></span>generate_arg_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_arg_decl </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1arg__decl.html">arg_decl</a> &amp;&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scalar_t_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the argument declaration for a function with flags indicating whether to generate a <code>const</code> qualifer and whether to make the variable a reference, for the specified declaration and scalar type name from context, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gen_const</td><td>true if declaration is for const </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gen_ref</td><td>true if declaration is for reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>argument declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_t_name</td><td>string representing context scalar type </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for writing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__arg__decl_8hpp_source.html#l00026">26</a> of file <a class="el" href="generate__arg__decl_8hpp_source.html">generate_arg_decl.hpp</a>.</p>

</div>
</div>
<a id="ab15ec31c717d4d4e4ffee7cc988c582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15ec31c717d4d4e4ffee7cc988c582b">&#9670;&nbsp;</a></span>generate_array_builder_adds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_array_builder_adds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_facing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive helper function for array, matrix, and row_vector expressions which generates chain of calls to math lib array_builder add function for each of the contained elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements</td><td>vector of expression elements to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_facing</td><td>true if generation is to read by user, false for code generation in C++ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if generation in parameter var context, false for data context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__array__builder__adds_8hpp_source.html#l00024">24</a> of file <a class="el" href="generate__array__builder__adds_8hpp_source.html">generate_array_builder_adds.hpp</a>.</p>

</div>
</div>
<a id="aab6319c212bc5bd8b1b22048793bad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6319c212bc5bd8b1b22048793bad68">&#9670;&nbsp;</a></span>generate_array_var_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_array_var_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>real_var_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate C++ type for array expressions according to context in which expression appears. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_type</td><td>expression base type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">real_var_type</td><td>context-dependent <code>real</code> type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true when in auto-diff context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>generated typename </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__array__var__type_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__array__var__type_8hpp_source.html">generate_array_var_type.hpp</a>.</p>

</div>
</div>
<a id="ae2280469462eba80d78bb6b9eb24e307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2280469462eba80d78bb6b9eb24e307">&#9670;&nbsp;</a></span>generate_bare_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_bare_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scalar_t_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the basic type for the specified expression type without dimensions, using the specified scalar type string, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>expression type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_t_name</td><td>name of scalar type for double values and containers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__bare__type_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__bare__type_8hpp_source.html">generate_bare_type.hpp</a>.</p>

</div>
</div>
<a id="a67d8ed85e4f5a9dfb3552583fa5990ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d8ed85e4f5a9dfb3552583fa5990ac">&#9670;&nbsp;</a></span>generate_catch_throw_located()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_catch_throw_located </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate code to catch and rethrow an exception that includes location information read out of the generated context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__catch__throw__located_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__catch__throw__located_8hpp_source.html">generate_catch_throw_located.hpp</a>.</p>

</div>
</div>
<a id="a50daa15f4ec54c35a9336a9909afd8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50daa15f4ec54c35a9336a9909afd8b9">&#9670;&nbsp;</a></span>generate_class_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_class_decl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified name for the model class to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of class </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__class__decl_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__class__decl_8hpp_source.html">generate_class_decl.hpp</a>.</p>

</div>
</div>
<a id="a04c976d48e6aa89bd4fff8f17d502491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c976d48e6aa89bd4fff8f17d502491">&#9670;&nbsp;</a></span>generate_class_decl_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_class_decl_end </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="generate__class__decl__end_8hpp_source.html#l00011">11</a> of file <a class="el" href="generate__class__decl__end_8hpp_source.html">generate_class_decl_end.hpp</a>.</p>

</div>
</div>
<a id="a640628072fa1df38b50d6da1c8aad335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640628072fa1df38b50d6da1c8aad335">&#9670;&nbsp;</a></span>generate_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified message as a comment with the specified indentation and an end-of-line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>text of comment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__comment_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__comment_8hpp_source.html">generate_comment.hpp</a>.</p>

</div>
</div>
<a id="a7e1ece5a45b8104d4e13031573101e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1ece5a45b8104d4e13031573101e18">&#9670;&nbsp;</a></span>generate_constrained_param_names_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_constrained_param_names_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the <code>constrained_param_names</code> method for the specified program on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__constrained__param__names__method_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__constrained__param__names__method_8hpp_source.html">generate_constrained_param_names_method.hpp</a>.</p>

</div>
</div>
<a id="a70c55cdcf09d7956ddc16eb09247f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c55cdcf09d7956ddc16eb09247f452">&#9670;&nbsp;</a></span>generate_constructor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_constructor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the constructors for the specified program with the specified model name to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of model for class name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__constructor_8hpp_source.html#l00027">27</a> of file <a class="el" href="generate__constructor_8hpp_source.html">generate_constructor.hpp</a>.</p>

</div>
</div>
<a id="adc6f03b03bc788d2fec7bd888e7a46b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6f03b03bc788d2fec7bd888e7a46b3">&#9670;&nbsp;</a></span>generate_cpp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_cpp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generae the C++ code for the specified program, generating it in a class and namespace derived from the specified model name, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of model for generating namespace and class name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__cpp_8hpp_source.html#l00045">45</a> of file <a class="el" href="generate__cpp_8hpp_source.html">generate_cpp.hpp</a>.</p>

</div>
</div>
<a id="aac7b229aa2cae75bd8eff548b441818e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7b229aa2cae75bd8eff548b441818e">&#9670;&nbsp;</a></span>generate_destructor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_destructor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the destructor for the class with name specified by the model name to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of model to use as class name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__destructor_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__destructor_8hpp_source.html">generate_destructor.hpp</a>.</p>

</div>
</div>
<a id="ac0315c0d23213e76df1df99bbd4c36f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0315c0d23213e76df1df99bbd4c36f0">&#9670;&nbsp;</a></span>generate_dims_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_dims_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the <code>get_dims</code> method for the parameters, transformed parameters, and generated quantities, using the specified program and generating to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__dims__method_8hpp_source.html#l00021">21</a> of file <a class="el" href="generate__dims__method_8hpp_source.html">generate_dims_method.hpp</a>.</p>

</div>
</div>
<a id="af17f8b86415e9f8fccb1920b8ea61c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17f8b86415e9f8fccb1920b8ea61c35">&#9670;&nbsp;</a></span>generate_eigen_index_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_eigen_index_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified expression cast to an Eigen index to disambiguate from pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression for size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__eigen__index__expression_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__eigen__index__expression_8hpp_source.html">generate_eigen_index_expression.hpp</a>.</p>

</div>
</div>
<a id="ae0e6cf03ffa13649391b5bf0c8d1a1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e6cf03ffa13649391b5bf0c8d1a1f6">&#9670;&nbsp;</a></span>generate_expression() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_facing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified expression to the specified stream with user-facing/C++ format and parameter/data format controlled by the flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_facing</td><td>true if generation is to read by user, false for code generation in C++ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if generation in parameter var context, false for data context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generator_2generate__expression_8hpp_source.html#l00024">24</a> of file <a class="el" href="generator_2generate__expression_8hpp_source.html">generate_expression.hpp</a>.</p>

</div>
</div>
<a id="a5da949fcdecb7cfab1f8494620671cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da949fcdecb7cfab1f8494620671cfa">&#9670;&nbsp;</a></span>generate_expression() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the code generated by the specified expression to the specified output stream. </p>
<p>Generate the specified expression to the specified stream, with C++ syntax.</p>
<p>This is just the header for a forward declaration defined in the generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression to write </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream to which expression is written</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generator_2generate__expression_8hpp_source.html#l00055">55</a> of file <a class="el" href="generator_2generate__expression_8hpp_source.html">generate_expression.hpp</a>.</p>

</div>
</div>
<a id="a6d14a8cb1e25c388b521528771906b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d14a8cb1e25c388b521528771906b48">&#9670;&nbsp;</a></span>generate_expression() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_facing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the code generated by the specified expression to the specified output stream, putting it in a user-readable format if the user-facing flag is true. </p>
<p>Generate the specified expression to the specified stream, with user-facing or C++ syntax as specified by the flag.</p>
<p>This is just the header for a forward declaration defined in the generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_facing</td><td>true if expression should be written so that a user can understand it </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream to which expression is written</td></tr>
  </table>
  </dd>
</dl>
<p>The generation is done for a double context rather than a var (parameter) context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_facing</td><td>true if generation is to read by user, false for code generation in C++ </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generator_2generate__expression_8hpp_source.html#l00041">41</a> of file <a class="el" href="generator_2generate__expression_8hpp_source.html">generate_expression.hpp</a>.</p>

</div>
</div>
<a id="a2cf0d21bf10a57dc8c28ecd805a8616f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf0d21bf10a57dc8c28ecd805a8616f">&#9670;&nbsp;</a></span>generate_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified function and optionally its default for propto=false for functions ending in _log. </p>
<p>Exact behavior differs for unmarked functions, and functions ending in one of "_rng", "_lp", or "_log".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function AST object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream to which function definition is written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function_8hpp_source.html#l00030">30</a> of file <a class="el" href="generate__function_8hpp_source.html">generate_function.hpp</a>.</p>

</div>
</div>
<a id="a103540a88b344eb45dd57bc8f9da3777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103540a88b344eb45dd57bc8f9da3777">&#9670;&nbsp;</a></span>generate_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the arguments for the specified function, with precalculated flags for whether it is an RNG, uses the log density accumulator or is a probability function, to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_rng</td><td>true if function is an RNG </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_lp</td><td>true if function accesses log density accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_log</td><td>true if function is log probability function </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__arguments_8hpp_source.html#l00027">27</a> of file <a class="el" href="generate__function__arguments_8hpp_source.html">generate_function_arguments.hpp</a>.</p>

</div>
</div>
<a id="a06ae82422c29218477c8a8b8d24b4346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ae82422c29218477c8a8b8d24b4346">&#9670;&nbsp;</a></span>generate_function_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scalar_t_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the body of the specified function, with the specified local scalar type, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_t_name</td><td>name of type to use for scalars in the function body </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__body_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__function__body_8hpp_source.html">generate_function_body.hpp</a>.</p>

</div>
</div>
<a id="adeaaf3b731002b35d79d2825059383ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaaf3b731002b35d79d2825059383ba">&#9670;&nbsp;</a></span>generate_function_functor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_functor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the functor to accompnay a function with the specified declaration, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__functor_8hpp_source.html#l00025">25</a> of file <a class="el" href="generate__function__functor_8hpp_source.html">generate_function_functor.hpp</a>.</p>

</div>
</div>
<a id="a00021796ae676077e725024a0cab7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00021796ae676077e725024a0cab7963">&#9670;&nbsp;</a></span>generate_function_inline_return_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_inline_return_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scalar_t_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the return type for the specified function declaration in the context of the specified scalar type at the specified indentation level on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_t_name</td><td>string version of scalar type in context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__inline__return__type_8hpp_source.html#l00025">25</a> of file <a class="el" href="generate__function__inline__return__type_8hpp_source.html">generate_function_inline_return_type.hpp</a>.</p>

</div>
</div>
<a id="a557fe521a05aa73dfc28ec87eea01d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557fe521a05aa73dfc28ec87eea01d8d">&#9670;&nbsp;</a></span>generate_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the function name from the specified declaration on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__name_8hpp_source.html#l00017">17</a> of file <a class="el" href="generate__function__name_8hpp_source.html">generate_function_name.hpp</a>.</p>

</div>
</div>
<a id="ad5232450d142d99c03d87f04de0ff8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5232450d142d99c03d87f04de0ff8e2">&#9670;&nbsp;</a></span>generate_function_template_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_function_template_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the template declaration for functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_rng</td><td>true if function is a random number generator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_lp</td><td>true if function accesses log density accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_log</td><td>true if function is a probability function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__function__template__parameters_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__function__template__parameters_8hpp_source.html">generate_function_template_parameters.hpp</a>.</p>

</div>
</div>
<a id="ad0173ab4487bd74c062ae05befe6fdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0173ab4487bd74c062ae05befe6fdb3">&#9670;&nbsp;</a></span>generate_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>funs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate function forward declarations, definitions, and functors for the the specified sequence of function declarations and definitions, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">funs</td><td>sequence of function declarations and definitions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__functions_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__functions_8hpp_source.html">generate_functions.hpp</a>.</p>

</div>
</div>
<a id="a25fbdf2906fe6c56acffdaacee9fa175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fbdf2906fe6c56acffdaacee9fa175">&#9670;&nbsp;</a></span>generate_functor_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_functor_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the arguments for the functor for the specified function declaration, with flags indicating whether it is a random number generator, accesses the log density accumulator, or is a probability function, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_rng</td><td>true if function is a random number generator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_lp</td><td>true if function acceses log density accumulator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_log</td><td>true if function is log probability function </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__functor__arguments_8hpp_source.html#l00023">23</a> of file <a class="el" href="generate__functor__arguments_8hpp_source.html">generate_functor_arguments.hpp</a>.</p>

</div>
</div>
<a id="a4b789c9de67418b1aa4204f6ad5300e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b789c9de67418b1aa4204f6ad5300e6">&#9670;&nbsp;</a></span>generate_globals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_globals </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the global variables to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__globals_8hpp_source.html#l00015">15</a> of file <a class="el" href="generate__globals_8hpp_source.html">generate_globals.hpp</a>.</p>

</div>
</div>
<a id="a8354e7eccc24f136d9be9ce19c7d528f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8354e7eccc24f136d9be9ce19c7d528f">&#9670;&nbsp;</a></span>generate_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_idx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified multiple index on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>multiple index to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__idx_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__idx_8hpp_source.html">generate_idx.hpp</a>.</p>

</div>
</div>
<a id="a411fd9c7ef8d79b328232ba1326b70b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411fd9c7ef8d79b328232ba1326b70b0">&#9670;&nbsp;</a></span>generate_idx_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_idx_user </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified multiple index for users to the specified stream. </p>
<p>Generate specified multiple index for user on specified stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>multiple index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for writing</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>multiple index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="geneate__idx__user_8hpp_source.html#l00019">19</a> of file <a class="el" href="geneate__idx__user_8hpp_source.html">geneate_idx_user.hpp</a>.</p>

</div>
</div>
<a id="a3eba9e27aeae326aae7fd9f80174e158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eba9e27aeae326aae7fd9f80174e158">&#9670;&nbsp;</a></span>generate_idxs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_idxs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive helper function tracking position to generate specified multiple indexes on the specified stream in order to terminate with a nil index properly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>position in list to generate next </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>multiple indexes to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__idxs_8hpp_source.html#l00021">21</a> of file <a class="el" href="generate__idxs_8hpp_source.html">generate_idxs.hpp</a>.</p>

</div>
</div>
<a id="a558596f434a26337e759cd95be9f0d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558596f434a26337e759cd95be9f0d5c">&#9670;&nbsp;</a></span>generate_idxs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_idxs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified multiple indexes on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>multiple indexes to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__idxs_8hpp_source.html#l00040">40</a> of file <a class="el" href="generate__idxs_8hpp_source.html">generate_idxs.hpp</a>.</p>

</div>
</div>
<a id="ab73af326a080a06530f59ea933c25964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73af326a080a06530f59ea933c25964">&#9670;&nbsp;</a></span>generate_idxs_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_idxs_user </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified multiple indexes for users to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>multiple indexes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for writing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__idxs__user_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__idxs__user_8hpp_source.html">generate_idxs_user.hpp</a>.</p>

</div>
</div>
<a id="ac84d4b9ca2bca9e972330e62d57ad733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d4b9ca2bca9e972330e62d57ad733">&#9670;&nbsp;</a></span>generate_include()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_include </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lib_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an include statement for the specified library path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lib_name</td><td>path to library </td></tr>
    <tr><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__include_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__include_8hpp_source.html">generate_include.hpp</a>.</p>

</div>
</div>
<a id="a9a5b57ae08bfa77edfa3588e7ea8090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5b57ae08bfa77edfa3588e7ea8090b">&#9670;&nbsp;</a></span>generate_includes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_includes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate include statements for a Stan model class to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__includes_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__includes_8hpp_source.html">generate_includes.hpp</a>.</p>

</div>
</div>
<a id="a3279591c00e285d4690f8b759b471a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3279591c00e285d4690f8b759b471a29">&#9670;&nbsp;</a></span>generate_indent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_indent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the specified number of indentations to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">indent</td><td>number of indentations </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream to which indentations are written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__indent_8hpp_source.html#l00017">17</a> of file <a class="el" href="generate__indent_8hpp_source.html">generate_indent.hpp</a>.</p>

</div>
</div>
<a id="a79d00069bae8e0a8f6ccbc3b26f9cf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d00069bae8e0a8f6ccbc3b26f9cf85">&#9670;&nbsp;</a></span>generate_indexed_expr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isLHS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_indexed_expr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a>&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e_num_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_facing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified expression indexed with the specified indices with the specified base type of expression being indexed, number of dimensions, and a flag indicating whether the generation is for user output or C++ compilation. </p>
<p>Depending on the base type, two layers of parens may be written in the underlying code.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">isLHS</td><td>true if indexed expression appears on left-hand side of an assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>string for expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexes</td><td>indexes for expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_type</td><td>base type of expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_num_dims</td><td>number of array dimensions in expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_facing</td><td>true if expression generated for user output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__indexed__expr_8hpp_source.html#l00036">36</a> of file <a class="el" href="generate__indexed__expr_8hpp_source.html">generate_indexed_expr.hpp</a>.</p>

</div>
</div>
<a id="aafc3df38f59506641e2ad112bf1c1326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc3df38f59506641e2ad112bf1c1326">&#9670;&nbsp;</a></span>generate_indexed_expr_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_indexed_expr_user </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an expression with indices, writing brackets around indices and commas in between as necessary. </p>
<p>If no indices are presents, no brackets will be written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>expression for indexing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexes</td><td>sequence of indexes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for writing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__indexed__expr__user_8hpp_source.html#l00024">24</a> of file <a class="el" href="generate__indexed__expr__user_8hpp_source.html">generate_indexed_expr_user.hpp</a>.</p>

</div>
</div>
<a id="a7b1074b75e80ae57c872a5dae545b2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1074b75e80ae57c872a5dae545b2fe">&#9670;&nbsp;</a></span>generate_init_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_init_method </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the <code>transform_inits</code> method for the specified variable declarations to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__init__method_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__init__method_8hpp_source.html">generate_init_method.hpp</a>.</p>

</div>
</div>
<a id="acfd4fe85b5c9aae01ac8854e49b90456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd4fe85b5c9aae01ac8854e49b90456">&#9670;&nbsp;</a></span>generate_initialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_initialization </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg1</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg2</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate varaible initialization, checking dimension sizes are all positive, gnerating to the specified stream for a variable with the specified name, type, dimension sizes, and optional matrix/vector size declarations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var_name</td><td>name of variable being initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_type</td><td>base type of variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>dimension sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_arg1</td><td>optional vector/row-vector size or matrix rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_arg2</td><td>optional size of matrix columns </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__initialization_8hpp_source.html#l00031">31</a> of file <a class="el" href="generate__initialization_8hpp_source.html">generate_initialization.hpp</a>.</p>

</div>
</div>
<a id="a75edae9628bb2df4e757983c2f89b180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75edae9628bb2df4e757983c2f89b180">&#9670;&nbsp;</a></span>generate_initializer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_initializer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg1</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg2</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an initializer for a variable of the specified base type with the specified dimension sizes with an additional size for vectors and row vectors and two additional sizes for matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramname">base_type</td><td>base type of variable </td></tr>
    <tr><td class="paramname">dims</td><td>sizes of dimensions for variable </td></tr>
    <tr><td class="paramname">type_arg1</td><td>size of vector or row vector or size of rows for matrix, not used otherwise </td></tr>
    <tr><td class="paramname">type_arg2</td><td>size of columns for matrix, not used otherwise </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__initializer_8hpp_source.html#l00030">30</a> of file <a class="el" href="generate__initializer_8hpp_source.html">generate_initializer.hpp</a>.</p>

</div>
</div>
<a id="a59716735a34a8d1fa3c42e8c0d38ad94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59716735a34a8d1fa3c42e8c0d38ad94">&#9670;&nbsp;</a></span>generate_local_var_decls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_local_var_decls </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fun_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate local variable declarations, including initializations, for the specified declarations, indentation level, writing to the specified stream, with flags indicating if its in a variable context or function return environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if in a variable context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fun_return</td><td>true if in function return context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__local__var__decls_8hpp_source.html#l00032">32</a> of file <a class="el" href="generate__local__var__decls_8hpp_source.html">generate_local_var_decls.hpp</a>.</p>

</div>
</div>
<a id="ab7fec5f324807b4ad869cf8e317d434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fec5f324807b4ad869cf8e317d434c">&#9670;&nbsp;</a></span>generate_local_var_inits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_local_var_inits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>declare_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate initializations for the specified local variables, with flags indicating whether the generation is in a variable context and whether variables need to be declared, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if generating in variable context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">declare_vars</td><td>true if variables should be declared </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__local__var__inits_8hpp_source.html#l00026">26</a> of file <a class="el" href="generate__local__var__inits_8hpp_source.html">generate_local_var_inits.hpp</a>.</p>

</div>
</div>
<a id="a1e5e3ec1ab32219b9f45d2e2c2ded738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5e3ec1ab32219b9f45d2e2c2ded738">&#9670;&nbsp;</a></span>generate_located_statement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_located_statement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fun_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified statement at the specified indentation level to the specified stream, with flags indicating if sampling should be included and if the context requires generating variables or function return types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>statement to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_sampling</td><td>true if sampling should be included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if variable types should be generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fun_return</td><td>true if function return types should be generated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__located__statement_8hpp_source.html#l00028">28</a> of file <a class="el" href="generate__located__statement_8hpp_source.html">generate_located_statement.hpp</a>.</p>

</div>
</div>
<a id="a9fff5a6159d21a8fa197ffcdcb3436ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fff5a6159d21a8fa197ffcdcb3436ab">&#9670;&nbsp;</a></span>generate_located_statements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_located_statements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fun_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified sequence of statements at the specified indentation level to the specified stream, with flags indicating if sampling should be included and if the context requires generating variables or function return types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ss</td><td>statements to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_sampling</td><td>true if sampling should be included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if variable types should be generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fun_return</td><td>true if function return types should be generated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__located__statements_8hpp_source.html#l00029">29</a> of file <a class="el" href="generate__located__statements_8hpp_source.html">generate_located_statements.hpp</a>.</p>

</div>
</div>
<a id="ab531586be7dc69b398308b1f20a9c19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab531586be7dc69b398308b1f20a9c19e">&#9670;&nbsp;</a></span>generate_log_prob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_log_prob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the log_prob method for the model class for the specified program on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>program </td></tr>
    <tr><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__log__prob_8hpp_source.html#l00025">25</a> of file <a class="el" href="generate__log__prob_8hpp_source.html">generate_log_prob.hpp</a>.</p>

</div>
</div>
<a id="a0089eb06122fd9e9d0165a229ed97355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0089eb06122fd9e9d0165a229ed97355">&#9670;&nbsp;</a></span>generate_member_var_decls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_member_var_decls </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate member variable declarations for the specified variable declarations at the specified indentation level to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>stream for writing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__member__var__decls_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__member__var__decls_8hpp_source.html">generate_member_var_decls.hpp</a>.</p>

</div>
</div>
<a id="a22a7fc8358db90341990d229edb86ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a7fc8358db90341990d229edb86ed4">&#9670;&nbsp;</a></span>generate_member_var_decls_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_member_var_decls_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate member variable declarations for the data and transformed data blocks for the specified program, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__member__var__decls__all_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__member__var__decls__all_8hpp_source.html">generate_member_var_decls_all.hpp</a>.</p>

</div>
</div>
<a id="aadf65848bd87529b0958d0e7ac55abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf65848bd87529b0958d0e7ac55abdb">&#9670;&nbsp;</a></span>generate_member_var_inits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_member_var_inits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate initializations for member variables by reading from constructor variable context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>member variable declarations </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__member__var__inits_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__member__var__inits_8hpp_source.html">generate_member_var_inits.hpp</a>.</p>

</div>
</div>
<a id="a2dc76ee0cb31bcb69deaf7fc67bce377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc76ee0cb31bcb69deaf7fc67bce377">&#9670;&nbsp;</a></span>generate_model_name_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_model_name_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the <code>model_name</code> method for the specified name on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of model </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__model__name__method_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__model__name__method_8hpp_source.html">generate_model_name_method.hpp</a>.</p>

</div>
</div>
<a id="ab2fed58a730c099b59ca4ac4e6778bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fed58a730c099b59ca4ac4e6778bdc">&#9670;&nbsp;</a></span>generate_model_typedef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_model_typedef </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate reusable typedef of <code>stan_model</code> for specified model name writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model_name</td><td>name of model </td></tr>
    <tr><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__model__typedef_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__model__typedef_8hpp_source.html">generate_model_typedef.hpp</a>.</p>

</div>
</div>
<a id="a8103aeae7073bd8e7c181b40418262d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8103aeae7073bd8e7c181b40418262d2">&#9670;&nbsp;</a></span>generate_namespace_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_namespace_end </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the end of a namespace to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__namespace__end_8hpp_source.html#l00015">15</a> of file <a class="el" href="generate__namespace__end_8hpp_source.html">generate_namespace_end.hpp</a>.</p>

</div>
</div>
<a id="aa43178c547dea8dad5e42b022cd9e8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43178c547dea8dad5e42b022cd9e8f1">&#9670;&nbsp;</a></span>generate_namespace_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_namespace_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the opening name and brace for a namespace, with two end of lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of namespace </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__namespace__start_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__namespace__start_8hpp_source.html">generate_namespace_start.hpp</a>.</p>

</div>
</div>
<a id="afd7c5cdb9a251d32b1ffcebc9f96d6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7c5cdb9a251d32b1ffcebc9f96d6e0">&#9670;&nbsp;</a></span>generate_param_names_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_param_names_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the method to <code>get_param_names</code>, which retrieves the parameter names for the specified program on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__param__names__method_8hpp_source.html#l00021">21</a> of file <a class="el" href="generate__param__names__method_8hpp_source.html">generate_param_names_method.hpp</a>.</p>

</div>
</div>
<a id="af28b6847110427ad1b82bbe0cbac7132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28b6847110427ad1b82bbe0cbac7132">&#9670;&nbsp;</a></span>generate_printable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_printable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1printable.html">printable</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified printable object to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>object to print </td></tr>
    <tr><td class="paramname">o</td><td>stream for printing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__printable_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__printable_8hpp_source.html">generate_printable.hpp</a>.</p>

</div>
</div>
<a id="a952f4acdc9bc76c726aecef4dffb5e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f4acdc9bc76c726aecef4dffb5e0c">&#9670;&nbsp;</a></span>generate_private_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_private_decl </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the private declaration scope for a class to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__private__decl_8hpp_source.html#l00017">17</a> of file <a class="el" href="generate__private__decl_8hpp_source.html">generate_private_decl.hpp</a>.</p>

</div>
</div>
<a id="ab189d3e07ef4de1c3d0d392722f68aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab189d3e07ef4de1c3d0d392722f68aed">&#9670;&nbsp;</a></span>generate_propto_default_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_propto_default_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scalar_t_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a version of the specified function with propto set to false, with the specified local scalar type, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_t_name</td><td>string representation of scalar type for local scalar variables </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__propto__default__function_8hpp_source.html#l00026">26</a> of file <a class="el" href="generate__propto__default__function_8hpp_source.html">generate_propto_default_function.hpp</a>.</p>

</div>
</div>
<a id="aa631dfbaa3b71fbc2863e10c4cf8200a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa631dfbaa3b71fbc2863e10c4cf8200a">&#9670;&nbsp;</a></span>generate_propto_default_function_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_propto_default_function_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the body of the specified function with <code>propto</code> set to false, writing to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__propto__default__function__body_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__propto__default__function__body_8hpp_source.html">generate_propto_default_function_body.hpp</a>.</p>

</div>
</div>
<a id="ab043da56c6ea6b53ebe7e8f4935aaba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab043da56c6ea6b53ebe7e8f4935aaba2">&#9670;&nbsp;</a></span>generate_public_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_public_decl </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the public declaration scope for a class to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__public__decl_8hpp_source.html#l00017">17</a> of file <a class="el" href="generate__public__decl_8hpp_source.html">generate_public_decl.hpp</a>.</p>

</div>
</div>
<a id="aefdbcb0f7754e8399276987ba3318897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdbcb0f7754e8399276987ba3318897">&#9670;&nbsp;</a></span>generate_quoted_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_quoted_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="generate__quoted__expression_8hpp_source.html#l00015">15</a> of file <a class="el" href="generate__quoted__expression_8hpp_source.html">generate_quoted_expression.hpp</a>.</p>

</div>
</div>
<a id="a2e76a2997e923ebcba918cdb060b27a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76a2997e923ebcba918cdb060b27a8">&#9670;&nbsp;</a></span>generate_quoted_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_quoted_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the specified string to the specified output stream, wrapping in double quotes (") and inserting a backslash to escape double quotes, single quotes, and backslashes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>String to output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>Output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__quoted__string_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__quoted__string_8hpp_source.html">generate_quoted_string.hpp</a>.</p>

</div>
</div>
<a id="a4d8cedf0cb701b87f6ed1ec35ab4c53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8cedf0cb701b87f6ed1ec35ab4c53a">&#9670;&nbsp;</a></span>generate_real_var_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_real_var_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1lang_1_1scope.html">scope</a> &amp;&#160;</td>
          <td class="paramname"><em>var_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate correct C++ type for expressions which contain a Stan <code>real</code> variable according to context in which expression is used and expression contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var_scope</td><td>expression origin block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_var</td><td>does expression contains a variable? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true when in auto-diff context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>generated typename </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__real__var__type_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__real__var__type_8hpp_source.html">generate_real_var_type.hpp</a>.</p>

</div>
</div>
<a id="ae6990ffb5427dd0305be01a248e1283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6990ffb5427dd0305be01a248e1283b">&#9670;&nbsp;</a></span>generate_set_param_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_set_param_ranges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="generate__set__param__ranges_8hpp_source.html#l00023">23</a> of file <a class="el" href="generate__set__param__ranges_8hpp_source.html">generate_set_param_ranges.hpp</a>.</p>

</div>
</div>
<a id="a56886da3c87c6cd1be0dfac0a94fb1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56886da3c87c6cd1be0dfac0a94fb1cd">&#9670;&nbsp;</a></span>generate_statement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_statement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fun_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the specified statement with the specified indentation level on the specified output stream with flags indicating whether sampling statements are allowed and whether the generation is in a variable context or function return context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>statement to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_sampling</td><td>true if sampling statements are included </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_var_context</td><td>true if in context to generate variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fun_return</td><td>true if in context of function return </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__statement_8hpp_source.html#l00029">29</a> of file <a class="el" href="generate__statement_8hpp_source.html">generate_statement.hpp</a>.</p>

</div>
</div>
<a id="aedd1c495ab574219279dae19ace9cd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1c495ab574219279dae19ace9cd31">&#9670;&nbsp;</a></span>generate_statement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_statement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_var_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fun_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae04dae29366c8d3b1b288e84fa63b693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04dae29366c8d3b1b288e84fa63b693">&#9670;&nbsp;</a></span>generate_try()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_try </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the opening for a try statement at the specified indentation level on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__try_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__try_8hpp_source.html">generate_try.hpp</a>.</p>

</div>
</div>
<a id="a960dab8641f4f21ef44fc8b14e588178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960dab8641f4f21ef44fc8b14e588178">&#9670;&nbsp;</a></span>generate_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the base type for multi-dimensional arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_type</td><td>string representing bae type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>number of standard vector embeddings </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__type_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__type_8hpp_source.html">generate_type.hpp</a>.</p>

</div>
</div>
<a id="a2e0437f9441ee3598b7852a6b14b3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0437f9441ee3598b7852a6b14b3d16">&#9670;&nbsp;</a></span>generate_typedef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_typedef </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>abbrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a typedef statement for the specified type and abbreviation to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type for definition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abbrev</td><td>abbreviation defined for type </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for writing </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__typedef_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__typedef_8hpp_source.html">generate_typedef.hpp</a>.</p>

</div>
</div>
<a id="a6060f517680103fb357786016e73799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6060f517680103fb357786016e73799e">&#9670;&nbsp;</a></span>generate_typedefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_typedefs </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the typedefs required for the Stan model class to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__typedefs_8hpp_source.html#l00017">17</a> of file <a class="el" href="generate__typedefs_8hpp_source.html">generate_typedefs.hpp</a>.</p>

</div>
</div>
<a id="a462d6c610edb406c616dcb84561e104a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d6c610edb406c616dcb84561e104a">&#9670;&nbsp;</a></span>generate_unconstrained_param_names_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_unconstrained_param_names_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the method <code>unconstrained_param_names</code> for the specified program on the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>progam from which to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__unconstrained__param__names__method_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__unconstrained__param__names__method_8hpp_source.html">generate_unconstrained_param_names_method.hpp</a>.</p>

</div>
</div>
<a id="a1ccf71e3d97ac9c27569afee06828c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccf71e3d97ac9c27569afee06828c47">&#9670;&nbsp;</a></span>generate_using()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_using </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a using statement for the specified type to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type for which using statement is geneated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__using_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__using_8hpp_source.html">generate_using.hpp</a>.</p>

</div>
</div>
<a id="a3574bbaa4099cb3361fcfefa625488b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3574bbaa4099cb3361fcfefa625488b2">&#9670;&nbsp;</a></span>generate_using_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_using_namespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate using statement for the specified namespace to the specfied stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns</td><td>namespace for which using statement is generated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__using__namespace_8hpp_source.html#l00019">19</a> of file <a class="el" href="generate__using__namespace_8hpp_source.html">generate_using_namespace.hpp</a>.</p>

</div>
</div>
<a id="a627cc86c84d1bce30b0f4aef8f5bfc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627cc86c84d1bce30b0f4aef8f5bfc64">&#9670;&nbsp;</a></span>generate_usings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_usings </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the using statements for a Stan model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__usings_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__usings_8hpp_source.html">generate_usings.hpp</a>.</p>

</div>
</div>
<a id="a8fb80ed1268d2d938718e7eea1a5ef9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb80ed1268d2d938718e7eea1a5ef9d">&#9670;&nbsp;</a></span>generate_validate_context_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_validate_context_size </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg1</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>type_arg2</em> = <code><a class="el" href="structstan_1_1lang_1_1expression.html">expression</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="generate__validate__context__size_8hpp_source.html#l00030">30</a> of file <a class="el" href="generate__validate__context__size_8hpp_source.html">generate_validate_context_size.hpp</a>.</p>

</div>
</div>
<a id="aa079c530ddd844645eb91de16cc21736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa079c530ddd844645eb91de16cc21736">&#9670;&nbsp;</a></span>generate_validate_positive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_validate_positive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate call to stan_math lib function validate_non_negative_index which will throw an informative error if dim size is &lt; 0. </p>
<p>This check should precede the variable declaration in order to avoid bad alloc runtime error. Called by <br />
generate_validate_context_size - data variables <br />
generate_initialization - transformed data declarations <br />
generate_var_resiszing - initializes transformed data variables <br />
generate_local_var_decls - local variables, transformed parameters write array, generated quantities <br />
 generate_set_param_ranges - parameter variables</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var_name</td><td>variable name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>declared dim size expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indents</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>output stream for generated code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__validate__positive_8hpp_source.html#l00034">34</a> of file <a class="el" href="generate__validate__positive_8hpp_source.html">generate_validate_positive.hpp</a>.</p>

</div>
</div>
<a id="a9a3f6f343eb242b917e2ae9ef35a7c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3f6f343eb242b917e2ae9ef35a7c0c">&#9670;&nbsp;</a></span>generate_validate_transformed_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_validate_transformed_params </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate code to validate the specified transformed parameters, generating at the specified indentation level to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__validate__transformed__params_8hpp_source.html#l00024">24</a> of file <a class="el" href="generate__validate__transformed__params_8hpp_source.html">generate_validate_transformed_params.hpp</a>.</p>

</div>
</div>
<a id="a30f68fd556e3a70a67bdb0cba8456d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f68fd556e3a70a67bdb0cba8456d37">&#9670;&nbsp;</a></span>generate_validate_var_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_validate_var_decl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &amp;&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate code to validate the specified variable declaration at the specified indentation level to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>variable declaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__validate__var__decl_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__validate__var__decl_8hpp_source.html">generate_validate_var_decl.hpp</a>.</p>

</div>
</div>
<a id="ac697de175dffd2a594113160200a793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac697de175dffd2a594113160200a793a">&#9670;&nbsp;</a></span>generate_validate_var_decls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_validate_var_decls </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt;&#160;</td>
          <td class="paramname"><em>decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate code to validate the specified variable declarations at the specified indentation level to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decls</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__validate__var__decls_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__validate__var__decls_8hpp_source.html">generate_validate_var_decls.hpp</a>.</p>

</div>
</div>
<a id="ac2341909a4024920c02ce4a307c43171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2341909a4024920c02ce4a307c43171">&#9670;&nbsp;</a></span>generate_var_resizing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_var_resizing </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1var__decl.html">var_decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate code to to the specified stream to resize the variables in the specified declarations and fill them with dummy values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vs</td><td>variable declarations </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__var__resizing_8hpp_source.html#l00022">22</a> of file <a class="el" href="generate__var__resizing_8hpp_source.html">generate_var_resizing.hpp</a>.</p>

</div>
</div>
<a id="adecd1271b3c82648546113d3c5a6bbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd1271b3c82648546113d3c5a6bbd9">&#9670;&nbsp;</a></span>generate_version_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_version_comment </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a comment indicating which version of Stan generated the model code to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__version__comment_8hpp_source.html#l00018">18</a> of file <a class="el" href="generate__version__comment_8hpp_source.html">generate_version_comment.hpp</a>.</p>

</div>
</div>
<a id="af80e12bb2bb3feba762be053b83ad0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e12bb2bb3feba762be053b83ad0fa">&#9670;&nbsp;</a></span>generate_void_statement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_void_statement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a dummy void-cast statement for a variable of the specified name at the specified indentation level to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>variable name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation level </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for genering </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__void__statement_8hpp_source.html#l00020">20</a> of file <a class="el" href="generate__void__statement_8hpp_source.html">generate_void_statement.hpp</a>.</p>

</div>
</div>
<a id="a8d378c308e28684825330054a9da228b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d378c308e28684825330054a9da228b">&#9670;&nbsp;</a></span>generate_write_array_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::generate_write_array_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the <code>write_array</code> method for the specified program, with specified model name to the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prog</td><td>program from which to generate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>name of model </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">o</td><td>stream for generating </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="generate__write__array__method_8hpp_source.html#l00028">28</a> of file <a class="el" href="generate__write__array__method_8hpp_source.html">generate_write_array_method.hpp</a>.</p>

</div>
</div>
<a id="a73fd3dfe5cfcb36920b948c5fef3a35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fd3dfe5cfcb36920b948c5fef3a35a">&#9670;&nbsp;</a></span>get_ccdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::get_ccdf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the CCDF for the specified distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_name</td><td>name of distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCDF for distribution </dd></dl>

<p class="definition">Definition at line <a class="el" href="get__ccdf__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="get__ccdf__def_8hpp_source.html">get_ccdf_def.hpp</a>.</p>

</div>
</div>
<a id="a98ff82ea83b8859ab132717e01daa12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ff82ea83b8859ab132717e01daa12f">&#9670;&nbsp;</a></span>get_cdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::get_cdf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the CDF for the specified distribution name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist_name</td><td>name of distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of CDF </dd></dl>

<p class="definition">Definition at line <a class="el" href="get__cdf__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="get__cdf__def_8hpp_source.html">get_cdf_def.hpp</a>.</p>

</div>
</div>
<a id="a2e57a6bb661f555faa3d4ff0969488f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e57a6bb661f555faa3d4ff0969488f8">&#9670;&nbsp;</a></span>get_prob_fun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::get_prob_fun </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the probability function (density or mass) for the specified distribution name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_name</td><td>name of distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probability function for distribution </dd></dl>

<p class="definition">Definition at line <a class="el" href="get__prob__fun__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="get__prob__fun__def_8hpp_source.html">get_prob_fun_def.hpp</a>.</p>

</div>
</div>
<a id="ae7da6a6f3383dae56a6e7cfba3fd3a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da6a6f3383dae56a6e7cfba3fd3a15">&#9670;&nbsp;</a></span>has_ccdf_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_ccdf_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified function name has a suffix indicating it is a CCDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function has a suffix indicating it is a CCDF </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__ccdf__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__ccdf__suffix__def_8hpp_source.html">has_ccdf_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="ad3b6b47e3d523cd5f2d527e08849098e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b6b47e3d523cd5f2d527e08849098e">&#9670;&nbsp;</a></span>has_cdf_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_cdf_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified function name has a suffix indicating it is a CDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the function has a suffix indicating it is a CDF </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__cdf__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__cdf__suffix__def_8hpp_source.html">has_cdf_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a48ccd21f3cccb2f1bfe9ca9fa41ea946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ccd21f3cccb2f1bfe9ca9fa41ea946">&#9670;&nbsp;</a></span>has_lb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_lb </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the the specified declaration has a lower bound range constraint but not an upper bound range constraint. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>type of declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the declaration has only a lower bound constraint </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__lb_8hpp_source.html#l00018">18</a> of file <a class="el" href="has__lb_8hpp_source.html">has_lb.hpp</a>.</p>

</div>
</div>
<a id="a2b85b03ca1407e08468dd579fe307724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b85b03ca1407e08468dd579fe307724">&#9670;&nbsp;</a></span>has_lp_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_lp_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified string has the suffix "_lp". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>function name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="has__lp__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__lp__suffix__def_8hpp_source.html">has_lp_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a6cdebaa5910c1e0ecb41e247186a0079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdebaa5910c1e0ecb41e247186a0079">&#9670;&nbsp;</a></span>has_lub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_lub </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the the specified declaration has a lower bound and upper bound range constraint. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>type of declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the declaration has lower and upper bounds </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__lub_8hpp_source.html#l00018">18</a> of file <a class="el" href="has__lub_8hpp_source.html">has_lub.hpp</a>.</p>

</div>
</div>
<a id="a12445f29328788d14a292974c22f6f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12445f29328788d14a292974c22f6f53">&#9670;&nbsp;</a></span>has_non_param_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_non_param_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;&#160;</td>
          <td class="paramname"><em>var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified expression contains a variable that requires a Jacobian warning. </p>
<p>This is either a transformed variable or a local variable or a non-linear function of a parameter.</p>
<p>Compare to <code>has_var</code>, which is similar, but just tests for inclusion of variables declared in the parameters, transformed parameters, or model block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Expression to test. </td></tr>
    <tr><td class="paramname">var_map</td><td>Variable mapping for origin and types of variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if expression contains a variable defined as a transformed parameter, or is a local variable that is not an integer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__non__param__var__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__non__param__var__def_8hpp_source.html">has_non_param_var_def.hpp</a>.</p>

</div>
</div>
<a id="a8544df0c4a5d6a17bbf462527445bebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8544df0c4a5d6a17bbf462527445bebb">&#9670;&nbsp;</a></span>has_only_int_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_only_int_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1function__decl__def.html">function_decl_def</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified function has only integer arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>function declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool if the function has only integer arguments </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__only__int__args_8hpp_source.html#l00016">16</a> of file <a class="el" href="has__only__int__args_8hpp_source.html">has_only_int_args.hpp</a>.</p>

</div>
</div>
<a id="accac1652ebed390c3e84e58b169cf593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accac1652ebed390c3e84e58b169cf593">&#9670;&nbsp;</a></span>has_prob_fun_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_prob_fun_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the function with the specified name has a suffix indicating it is a probability function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>function name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function anme has a suffix indicating it is a probability function </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__prob__fun__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__prob__fun__suffix__def_8hpp_source.html">has_prob_fun_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a74b758f597c04dd15deb5b577e2c4c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b758f597c04dd15deb5b577e2c4c0a">&#9670;&nbsp;</a></span>has_prob_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_prob_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00079">79</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac9c73eb1b88dc808ccef61c25d3bdf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c73eb1b88dc808ccef61c25d3bdf3c">&#9670;&nbsp;</a></span>has_rng_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_rng_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified string has the suffix "_rng". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>function name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="has__rng__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__rng__suffix__def_8hpp_source.html">has_rng_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a9534baee0f138bf625dc226433f47f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9534baee0f138bf625dc226433f47f89">&#9670;&nbsp;</a></span>has_ub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_ub </td>
          <td>(</td>
          <td class="paramtype">const D &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the the specified declaration has an upper bound range constraint but not a lower bound range constraint. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>type of declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>declaration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the declaration has only an upper bound constraint </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__ub_8hpp_source.html#l00018">18</a> of file <a class="el" href="has__ub_8hpp_source.html">has_ub.hpp</a>.</p>

</div>
</div>
<a id="abf7ee6aa6282ef4e6b2662783145a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7ee6aa6282ef4e6b2662783145a087">&#9670;&nbsp;</a></span>has_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::has_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;&#160;</td>
          <td class="paramname"><em>var_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified expression contains a variable that is defined as a parameter, defined as a transformed parameter, or is a local variable that is not an integer. </p>
<p>Compare to <code>has_nonparam_var</code>, which is similar, but excludes variables declared as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Expression to test. </td></tr>
    <tr><td class="paramname">var_map</td><td>Variable mapping for origin and types of variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if expression contains a variable defined as as a parameter, defined as a transformedparameter, or is a local variable that is not an integer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="has__var__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="has__var__def_8hpp_source.html">has_var_def.hpp</a>.</p>

</div>
</div>
<a id="ae849e8dda2ae020630ac0751ff7b69ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae849e8dda2ae020630ac0751ff7b69ff">&#9670;&nbsp;</a></span>INDENT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::lang::INDENT </td>
          <td>(</td>
          <td class="paramtype">&quot; &quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single indentation. </p>

</div>
</div>
<a id="a7ea198423296d857fb1c541ab4932bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea198423296d857fb1c541ab4932bd3">&#9670;&nbsp;</a></span>INDENT2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::lang::INDENT2 </td>
          <td>(</td>
          <td class="paramtype">&quot; &quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double indentation. </p>

</div>
</div>
<a id="a9d665b3ed813d4eee09d29d9e806d247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d665b3ed813d4eee09d29d9e806d247">&#9670;&nbsp;</a></span>INDENT3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::lang::INDENT3 </td>
          <td>(</td>
          <td class="paramtype">&quot; &quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triple indentation. </p>

</div>
</div>
<a id="a36003a9c077e1f0e846235fcb26b9a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36003a9c077e1f0e846235fcb26b9a01">&#9670;&nbsp;</a></span>indexed_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::indexed_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the expression indexed by the generalized index sequence. </p>
<p>Return a type with base type <code>ILL_FORMED_T</code> if there are too many indexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Expression being indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Index sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type of expression applied to indexes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="indexed__type__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="indexed__type__def_8hpp_source.html">indexed_type_def.hpp</a>.</p>

</div>
</div>
<a id="a4fc632c04d1dcb7418bfd0afa199e02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc632c04d1dcb7418bfd0afa199e02d">&#9670;&nbsp;</a></span>infer_type_indexing() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::infer_type_indexing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>expr_base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_expr_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_index_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="infer__type__indexing__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="infer__type__indexing__def_8hpp_source.html">infer_type_indexing_def.hpp</a>.</p>

</div>
</div>
<a id="ad7fb09b61f971c94c7c1429249933906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fb09b61f971c94c7c1429249933906">&#9670;&nbsp;</a></span>infer_type_indexing() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::infer_type_indexing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expression type resulting from indexing an expression of the specified base type and number of dimensions with the specified number of indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_type</td><td>base type of expression being indexed </td></tr>
    <tr><td class="paramname">dims</td><td>number of dimensions of the expression being indexed </td></tr>
    <tr><td class="paramname">num_indexes</td><td>number of indexes provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression type of indexed expression </dd></dl>

</div>
</div>
<a id="a701776c4b46d1aced9b9b32c0b5ee29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701776c4b46d1aced9b9b32c0b5ee29c">&#9670;&nbsp;</a></span>infer_type_indexing() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::infer_type_indexing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_index_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="infer__type__indexing__def_8hpp_source.html#l00029">29</a> of file <a class="el" href="infer__type__indexing__def_8hpp_source.html">infer_type_indexing_def.hpp</a>.</p>

</div>
</div>
<a id="af7466f117e09649c22649efdebec2fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7466f117e09649c22649efdebec2fe1">&#9670;&nbsp;</a></span>infer_type_indexing() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::infer_type_indexing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expression type resulting from indexing the specified expression with the specified number of indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>expression being indexed </td></tr>
    <tr><td class="paramname">num_indexes</td><td>number of indexes provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression type of indexed expression </dd></dl>

</div>
</div>
<a id="adaeddc18b2b07e4dfdfda4ad88e8b9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeddc18b2b07e4dfdfda4ad88e8b9a3">&#9670;&nbsp;</a></span>is_assignable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_assignable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>l_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>r_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>failure_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>error_msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if an expression of the right-hand side type is assignable to a variable of the left-hand side type, writing the failure message to the error messages if the asisgnment is not legal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l_type</td><td>type of expression being assigned to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_type</td><td>type of value expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">failure_message</td><td>message to write if assignment is not possible </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">error_msgs</td><td>stream to which error messages are written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the assignment is legal </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__assignable__def_8hpp_source.html#l00011">11</a> of file <a class="el" href="is__assignable__def_8hpp_source.html">is_assignable_def.hpp</a>.</p>

</div>
</div>
<a id="a332386935a5f4361be00138c19451388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332386935a5f4361be00138c19451388">&#9670;&nbsp;</a></span>is_binary_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_binary_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00252">252</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="a4136c84f86c5c60d8e11005a78516075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4136c84f86c5c60d8e11005a78516075">&#9670;&nbsp;</a></span>is_defined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_defined </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00975">975</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ad84bd96c2954db4474805a06eaeb3b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84bd96c2954db4474805a06eaeb3b14">&#9670;&nbsp;</a></span>is_double_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_double_return </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>error_msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00982">982</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a2b7f940afd153a816c0c4114e58bac9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7f940afd153a816c0c4114e58bac9d">&#9670;&nbsp;</a></span>is_linear_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_linear_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="has__non__param__var__vis__def_8hpp_source.html#l00011">11</a> of file <a class="el" href="has__non__param__var__vis__def_8hpp_source.html">has_non_param_var_vis_def.hpp</a>.</p>

</div>
</div>
<a id="a5613d178abb61fdaadf44c405e5cd556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5613d178abb61fdaadf44c405e5cd556">&#9670;&nbsp;</a></span>is_multi_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_multi_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1idx.html">idx</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified index potentially takes more than one value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is not a unary index </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__multi__index__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="is__multi__index__def_8hpp_source.html">is_multi_index_def.hpp</a>.</p>

</div>
</div>
<a id="a3464b73e4e976ed85f3faf2554611826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3464b73e4e976ed85f3faf2554611826">&#9670;&nbsp;</a></span>is_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_nil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified expression is nil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>expression to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if expression is nil </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__nil__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="is__nil__def_8hpp_source.html">is_nil_def.hpp</a>.</p>

</div>
</div>
<a id="a9f14dcfd1c3959fb168642a88b1b1241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f14dcfd1c3959fb168642a88b1b1241">&#9670;&nbsp;</a></span>is_nonempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_nonempty </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00052">52</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a466e505467b9317523280cfc19bbf61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466e505467b9317523280cfc19bbf61e">&#9670;&nbsp;</a></span>is_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00273">273</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="a2061b9f3e0e3c17cf5fc9c53c9c1fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2061b9f3e0e3c17cf5fc9c53c9c1fc45">&#9670;&nbsp;</a></span>is_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_space </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00048">48</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a2db96048c52e496af42ae879a6c6b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db96048c52e496af42ae879a6c6b8cb">&#9670;&nbsp;</a></span>is_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_type </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified exception can be dynamically cast to the template parameter type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>Type to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Exception to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if exception can be dynamically cast to type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rethrow__located_8hpp_source.html#l00025">25</a> of file <a class="el" href="rethrow__located_8hpp_source.html">rethrow_located.hpp</a>.</p>

</div>
</div>
<a id="a28ff1096677d578c3ddd33ca62a89b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ff1096677d578c3ddd33ca62a89b82">&#9670;&nbsp;</a></span>is_unary_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_unary_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00264">264</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="aba1b8580f14b027763a642552f9b106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1b8580f14b027763a642552f9b106d">&#9670;&nbsp;</a></span>is_unary_postfix_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_unary_postfix_operator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00269">269</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="ac84a3990582f5c439e655bc039d22d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84a3990582f5c439e655bc039d22d82">&#9670;&nbsp;</a></span>is_univariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_univariate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00990">990</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a8b8b4ce523118153a33565cc27afcc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8b4ce523118153a33565cc27afcc03">&#9670;&nbsp;</a></span>is_user_defined() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_user_defined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified function was declared in the functions block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fx</td><td>function with arguments </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="is__user__defined__def_8hpp_source.html#l00012">12</a> of file <a class="el" href="is__user__defined__def_8hpp_source.html">is_user_defined_def.hpp</a>.</p>

</div>
</div>
<a id="a3ff40a7a2ce84d02e5b4fe69a11277e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff40a7a2ce84d02e5b4fe69a11277e3">&#9670;&nbsp;</a></span>is_user_defined() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_user_defined </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a function with the specified name and arguments was defined in the functions block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>function name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>function arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function is defined in the functions block </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__user__defined__def_8hpp_source.html#l00016">16</a> of file <a class="el" href="is__user__defined__def_8hpp_source.html">is_user_defined_def.hpp</a>.</p>

</div>
</div>
<a id="a2491b5c8b3cc203be2acfefdd4650c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2491b5c8b3cc203be2acfefdd4650c39">&#9670;&nbsp;</a></span>is_user_defined_prob_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::is_user_defined_prob_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &amp;&#160;</td>
          <td class="paramname"><em>variate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a probability function with the specified name, random variate and parameters is user defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>function name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variate</td><td>random variable for probability function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parameters to probability function </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="is__user__defined__prob__function__def_8hpp_source.html#l00011">11</a> of file <a class="el" href="is__user__defined__prob__function__def_8hpp_source.html">is_user_defined_prob_function_def.hpp</a>.</p>

</div>
</div>
<a id="aec1d44bc5e384562a72befaddf7ccb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1d44bc5e384562a72befaddf7ccb3e">&#9670;&nbsp;</a></span>num_dimss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stan::lang::num_dimss </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">stan::lang::expression</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00136">136</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a9d8c19e05423f019874999bfca2d18ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8c19e05423f019874999bfca2d18ac">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; stan::lang::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream a user-readable version of the expression type to the specified output stream, returning the speicifed argument output stream to allow chaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">et</td><td>expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>argument output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="expr__type__def_8hpp_source.html#l00077">77</a> of file <a class="el" href="expr__type__def_8hpp_source.html">expr_type_def.hpp</a>.</p>

</div>
</div>
<a id="a3ce966334660208046cbfaf72e1c1d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce966334660208046cbfaf72e1c1d5f">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::parse </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>output_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1program.html">program</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_8hpp_source.html#l00059">59</a> of file <a class="el" href="parser_8hpp_source.html">parser.hpp</a>.</p>

</div>
</div>
<a id="a911f61cb03332694c4aa42d5788237d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911f61cb03332694c4aa42d5788237d3">&#9670;&nbsp;</a></span>print_scope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::print_scope </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1lang_1_1scope.html">scope</a> &amp;&#160;</td>
          <td class="paramname"><em>var_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a user-readable version of the specified variable scope to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">var_scope</td><td>variable scope </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="print__scope__def_8hpp_source.html#l00009">9</a> of file <a class="el" href="print__scope__def_8hpp_source.html">print_scope_def.hpp</a>.</p>

</div>
</div>
<a id="a5ca1c8d93ce4f50d8cff58259c420fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca1c8d93ce4f50d8cff58259c420fd0">&#9670;&nbsp;</a></span>print_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::print_signature </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampling_error_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="function__signatures__def_8hpp_source.html#l00305">305</a> of file <a class="el" href="function__signatures__def_8hpp_source.html">function_signatures_def.hpp</a>.</p>

</div>
</div>
<a id="af68eacf4ea9f2c64c869c72c55cc649b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68eacf4ea9f2c64c869c72c55cc649b">&#9670;&nbsp;</a></span>promote_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::promote_primitive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">et</td><td>expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>promoted expression type </dd></dl>

<p class="definition">Definition at line <a class="el" href="promote__primitive__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="promote__primitive__def_8hpp_source.html">promote_primitive_def.hpp</a>.</p>

</div>
</div>
<a id="a46109ea20ae5db396814aa9f54677d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46109ea20ae5db396814aa9f54677d05">&#9670;&nbsp;</a></span>promote_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> stan::lang::promote_primitive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>et1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>et2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">et1</td><td>first expression type </td></tr>
    <tr><td class="paramname">et2</td><td>second expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>promoted expression type </dd></dl>

<p class="definition">Definition at line <a class="el" href="promote__primitive__def_8hpp_source.html#l00016">16</a> of file <a class="el" href="promote__primitive__def_8hpp_source.html">promote_primitive_def.hpp</a>.</p>

</div>
</div>
<a id="ab11de2e113c82999d121de8c5e43b298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11de2e113c82999d121de8c5e43b298">&#9670;&nbsp;</a></span>qualify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::qualify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set original name of specified function to name and add "stan::math::" namespace qualifier to name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>Function to qualify. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00033">33</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="af87260e8936a69f25768009bce33c4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87260e8936a69f25768009bce33c4d4">&#9670;&nbsp;</a></span>qualify_builtins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::qualify_builtins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add qualifier "stan::math::" to nullary functions defined in the Stan language. </p>
<p>Sets original name of specified function to name and add "stan::math::" namespace qualifier to name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>Function to qualify. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00045">45</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a4ad7f6afa9f2598380e313ca819942c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7f6afa9f2598380e313ca819942c3">&#9670;&nbsp;</a></span>qualify_cpp11_builtins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::qualify_cpp11_builtins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add namespace qualifier <a class="el" href="namespacestan_1_1math.html" title="Matrices and templated mathematical functions. ">stan::math</a>:: to specify Stan versions of functions to avoid ambiguities with versions defined in math.h in the top-level namespace. </p>
<p>Sets original name of specified function to name and add <code><a class="el" href="namespacestan_1_1math.html" title="Matrices and templated mathematical functions. ">stan::math</a>::</code> namespace qualifier to name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>Function to qualify. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00063">63</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a2d054318947617826a426deffadab61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d054318947617826a426deffadab61a">&#9670;&nbsp;</a></span>replace_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::replace_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>old_suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00084">84</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a90284258a07c639d7b3bfb285317819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90284258a07c639d7b3bfb285317819a">&#9670;&nbsp;</a></span>rethrow_located()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::rethrow_located </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rethrow an exception of type specified by the dynamic type of the specified exception, adding the specified line number to the specified exception's message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Original exception. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line number in Stan source program where exception originated. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rethrow__located_8hpp_source.html#l00087">87</a> of file <a class="el" href="rethrow__located_8hpp_source.html">rethrow_located.hpp</a>.</p>

</div>
</div>
<a id="a04c62e86ae5453b817e25b2bec9e6be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c62e86ae5453b817e25b2bec9e6be5">&#9670;&nbsp;</a></span>returns_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::lang::returns_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1expr__type.html">expr_type</a> &amp;&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1statement.html">statement</a> &amp;&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>error_msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified statement is a return statement returning an expression of the specified type, otherwise return false and write an error message to the specified error stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">return_type</td><td>expected type of returned expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statement</td><td>statement to test </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">error_msgs</td><td>stream to which error messages are written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified statement is a return statement with a return expression of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="returns__type__def_8hpp_source.html#l00014">14</a> of file <a class="el" href="returns__type__def_8hpp_source.html">returns_type_def.hpp</a>.</p>

</div>
</div>
<a id="a3046d88d7cb39daff937b50ab8cb03c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3046d88d7cb39daff937b50ab8cb03c5">&#9670;&nbsp;</a></span>set_fun_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::set_fun_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstan_1_1lang_1_1fun.html">fun</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>error_msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00128">128</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aba82cc67a33a3ae5a7c6b4be7a72317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba82cc67a33a3ae5a7c6b4be7a72317d">&#9670;&nbsp;</a></span>strip_ccdf_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::strip_ccdf_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of removing the suffix from the specified function name indicating it is a CCDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_fun</td><td>name of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of removing suffix from function </dd></dl>

<p class="definition">Definition at line <a class="el" href="strip__ccdf__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="strip__ccdf__suffix__def_8hpp_source.html">strip_ccdf_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="ab0a048ae36d5e5777cdc41e97e21728e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a048ae36d5e5777cdc41e97e21728e">&#9670;&nbsp;</a></span>strip_cdf_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::strip_cdf_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of removing the suffix from the specified function name indicating it is a CDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_fun</td><td>name of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of removing suffix from function </dd></dl>

<p class="definition">Definition at line <a class="el" href="strip__cdf__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="strip__cdf__suffix__def_8hpp_source.html">strip_cdf_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a0748131852a7c29bb713fad843fdd209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748131852a7c29bb713fad843fdd209">&#9670;&nbsp;</a></span>strip_prob_fun_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::strip_prob_fun_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dist_fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of stripping the suffix indicating it is a probability function from the specified function name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_fun</td><td>name of probability function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the probability function with the suffix stripped off </dd></dl>

<p class="definition">Definition at line <a class="el" href="strip__prob__fun__suffix__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="strip__prob__fun__suffix__def_8hpp_source.html">strip_prob_fun_suffix_def.hpp</a>.</p>

</div>
</div>
<a id="a95a4a3a6a1a8f85822c65940bb01801c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a4a3a6a1a8f85822c65940bb01801c">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::lang::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string resulting from streaming the specified argument to a default <code>std::stringstream</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of primitive or class to convert to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value to convert to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string resulting from streaming the value </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__string_8hpp_source.html#l00019">19</a> of file <a class="el" href="to__string_8hpp_source.html">to_string.hpp</a>.</p>

</div>
</div>
<a id="add818c85ac1c2c2d11dd9d25c26ed7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add818c85ac1c2c2d11dd9d25c26ed7aa">&#9670;&nbsp;</a></span>total_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::lang::total_dims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structstan_1_1lang_1_1expression.html">expression</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of dimensions when the specified vectors of expressions are concatenated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimss</td><td>vector of vector of dimension expressions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="total__dims__def_8hpp_source.html#l00010">10</a> of file <a class="el" href="total__dims__def_8hpp_source.html">total_dims_def.hpp</a>.</p>

</div>
</div>
<a id="af4ec1b4d734a768e0ddce6d117498086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ec1b4d734a768e0ddce6d117498086">&#9670;&nbsp;</a></span>validate_integrate_ode_non_control_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::lang::validate_integrate_ode_non_control_args </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ode_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1lang_1_1variable__map.html">variable_map</a> &amp;&#160;</td>
          <td class="paramname"><em>var_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>error_msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01370">1370</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a0ff27aba1e70ef30121a6abc7901a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff27aba1e70ef30121a6abc7901a23a">&#9670;&nbsp;</a></span>write_base_expr_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; stan::lang::write_base_expr_type </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacestan_1_1lang.html#a68e0a56b53eff799154af42b5f6e79d2">base_expr_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a user-readable version of the specified base expression type to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramname">type</td><td>base expression type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="write__base__expr__type__def_8hpp_source.html#l00009">9</a> of file <a class="el" href="write__base__expr__type__def_8hpp_source.html">write_base_expr_type_def.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6ef45be44c4e6b944a4a7fa209806da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef45be44c4e6b944a4a7fa209806da9">&#9670;&nbsp;</a></span>add_conditional_body_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__conditional__body.html">add_conditional_body</a> &gt; stan::lang::add_conditional_body_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00757">757</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aa887a72ee764faf7b02b9a19cfb7415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa887a72ee764faf7b02b9a19cfb7415a">&#9670;&nbsp;</a></span>add_conditional_condition_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__conditional__condition.html">add_conditional_condition</a> &gt; stan::lang::add_conditional_condition_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00751">751</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a18a1f248f0360b34de079b0b227990b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a1f248f0360b34de079b0b227990b2">&#9670;&nbsp;</a></span>add_expression_dimss_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__expression__dimss.html">add_expression_dimss</a> &gt; stan::lang::add_expression_dimss_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02022">2022</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a205b253cdba26aa1abc973fefa71ab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205b253cdba26aa1abc973fefa71ab76">&#9670;&nbsp;</a></span>add_fun_var_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__fun__var.html">add_fun_var</a> &gt; stan::lang::add_fun_var_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00598">598</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac38e2868b4e8d8bd5932c265e1240360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38e2868b4e8d8bd5932c265e1240360">&#9670;&nbsp;</a></span>add_function_signature_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__function__signature.html">add_function_signature</a> &gt; stan::lang::add_function_signature_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00507">507</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a72baabb2672a243ac50dbf1f2030b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72baabb2672a243ac50dbf1f2030b563">&#9670;&nbsp;</a></span>add_idxs_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__idxs.html">add_idxs</a> &gt; stan::lang::add_idxs_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01993">1993</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a0096b22606e504822f8f0b8773b8aa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096b22606e504822f8f0b8773b8aa3e">&#9670;&nbsp;</a></span>add_line_number_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__line__number.html">add_line_number</a> &gt; stan::lang::add_line_number_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01346">1346</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a8ad5ad9629a5592fae8976ee79caaf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad5ad9629a5592fae8976ee79caaf92">&#9670;&nbsp;</a></span>add_loop_identifier_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__loop__identifier.html">add_loop_identifier</a> &gt; stan::lang::add_loop_identifier_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01281">1281</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aa1d68283cf8598be450993ff7d116a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d68283cf8598be450993ff7d116a11">&#9670;&nbsp;</a></span>add_params_var_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__params__var.html">add_params_var</a> &gt; stan::lang::add_params_var_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00664">664</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a90f052a77427e0ab381643084bbab6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f052a77427e0ab381643084bbab6da">&#9670;&nbsp;</a></span>add_var_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__var.html">add_var</a> &gt; stan::lang::add_var_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02658">2658</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a113b28c041b2d695d365846978a38a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113b28c041b2d695d365846978a38a9b">&#9670;&nbsp;</a></span>add_while_body_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__while__body.html">add_while_body</a> &gt; stan::lang::add_while_body_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01265">1265</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="adfef57b170334b47c3c3323a1efa6c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfef57b170334b47c3c3323a1efa6c8a">&#9670;&nbsp;</a></span>add_while_condition_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1add__while__condition.html">add_while_condition</a> &gt; stan::lang::add_while_condition_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01259">1259</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a8c6330e5eb1772572f21d1deaabcb75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6330e5eb1772572f21d1deaabcb75f">&#9670;&nbsp;</a></span>addition3_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1addition__expr3.html">addition_expr3</a> &gt; stan::lang::addition3_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00205">205</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a092cb2640be87937380477f8bc4502be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092cb2640be87937380477f8bc4502be">&#9670;&nbsp;</a></span>assign_lhs_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1assign__lhs.html">assign_lhs</a> &gt; stan::lang::assign_lhs_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00147">147</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a318f822a45db85a7a2b530f3c532e35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f822a45db85a7a2b530f3c532e35b">&#9670;&nbsp;</a></span>binary_op_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1binary__op__expr.html">binary_op_expr</a> &gt; stan::lang::binary_op_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00305">305</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a479900846afd139ed5fd5e8941641e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479900846afd139ed5fd5e8941641e0e">&#9670;&nbsp;</a></span>copy_square_cholesky_dimension_if_necessary_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1copy__square__cholesky__dimension__if__necessary.html">copy_square_cholesky_dimension_if_necessary</a> &gt; stan::lang::copy_square_cholesky_dimension_if_necessary_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02545">2545</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac786a03a29d55c493357af5ecbca3b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac786a03a29d55c493357af5ecbca3b10">&#9670;&nbsp;</a></span>data_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::data_origin = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The origin of the variable is the data block. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00021">21</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="ab70036a4078612af7ba5b229da7bdb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70036a4078612af7ba5b229da7bdb60">&#9670;&nbsp;</a></span>deprecate_increment_log_prob_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecate__increment__log__prob.html">deprecate_increment_log_prob</a> &gt; stan::lang::deprecate_increment_log_prob_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01312">1312</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a95bb1c827e026f924e1d041ec9e0bbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bb1c827e026f924e1d041ec9e0bbc7">&#9670;&nbsp;</a></span>deprecate_old_assignment_op_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecate__old__assignment__op.html">deprecate_old_assignment_op</a> &gt; stan::lang::deprecate_old_assignment_op_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00767">767</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a19064c96cb0d5c1a61cc21e0e6cd2cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19064c96cb0d5c1a61cc21e0e6cd2cf9">&#9670;&nbsp;</a></span>deprecated_integrate_ode_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1deprecated__integrate__ode.html">deprecated_integrate_ode</a> &gt; stan::lang::deprecated_integrate_ode_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01367">1367</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a91eadba622a7e472de3ff6a882edd615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91eadba622a7e472de3ff6a882edd615">&#9670;&nbsp;</a></span>derived_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::derived_origin = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The origin of the variable is generated quantities. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00041">41</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a681a51434f84a41a8f9a28b8c0ce407b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681a51434f84a41a8f9a28b8c0ce407b">&#9670;&nbsp;</a></span>division_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1division__expr.html">division_expr</a> &gt; stan::lang::division_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01856">1856</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ae0e14b560c2617f85fbbe54139df5a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e14b560c2617f85fbbe54139df5a3d">&#9670;&nbsp;</a></span>DOUBLE_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::DOUBLE_T = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real scalar type. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00027">27</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="a1c66d9e820714cdc709fdae189ee7587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c66d9e820714cdc709fdae189ee7587">&#9670;&nbsp;</a></span>elt_division_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1elt__division__expr.html">elt_division_expr</a> &gt; stan::lang::elt_division_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01934">1934</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="add4102ac311ae6ef9d63c63ae8f2afe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4102ac311ae6ef9d63c63ae8f2afe7">&#9670;&nbsp;</a></span>elt_multiplication_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1elt__multiplication__expr.html">elt_multiplication_expr</a> &gt; stan::lang::elt_multiplication_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01917">1917</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="afc573429b8e343036eaf2749dde1a985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc573429b8e343036eaf2749dde1a985">&#9670;&nbsp;</a></span>empty_range_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1empty__range.html">empty_range</a> &gt; stan::lang::empty_range_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02551">2551</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a8d14ea43635049df71e5c88b07fb61ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14ea43635049df71e5c88b07fb61ca">&#9670;&nbsp;</a></span>exponentiation_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1exponentiation__expr.html">exponentiation_expr</a> &gt; stan::lang::exponentiation_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01790">1790</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="adc0a0e2f8b766b9808b70cd3a4ee7fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0a0e2f8b766b9808b70cd3a4ee7fc6">&#9670;&nbsp;</a></span>expression_as_statement_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1expression__as__statement.html">expression_as_statement</a> &gt; stan::lang::expression_as_statement_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01238">1238</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a5ebf67def8ef0f503f15d35fc7048ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf67def8ef0f503f15d35fc7048ef9">&#9670;&nbsp;</a></span>function_argument_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::function_argument_origin = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as a function argument to a non-void function that does not end in _lp or _rng. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00047">47</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a85bba07d76f7bf223e67aae4b9e28fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bba07d76f7bf223e67aae4b9e28fd8">&#9670;&nbsp;</a></span>function_argument_origin_lp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::function_argument_origin_lp = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as an argument to a non-void function with the _lp suffix. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00053">53</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a3a6f3011d4676d30cbc264fee2cc1cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6f3011d4676d30cbc264fee2cc1cc2">&#9670;&nbsp;</a></span>function_argument_origin_rng</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::function_argument_origin_rng = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as an argument to a non-void function with the _rng suffix. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00059">59</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a1a80cac3a51a41052542a8475977c066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a80cac3a51a41052542a8475977c066">&#9670;&nbsp;</a></span>ILL_FORMED_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::ILL_FORMED_T = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type denoting an ill-formed expression. </p>
<p>Used as a return for functions. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00048">48</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="a1d8f01052bb3786de5fe0926d8e9cfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8f01052bb3786de5fe0926d8e9cfcc">&#9670;&nbsp;</a></span>increment_size_t_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1increment__size__t.html">increment_size_t</a> &gt; stan::lang::increment_size_t_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00227">227</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ad3634fd0eaf803aa6c8242293d7ea844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3634fd0eaf803aa6c8242293d7ea844">&#9670;&nbsp;</a></span>infer_array_expr_type_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1infer__array__expr__type.html">infer_array_expr_type</a> &gt; stan::lang::infer_array_expr_type_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01708">1708</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac9969faf112e7a023977ad8bd94efeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9969faf112e7a023977ad8bd94efeff">&#9670;&nbsp;</a></span>infer_vec_or_matrix_expr_type_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1infer__vec__or__matrix__expr__type.html">infer_vec_or_matrix_expr_type</a> &gt; stan::lang::infer_vec_or_matrix_expr_type_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01763">1763</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac00b6c726776401eae900f6c6dd60dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00b6c726776401eae900f6c6dd60dab">&#9670;&nbsp;</a></span>INT_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::INT_T = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer type. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00022">22</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="ac5be25f1771bd1501888b206ab06404f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5be25f1771bd1501888b206ab06404f">&#9670;&nbsp;</a></span>is_prob_fun_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1is__prob__fun.html">is_prob_fun</a> &gt; stan::lang::is_prob_fun_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00189">189</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a85c36ec7374e414afb6aa22c566e82e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c36ec7374e414afb6aa22c566e82e7">&#9670;&nbsp;</a></span>left_division_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1left__division__expr.html">left_division_expr</a> &gt; stan::lang::left_division_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01900">1900</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a3c15073b0f14ae44d221d76f73148155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c15073b0f14ae44d221d76f73148155">&#9670;&nbsp;</a></span>logical_negate_expr_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1logical__negate__expr.html">logical_negate_expr</a> &gt; stan::lang::logical_negate_expr_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01965">1965</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac213c08e33cb349a160b248e291ed3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac213c08e33cb349a160b248e291ed3ae">&#9670;&nbsp;</a></span>MATRIX_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::MATRIX_T = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type; scalar type is real. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00042">42</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="a71cb4481262c785e442001be02576d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cb4481262c785e442001be02576d3a">&#9670;&nbsp;</a></span>model_name_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::model_name_origin = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Origin of variable is the name of the model. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00016">16</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="aea16d18d77239e5e3c094dc75ece04bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea16d18d77239e5e3c094dc75ece04bb">&#9670;&nbsp;</a></span>modulus_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1modulus__expr.html">modulus_expr</a> &gt; stan::lang::modulus_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01878">1878</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aaa7f42deee9c1172f1d9911715f47202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7f42deee9c1172f1d9911715f47202">&#9670;&nbsp;</a></span>multiplication_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1multiplication__expr.html">multiplication_expr</a> &gt; stan::lang::multiplication_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01807">1807</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aadfb67c8b21205ec3389a5bcd06aef2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfb67c8b21205ec3389a5bcd06aef2b">&#9670;&nbsp;</a></span>negate_expr_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1negate__expr.html">negate_expr</a> &gt; stan::lang::negate_expr_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01949">1949</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a3704f701d2d71f4da2d26a0a092bf661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3704f701d2d71f4da2d26a0a092bf661">&#9670;&nbsp;</a></span>non_void_expression_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1non__void__expression.html">non_void_expression</a> &gt; stan::lang::non_void_expression_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02721">2721</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a4bba0b81288df957fc7088fcfd6a21f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bba0b81288df957fc7088fcfd6a21f7">&#9670;&nbsp;</a></span>parameter_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::parameter_origin = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The origin of the variable is the parameter block. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00031">31</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a822df83f09c698b97761142503c7c0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822df83f09c698b97761142503c7c0ee">&#9670;&nbsp;</a></span>program_error_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1program__error.html">program_error</a> &gt; stan::lang::program_error_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00731">731</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ae20023baf9ffb97b5007e25d08136fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20023baf9ffb97b5007e25d08136fb5">&#9670;&nbsp;</a></span>remove_loop_identifier_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1remove__loop__identifier.html">remove_loop_identifier</a> &gt; stan::lang::remove_loop_identifier_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01287">1287</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ab6069db2edc4d4bb6283e9631bdf81a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6069db2edc4d4bb6283e9631bdf81a7">&#9670;&nbsp;</a></span>remove_params_var_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1remove__params__var.html">remove_params_var</a> &gt; stan::lang::remove_params_var_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00669">669</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ad8c972bb350b41a53b8ffdaf328f321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c972bb350b41a53b8ffdaf328f321a">&#9670;&nbsp;</a></span>require_vbar_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1require__vbar.html">require_vbar</a> &gt; stan::lang::require_vbar_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02067">2067</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a62c363c60bc1c580f8a46396386ca22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c363c60bc1c580f8a46396386ca22f">&#9670;&nbsp;</a></span>reset_var_scope_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1reset__var__scope.html">reset_var_scope</a> &gt; stan::lang::reset_var_scope_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02743">2743</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="afa3a8b7a8c4ab9815be757a5ed109869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3a8b7a8c4ab9815be757a5ed109869">&#9670;&nbsp;</a></span>ROW_VECTOR_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::ROW_VECTOR_T = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row vector type; scalar type is real. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00037">37</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="af7aa6fbb9a1e738c3440f4d64c38fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7aa6fbb9a1e738c3440f4d64c38fabf">&#9670;&nbsp;</a></span>set_allows_sampling_origin_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__allows__sampling__origin.html">set_allows_sampling_origin</a> &gt; stan::lang::set_allows_sampling_origin_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00352">352</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ad9fc25e409fa8d66c78ab745dc81358b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fc25e409fa8d66c78ab745dc81358b">&#9670;&nbsp;</a></span>set_double_range_lower_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__double__range__lower.html">set_double_range_lower</a> &gt; stan::lang::set_double_range_lower_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02610">2610</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="af2072724f6b35272d8f926ab82675aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2072724f6b35272d8f926ab82675aa2">&#9670;&nbsp;</a></span>set_double_range_upper_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__double__range__upper.html">set_double_range_upper</a> &gt; stan::lang::set_double_range_upper_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02621">2621</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="af2ef4b50a6aff209870870afc10e7152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ef4b50a6aff209870870afc10e7152">&#9670;&nbsp;</a></span>set_fun_params_scope_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__fun__params__scope.html">set_fun_params_scope</a> &gt; stan::lang::set_fun_params_scope_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00572">572</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a7f710ffe658533b2718168aefab419d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f710ffe658533b2718168aefab419d5">&#9670;&nbsp;</a></span>set_fun_type_named_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__fun__type__named.html">set_fun_type_named</a> &gt; stan::lang::set_fun_type_named_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01659">1659</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ab12551895e6c99a14f548cb42e7b664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12551895e6c99a14f548cb42e7b664b">&#9670;&nbsp;</a></span>set_int_range_lower_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__int__range__lower.html">set_int_range_lower</a> &gt; stan::lang::set_int_range_lower_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02561">2561</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a1b0b30d7cdd3fe9b98d7f592a96a4c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0b30d7cdd3fe9b98d7f592a96a4c58">&#9670;&nbsp;</a></span>set_int_range_upper_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__int__range__upper.html">set_int_range_upper</a> &gt; stan::lang::set_int_range_upper_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02571">2571</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aac3945c1fba849047c2db85b45d5d732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3945c1fba849047c2db85b45d5d732">&#9670;&nbsp;</a></span>set_no_op_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__no__op.html">set_no_op</a> &gt; stan::lang::set_no_op_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01356">1356</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a6862217ec402048e344cd00bbace5a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6862217ec402048e344cd00bbace5a7f">&#9670;&nbsp;</a></span>set_omni_idx_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__omni__idx.html">set_omni_idx</a> &gt; stan::lang::set_omni_idx_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00604">604</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a4f4502cb805b38efd45a3fc6ba121f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4502cb805b38efd45a3fc6ba121f8b">&#9670;&nbsp;</a></span>set_var_scope_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__scope.html">set_var_scope</a> &gt; stan::lang::set_var_scope_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02728">2728</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a1be86553295d8b1db06b4d9e6a9fdd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be86553295d8b1db06b4d9e6a9fdd33">&#9670;&nbsp;</a></span>set_var_scope_local_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__scope__local.html">set_var_scope_local</a> &gt; stan::lang::set_var_scope_local_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02735">2735</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a85d9c0f133baab40945c6cde3945285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9c0f133baab40945c6cde3945285f">&#9670;&nbsp;</a></span>set_var_type_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__var__type.html">set_var_type</a> &gt; stan::lang::set_var_type_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02058">2058</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aeb9220ac98f9466d939c27fef1ca47b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9220ac98f9466d939c27fef1ca47b2">&#9670;&nbsp;</a></span>set_void_function_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__void__function.html">set_void_function</a> &gt; stan::lang::set_void_function_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00333">333</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a24be8b1afb1b474b54f8c382973d8df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be8b1afb1b474b54f8c382973d8df3">&#9670;&nbsp;</a></span>set_void_return_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1set__void__return.html">set_void_return</a> &gt; stan::lang::set_void_return_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01351">1351</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a7665b6ef58bda5e9641037e203c3e9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7665b6ef58bda5e9641037e203c3e9b8">&#9670;&nbsp;</a></span>subtraction3_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1subtraction__expr3.html">subtraction_expr3</a> &gt; stan::lang::subtraction3_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00222">222</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a1fa09f67196eac19446448aaa2520980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa09f67196eac19446448aaa2520980">&#9670;&nbsp;</a></span>trace_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1trace.html">trace</a> &gt; stan::lang::trace_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02747">2747</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aaf327d8b9e76bf1eb0781a8c808aa5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf327d8b9e76bf1eb0781a8c808aa5f3">&#9670;&nbsp;</a></span>transformed_data_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::transformed_data_origin = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The origin of the variable is the transformed data block. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00026">26</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a8cdb7bcf9b67e2213196b02eb0d11af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdb7bcf9b67e2213196b02eb0d11af5">&#9670;&nbsp;</a></span>transformed_parameter_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::transformed_parameter_origin = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The origin of the variable is the transformed parameter block. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00036">36</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="aec1ae7da2c1c71f10f5254fc4f15f929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1ae7da2c1c71f10f5254fc4f15f929">&#9670;&nbsp;</a></span>transpose_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1transpose__expr.html">transpose_expr</a> &gt; stan::lang::transpose_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01978">1978</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="adcfc55167da5686aa43fc31649e98468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc55167da5686aa43fc31649e98468">&#9670;&nbsp;</a></span>unscope_locals_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1unscope__locals.html">unscope_locals</a> &gt; stan::lang::unscope_locals_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01245">1245</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aaf05375acf268ff006abc8422f3cc8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf05375acf268ff006abc8422f3cc8bb">&#9670;&nbsp;</a></span>unscope_variables_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1unscope__variables.html">unscope_variables</a> &gt; stan::lang::unscope_variables_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00580">580</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a0510f05000ee933eecb99ce2eaa62c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0510f05000ee933eecb99ce2eaa62c5e">&#9670;&nbsp;</a></span>validate_allow_sample_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__allow__sample.html">validate_allow_sample</a> &gt; stan::lang::validate_allow_sample_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01325">1325</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ae9e5ff6477ea53b1a2278f6d7421429e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e5ff6477ea53b1a2278f6d7421429e">&#9670;&nbsp;</a></span>validate_assgn_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__assgn.html">validate_assgn</a> &gt; stan::lang::validate_assgn_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00881">881</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a3f10724e3adb4a1eaad4291b6b6b6a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f10724e3adb4a1eaad4291b6b6b6a6d">&#9670;&nbsp;</a></span>validate_assignment_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__assignment.html">validate_assignment</a> &gt; stan::lang::validate_assignment_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00973">973</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a2bb8c5e33d9977c96f8de6d537feb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb8c5e33d9977c96f8de6d537feb374">&#9670;&nbsp;</a></span>validate_conditional_op_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__conditional__op.html">validate_conditional_op</a> &gt; stan::lang::validate_conditional_op_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00282">282</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="af5ebca80cc3f2cda24e75e7d8086c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ebca80cc3f2cda24e75e7d8086c717">&#9670;&nbsp;</a></span>validate_decl_constraints_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__decl__constraints.html">validate_decl_constraints</a> &gt; stan::lang::validate_decl_constraints_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02278">2278</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a187c3e9a528d25fa426c6b2c5c106882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c3e9a528d25fa426c6b2c5c106882">&#9670;&nbsp;</a></span>validate_declarations_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__declarations.html">validate_declarations</a> &gt; stan::lang::validate_declarations_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00378">378</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ac651a6d28d82e2afa0b37a731229c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac651a6d28d82e2afa0b37a731229c495">&#9670;&nbsp;</a></span>validate_definition_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__definition.html">validate_definition</a> &gt; stan::lang::validate_definition_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02326">2326</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a41398df14999df6529df448a61263d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41398df14999df6529df448a61263d48">&#9670;&nbsp;</a></span>validate_double_expr_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__double__expr.html">validate_double_expr</a> &gt; stan::lang::validate_double_expr_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00126">126</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aa6a0d7b66a80f971af0f9d3428a28937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a0d7b66a80f971af0f9d3428a28937">&#9670;&nbsp;</a></span>validate_expr_type3_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__expr__type3.html">validate_expr_type3</a> &gt; stan::lang::validate_expr_type3_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00183">183</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a6e90231eaf5c1f9750c90e88a09dff91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e90231eaf5c1f9750c90e88a09dff91">&#9670;&nbsp;</a></span>validate_identifier_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__identifier.html">validate_identifier</a> &gt; stan::lang::validate_identifier_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02536">2536</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="ae92d5b4efbca7a0bc51eab1784a3359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92d5b4efbca7a0bc51eab1784a3359f">&#9670;&nbsp;</a></span>validate_in_loop_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__in__loop.html">validate_in_loop</a> &gt; stan::lang::validate_in_loop_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02710">2710</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a807b1b32623789e2bedc4a6941a56d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807b1b32623789e2bedc4a6941a56d91">&#9670;&nbsp;</a></span>validate_int_data_expr_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__data__expr.html">validate_int_data_expr</a> &gt; stan::lang::validate_int_data_expr_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l02599">2599</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a273e836f53ba4e0280a4e9a5bc1a3f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273e836f53ba4e0280a4e9a5bc1a3f56">&#9670;&nbsp;</a></span>validate_int_expr_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expr.html">validate_int_expr</a> &gt; stan::lang::validate_int_expr_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01301">1301</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a8ead8684da9881c21e69230281c376f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ead8684da9881c21e69230281c376f0">&#9670;&nbsp;</a></span>validate_int_expr_silent_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expr__silent.html">validate_int_expr_silent</a> &gt; stan::lang::validate_int_expr_silent_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00611">611</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a07a71795d7dbf64e63de484ce77e93be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a71795d7dbf64e63de484ce77e93be">&#9670;&nbsp;</a></span>validate_int_expression_warn_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__int__expression__warn.html">validate_int_expression_warn</a> &gt; stan::lang::validate_int_expression_warn_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00626">626</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="acc5e85866bb6db6eaebb8d07af8dbd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5e85866bb6db6eaebb8d07af8dbd13">&#9670;&nbsp;</a></span>validate_integrate_ode_control_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__integrate__ode__control.html">validate_integrate_ode_control</a> &gt; stan::lang::validate_integrate_ode_control_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01537">1537</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a4833d6cd0ab6cad306ca6d76d711d343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4833d6cd0ab6cad306ca6d76d711d343">&#9670;&nbsp;</a></span>validate_integrate_ode_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__integrate__ode.html">validate_integrate_ode</a> &gt; stan::lang::validate_integrate_ode_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01477">1477</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="acb7dfe3a600cc67284fe3c37a9040bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7dfe3a600cc67284fe3c37a9040bc8">&#9670;&nbsp;</a></span>validate_ints_expression_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__ints__expression.html">validate_ints_expression</a> &gt; stan::lang::validate_ints_expression_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00656">656</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a06879f3f1ecd5812dd477955b5cd0051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06879f3f1ecd5812dd477955b5cd0051">&#9670;&nbsp;</a></span>validate_lhs_var_assgn_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__lhs__var__assgn.html">validate_lhs_var_assgn</a> &gt; stan::lang::validate_lhs_var_assgn_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00822">822</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a78701a79b0b34a22201b086137de5f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78701a79b0b34a22201b086137de5f4c">&#9670;&nbsp;</a></span>validate_non_void_arg_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__non__void__arg__function.html">validate_non_void_arg_function</a> &gt; stan::lang::validate_non_void_arg_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00317">317</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a19c5bedfc8ee2287070770e1fb209e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c5bedfc8ee2287070770e1fb209e2f">&#9670;&nbsp;</a></span>validate_non_void_expression_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__non__void__expression.html">validate_non_void_expression</a> &gt; stan::lang::validate_non_void_expression_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01337">1337</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aba4620ce8dfc5b63868ec172c4f11ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4620ce8dfc5b63868ec172c4f11ac2">&#9670;&nbsp;</a></span>validate_pmf_pdf_variate_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__pmf__pdf__variate.html">validate_pmf_pdf_variate</a> &gt; stan::lang::validate_pmf_pdf_variate_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00539">539</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aebceb67c6597d9918b888b50fea9fd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebceb67c6597d9918b888b50fea9fd44">&#9670;&nbsp;</a></span>validate_prob_fun_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__prob__fun.html">validate_prob_fun</a> &gt; stan::lang::validate_prob_fun_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00433">433</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="aa1e7d836a48376f1e40360215748fe04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e7d836a48376f1e40360215748fe04">&#9670;&nbsp;</a></span>validate_return_allowed_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__return__allowed.html">validate_return_allowed</a> &gt; stan::lang::validate_return_allowed_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00779">779</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a20e8be11f3ca753622ca4cd10aec2c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e8be11f3ca753622ca4cd10aec2c9f">&#9670;&nbsp;</a></span>validate_return_type_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__return__type.html">validate_return_type</a> &gt; stan::lang::validate_return_type_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00564">564</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a577d284c7eeb93563c4c83a17c261c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577d284c7eeb93563c4c83a17c261c48">&#9670;&nbsp;</a></span>validate_sample_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__sample.html">validate_sample</a> &gt; stan::lang::validate_sample_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l01201">1201</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a1fe4fdb7c445c2e5b75c02eee9062fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4fdb7c445c2e5b75c02eee9062fee">&#9670;&nbsp;</a></span>validate_void_return_allowed_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::phoenix::function&lt; <a class="el" href="structstan_1_1lang_1_1validate__void__return__allowed.html">validate_void_return_allowed</a> &gt; stan::lang::validate_void_return_allowed_f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="semantic__actions__def_8cpp_source.html#l00795">795</a> of file <a class="el" href="semantic__actions__def_8cpp_source.html">semantic_actions_def.cpp</a>.</p>

</div>
</div>
<a id="a841b3d1879af4b4b8b3d3b43d77db0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841b3d1879af4b4b8b3d3b43d77db0bd">&#9670;&nbsp;</a></span>VECTOR_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::VECTOR_T = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Column vector type; scalar type is real. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00032">32</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
<a id="a58187b5ad062f7c82e69e1d412a30add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58187b5ad062f7c82e69e1d412a30add">&#9670;&nbsp;</a></span>void_function_argument_origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::void_function_argument_origin = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as an argument to a function returning void that does not have the _lp or _rng suffix. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00065">65</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="abb5dba01e3d62fb23a5a32954cfc0782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5dba01e3d62fb23a5a32954cfc0782">&#9670;&nbsp;</a></span>void_function_argument_origin_lp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::void_function_argument_origin_lp = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as an argument to a function returning void with _lp suffix. </p>
<p>function returning void </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00071">71</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a3257a85740af8a9bd2b42328c42b35d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3257a85740af8a9bd2b42328c42b35d4">&#9670;&nbsp;</a></span>void_function_argument_origin_rng</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::void_function_argument_origin_rng = 11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The variable arose as an argument to a function returning void with an _rng suffix. </p>

<p class="definition">Definition at line <a class="el" href="origin__block_8hpp_source.html#l00077">77</a> of file <a class="el" href="origin__block_8hpp_source.html">origin_block.hpp</a>.</p>

</div>
</div>
<a id="a2678c64adf505d36884a7f125d475bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2678c64adf505d36884a7f125d475bdc">&#9670;&nbsp;</a></span>VOID_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int stan::lang::VOID_T = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Void type. </p>
<p>Used as return type for void functions. </p>

<p class="definition">Definition at line <a class="el" href="base__expr__type_8hpp_source.html#l00017">17</a> of file <a class="el" href="base__expr__type_8hpp_source.html">base_expr_type.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2016,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
