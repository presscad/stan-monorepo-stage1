<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stan: stan::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stan
   &#160;<span id="projectnumber">1.3</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stan::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrices and templated mathematical functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1math_1_1policies"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1policies.html">policies</a></td></tr>
<tr class="memdesc:namespacestan_1_1math_1_1policies"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extending boost functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01stan_1_1agrad_1_1var_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; stan::agrad::var, R, C &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1array__builder.html">array_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for building up arrays in an expression (rather than in statements) using an argumentchaining <a class="el" href="structstan_1_1math_1_1array__builder.html#a085e0190d7a41c4e33bfa9f542b1d62a">add()</a> method and a getter method <a class="el" href="structstan_1_1math_1_1array__builder.html#a725410c59aa282c6b23c52fd252aa1a3">array()</a> to return the result.  <a href="structstan_1_1math_1_1array__builder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">common_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_00_01_eiged8accfa00e73f240c58ad02ac582ba93.html">common_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01double_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; double, R, C &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter.html">promoter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_t_00_01_t_01_4.html">promoter&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_f_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; F &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_f_00_01_r_00_01_c_01_4_00_01_eigen_1_142b48fda94601374e41a81325f3f7b84.html">promoter&lt; Eigen::Matrix&lt; F, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_eigen_1_12d7fadf0560f1f2f3abc5388b7666f9c.html">promoter&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type.html">store_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01double_01_4.html">store_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01int_01_4.html">store_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type.html">pass_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01double_01_4.html">pass_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01int_01_4.html">pass_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view.html">seq_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">seq_view&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_t_01_4_01_4.html">seq_view&lt; T, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01std_1_1vector_3_01_t_01_4_01_4_01_4.html">seq_view&lt; T, std::vector&lt; std::vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01double_00_01std_1_1vector_3_01int_01_4_01_4.html">seq_view&lt; double, std::vector&lt; int &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa29284c242450c2000920599105e4eb0"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;<br class="typebreak"/>
::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa29284c242450c2000920599105e4eb0">size_type</a></td></tr>
<tr class="separator:aa29284c242450c2000920599105e4eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a24821b475ee296830ebac12f70460"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a></td></tr>
<tr class="memdesc:ac1a24821b475ee296830ebac12f70460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for matrix of double values.  <a href="#ac1a24821b475ee296830ebac12f70460"></a><br/></td></tr>
<tr class="separator:ac1a24821b475ee296830ebac12f70460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7ab54df86be3a3d61e58623c210d86"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c7ab54df86be3a3d61e58623c210d86">vector_d</a></td></tr>
<tr class="memdesc:a0c7ab54df86be3a3d61e58623c210d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (column) vector of double values.  <a href="#a0c7ab54df86be3a3d61e58623c210d86"></a><br/></td></tr>
<tr class="separator:a0c7ab54df86be3a3d61e58623c210d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105e584e4ed2d24a5c3a40df4d94697"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac105e584e4ed2d24a5c3a40df4d94697">row_vector_d</a></td></tr>
<tr class="memdesc:ac105e584e4ed2d24a5c3a40df4d94697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (row) vector of double values.  <a href="#ac105e584e4ed2d24a5c3a40df4d94697"></a><br/></td></tr>
<tr class="separator:ac105e584e4ed2d24a5c3a40df4d94697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2ffd66726e0532160e16e6b48d6f428"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa2ffd66726e0532160e16e6b48d6f428">pi</a> ()</td></tr>
<tr class="memdesc:aa2ffd66726e0532160e16e6b48d6f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of pi.  <a href="#aa2ffd66726e0532160e16e6b48d6f428"></a><br/></td></tr>
<tr class="separator:aa2ffd66726e0532160e16e6b48d6f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b650a0131d41167ef4837ecc7d02be5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a> ()</td></tr>
<tr class="memdesc:a3b650a0131d41167ef4837ecc7d02be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base of the natural logarithm.  <a href="#a3b650a0131d41167ef4837ecc7d02be5"></a><br/></td></tr>
<tr class="separator:a3b650a0131d41167ef4837ecc7d02be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1369f60a09e3af4933096de3a54ac28c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1369f60a09e3af4933096de3a54ac28c">sqrt2</a> ()</td></tr>
<tr class="memdesc:a1369f60a09e3af4933096de3a54ac28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of two.  <a href="#a1369f60a09e3af4933096de3a54ac28c"></a><br/></td></tr>
<tr class="separator:a1369f60a09e3af4933096de3a54ac28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4f7c092e2bc9a089885628b86c004"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a21f4f7c092e2bc9a089885628b86c004">log10</a> ()</td></tr>
<tr class="memdesc:a21f4f7c092e2bc9a089885628b86c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of ten.  <a href="#a21f4f7c092e2bc9a089885628b86c004"></a><br/></td></tr>
<tr class="separator:a21f4f7c092e2bc9a089885628b86c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34675a70d3df614d88d33ddbdd49b49a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34675a70d3df614d88d33ddbdd49b49a">positive_infinity</a> ()</td></tr>
<tr class="memdesc:a34675a70d3df614d88d33ddbdd49b49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity.  <a href="#a34675a70d3df614d88d33ddbdd49b49a"></a><br/></td></tr>
<tr class="separator:a34675a70d3df614d88d33ddbdd49b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34bffe91b7a24cb29bd69cb60814c39e">negative_infinity</a> ()</td></tr>
<tr class="memdesc:a34bffe91b7a24cb29bd69cb60814c39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return negative infinity.  <a href="#a34bffe91b7a24cb29bd69cb60814c39e"></a><br/></td></tr>
<tr class="separator:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381493bccc58bd993d797a2a5458c486"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a381493bccc58bd993d797a2a5458c486">not_a_number</a> ()</td></tr>
<tr class="memdesc:a381493bccc58bd993d797a2a5458c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (quiet) not-a-number.  <a href="#a381493bccc58bd993d797a2a5458c486"></a><br/></td></tr>
<tr class="separator:a381493bccc58bd993d797a2a5458c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a173839dddd0a8ac8afa710b9e3d5008a">machine_precision</a> ()</td></tr>
<tr class="memdesc:a173839dddd0a8ac8afa710b9e3d5008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between 1.0 and the next value representable.  <a href="#a173839dddd0a8ac8afa710b9e3d5008a"></a><br/></td></tr>
<tr class="separator:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244fb67601cb568b79137450f934047b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , typename T_result &gt; </td></tr>
<tr class="memitem:a244fb67601cb568b79137450f934047b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a244fb67601cb568b79137450f934047b">check_bounded</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high, const char *name, T_result *result)</td></tr>
<tr class="separator:a244fb67601cb568b79137450f934047b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e00f0db84045333d946bb2a49b924ac"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a1e00f0db84045333d946bb2a49b924ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1e00f0db84045333d946bb2a49b924ac">check_bounded</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high, const char *name)</td></tr>
<tr class="separator:a1e00f0db84045333d946bb2a49b924ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8987da44a92a90edb79fd84fd39e39d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T_result &gt; </td></tr>
<tr class="memitem:a8987da44a92a90edb79fd84fd39e39d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8987da44a92a90edb79fd84fd39e39d3">check_consistent_size</a> (size_t <a class="el" href="namespacestan.html#a8b2c79a3a686dcf90566be8492e1065d">max_size</a>, const char *function, const T &amp;x, const char *name, T_result *result)</td></tr>
<tr class="separator:a8987da44a92a90edb79fd84fd39e39d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0ad1687b604c6f0667a12922a2545"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T_result &gt; </td></tr>
<tr class="memitem:ac0e0ad1687b604c6f0667a12922a2545"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0e0ad1687b604c6f0667a12922a2545">check_consistent_sizes</a> (const char *function, const T1 &amp;x1, const T2 &amp;x2, const char *name1, const char *name2, T_result *result)</td></tr>
<tr class="separator:ac0e0ad1687b604c6f0667a12922a2545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4c9f7aec5e75731b7e3d0c33a758b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T_result &gt; </td></tr>
<tr class="memitem:a0a4c9f7aec5e75731b7e3d0c33a758b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a4c9f7aec5e75731b7e3d0c33a758b6">check_consistent_sizes</a> (const char *function, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3, const char *name1, const char *name2, const char *name3, T_result *result)</td></tr>
<tr class="separator:a0a4c9f7aec5e75731b7e3d0c33a758b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244db32f5cb1447091b8f7965fe09d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T_result &gt; </td></tr>
<tr class="memitem:a1244db32f5cb1447091b8f7965fe09d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1244db32f5cb1447091b8f7965fe09d6">check_consistent_sizes</a> (const char *function, const T1 &amp;x1, const T2 &amp;x2, const T3 &amp;x3, const T4 &amp;x4, const char *name1, const char *name2, const char *name3, const char *name4, T_result *result)</td></tr>
<tr class="separator:a1244db32f5cb1447091b8f7965fe09d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6feab878b8ff447121df2e6a9461680"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:af6feab878b8ff447121df2e6a9461680"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6feab878b8ff447121df2e6a9461680">check_finite</a> (const char *function, const T_y &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:af6feab878b8ff447121df2e6a9461680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variable y is finite.  <a href="#af6feab878b8ff447121df2e6a9461680"></a><br/></td></tr>
<tr class="separator:af6feab878b8ff447121df2e6a9461680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c87d5d26732e2860ae58d00f4fdff2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46c87d5d26732e2860ae58d00f4fdff2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a46c87d5d26732e2860ae58d00f4fdff2">check_finite</a> (const char *function, const T &amp;y, const char *name)</td></tr>
<tr class="separator:a46c87d5d26732e2860ae58d00f4fdff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada3014caf18d49104f7d63d0d6ea15e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_result &gt; </td></tr>
<tr class="memitem:aada3014caf18d49104f7d63d0d6ea15e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aada3014caf18d49104f7d63d0d6ea15e">check_greater</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const char *name, T_result *result)</td></tr>
<tr class="separator:aada3014caf18d49104f7d63d0d6ea15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1c4b2de4ed60a01fe919a0b3655fd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:aaaf1c4b2de4ed60a01fe919a0b3655fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaaf1c4b2de4ed60a01fe919a0b3655fd">check_greater</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const char *name)</td></tr>
<tr class="separator:aaaf1c4b2de4ed60a01fe919a0b3655fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb58d3f6d9657f8488bc74a6db0a056"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_result &gt; </td></tr>
<tr class="memitem:adbb58d3f6d9657f8488bc74a6db0a056"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adbb58d3f6d9657f8488bc74a6db0a056">check_greater_or_equal</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const char *name, T_result *result)</td></tr>
<tr class="separator:adbb58d3f6d9657f8488bc74a6db0a056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe66408d89f69a9d59b13d7c3d73423b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:abe66408d89f69a9d59b13d7c3d73423b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abe66408d89f69a9d59b13d7c3d73423b">check_greater_or_equal</a> (const char *function, const T_y &amp;y, const T_low &amp;low, const char *name)</td></tr>
<tr class="separator:abe66408d89f69a9d59b13d7c3d73423b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7187754b7dfb0727664c3bed40ccf7b4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , typename T_result &gt; </td></tr>
<tr class="memitem:a7187754b7dfb0727664c3bed40ccf7b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7187754b7dfb0727664c3bed40ccf7b4">check_less</a> (const char *function, const T_y &amp;y, const T_high &amp;high, const char *name, T_result *result)</td></tr>
<tr class="separator:a7187754b7dfb0727664c3bed40ccf7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359cf57677ad750cbe12441ba34df391"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:a359cf57677ad750cbe12441ba34df391"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a359cf57677ad750cbe12441ba34df391">check_less</a> (const char *function, const T_y &amp;y, const T_high &amp;high, const char *name)</td></tr>
<tr class="separator:a359cf57677ad750cbe12441ba34df391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a1e6a543017c50d64bcdd9d53bd83"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , typename T_result &gt; </td></tr>
<tr class="memitem:a1c5a1e6a543017c50d64bcdd9d53bd83"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1c5a1e6a543017c50d64bcdd9d53bd83">check_less_or_equal</a> (const char *function, const T_y &amp;y, const T_high &amp;high, const char *name, T_result *result)</td></tr>
<tr class="separator:a1c5a1e6a543017c50d64bcdd9d53bd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaa5ed482610e1a8c0477cdd60e8033"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:adaaa5ed482610e1a8c0477cdd60e8033"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adaaa5ed482610e1a8c0477cdd60e8033">check_less_or_equal</a> (const char *function, const T_y &amp;y, const T_high &amp;high, const char *name)</td></tr>
<tr class="separator:adaaa5ed482610e1a8c0477cdd60e8033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e2e1e4423183dabe9e5cdad6bee6c2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a68e2e1e4423183dabe9e5cdad6bee6c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a68e2e1e4423183dabe9e5cdad6bee6c2">check_nonnegative</a> (const char *function, const T_y &amp;y, const char *name, T_result *result)</td></tr>
<tr class="separator:a68e2e1e4423183dabe9e5cdad6bee6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d0fc72c0c2a6612f355cd48ddffab8"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a88d0fc72c0c2a6612f355cd48ddffab8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88d0fc72c0c2a6612f355cd48ddffab8">check_nonnegative</a> (const char *function, const T_y &amp;y, const char *name)</td></tr>
<tr class="separator:a88d0fc72c0c2a6612f355cd48ddffab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee36bc9bba89bed1d1568d20046cd3da"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:aee36bc9bba89bed1d1568d20046cd3da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aee36bc9bba89bed1d1568d20046cd3da">check_not_nan</a> (const char *function, const T_y &amp;y, const char *name, T_result *result=0)</td></tr>
<tr class="memdesc:aee36bc9bba89bed1d1568d20046cd3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variable y is nan.  <a href="#aee36bc9bba89bed1d1568d20046cd3da"></a><br/></td></tr>
<tr class="separator:aee36bc9bba89bed1d1568d20046cd3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d490dd2ffa3a5775cfd4f5347111505"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d490dd2ffa3a5775cfd4f5347111505"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d490dd2ffa3a5775cfd4f5347111505">check_not_nan</a> (const char *function, const T &amp;y, const char *name)</td></tr>
<tr class="separator:a4d490dd2ffa3a5775cfd4f5347111505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573ec8402d9e6928596057ee179a96a9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a573ec8402d9e6928596057ee179a96a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a573ec8402d9e6928596057ee179a96a9">check_positive</a> (const char *function, const T_y &amp;y, const char *name, T_result *result)</td></tr>
<tr class="separator:a573ec8402d9e6928596057ee179a96a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e0ff96981b93a266298e6c9343395"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac07e0ff96981b93a266298e6c9343395"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac07e0ff96981b93a266298e6c9343395">check_positive</a> (const char *function, const T &amp;x, const char *name)</td></tr>
<tr class="separator:ac07e0ff96981b93a266298e6c9343395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af45491b0f1852295f1c7ec0730294c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result , typename T_msg2 &gt; </td></tr>
<tr class="memitem:a5af45491b0f1852295f1c7ec0730294c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5af45491b0f1852295f1c7ec0730294c">dom_err</a> (const char *function, const T_y &amp;y, const char *name, const char *error_msg, T_msg2 error_msg2, T_result *result)</td></tr>
<tr class="separator:a5af45491b0f1852295f1c7ec0730294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114bd4a8397e21dd60cc596d24022fe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result , typename T_msg2 &gt; </td></tr>
<tr class="memitem:a5114bd4a8397e21dd60cc596d24022fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5114bd4a8397e21dd60cc596d24022fe">dom_err_vec</a> (size_t i, const char *function, const T_y &amp;y, const char *name, const char *error_msg, T_msg2 error_msg2, T_result *result)</td></tr>
<tr class="separator:a5114bd4a8397e21dd60cc596d24022fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea62b7ae38dc4b6a84bfe90f72b1fc9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a6ea62b7ae38dc4b6a84bfe90f72b1fc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6ea62b7ae38dc4b6a84bfe90f72b1fc9">check_cholesky_factor</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a6ea62b7ae38dc4b6a84bfe90f72b1fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor.  <a href="#a6ea62b7ae38dc4b6a84bfe90f72b1fc9"></a><br/></td></tr>
<tr class="separator:a6ea62b7ae38dc4b6a84bfe90f72b1fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78172933a2bd63bdd511f062564a505"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab78172933a2bd63bdd511f062564a505"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab78172933a2bd63bdd511f062564a505">check_cholesky_factor</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:ab78172933a2bd63bdd511f062564a505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e498bfd9699c99b57b207e2869023a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a63e498bfd9699c99b57b207e2869023a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63e498bfd9699c99b57b207e2869023a">check_cholesky_factor</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, T_result *result)</td></tr>
<tr class="memdesc:a63e498bfd9699c99b57b207e2869023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor (lower triangular, positive diagonal).  <a href="#a63e498bfd9699c99b57b207e2869023a"></a><br/></td></tr>
<tr class="separator:a63e498bfd9699c99b57b207e2869023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bba6a9591ff4834950d8819d17ec105"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1bba6a9591ff4834950d8819d17ec105"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1bba6a9591ff4834950d8819d17ec105">check_cholesky_factor</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, T *result=0)</td></tr>
<tr class="separator:a1bba6a9591ff4834950d8819d17ec105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19892bf98f113034430413117fddd012"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a19892bf98f113034430413117fddd012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a19892bf98f113034430413117fddd012">check_corr_matrix</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a19892bf98f113034430413117fddd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid correlation matrix.  <a href="#a19892bf98f113034430413117fddd012"></a><br/></td></tr>
<tr class="separator:a19892bf98f113034430413117fddd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32dc573d6046854e39913596554961b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad32dc573d6046854e39913596554961b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad32dc573d6046854e39913596554961b">check_corr_matrix</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:ad32dc573d6046854e39913596554961b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90326b7bfecdcd28d2555c001ca7cf0f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a90326b7bfecdcd28d2555c001ca7cf0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a90326b7bfecdcd28d2555c001ca7cf0f">check_cov_matrix</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a90326b7bfecdcd28d2555c001ca7cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid covariance matrix.  <a href="#a90326b7bfecdcd28d2555c001ca7cf0f"></a><br/></td></tr>
<tr class="separator:a90326b7bfecdcd28d2555c001ca7cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9d505abaaf8ae26ad366f51d71fbd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf9d505abaaf8ae26ad366f51d71fbd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adf9d505abaaf8ae26ad366f51d71fbd8">check_cov_matrix</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:adf9d505abaaf8ae26ad366f51d71fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea06d3b49639cdd7f4eee1a9e21d01a0"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_result &gt; </td></tr>
<tr class="memitem:aea06d3b49639cdd7f4eee1a9e21d01a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aea06d3b49639cdd7f4eee1a9e21d01a0">check_cov_matrix</a> (const char *function, const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, T_result *result)</td></tr>
<tr class="memdesc:aea06d3b49639cdd7f4eee1a9e21d01a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid covariance matrix.  <a href="#aea06d3b49639cdd7f4eee1a9e21d01a0"></a><br/></td></tr>
<tr class="separator:aea06d3b49639cdd7f4eee1a9e21d01a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a94eb57a3b80ccdb54d75a38d5aa4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac60a94eb57a3b80ccdb54d75a38d5aa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac60a94eb57a3b80ccdb54d75a38d5aa4">check_cov_matrix</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, T *result=0)</td></tr>
<tr class="separator:ac60a94eb57a3b80ccdb54d75a38d5aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f45f5cee19ad65fdd516e1b855d0fe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a54f45f5cee19ad65fdd516e1b855d0fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a54f45f5cee19ad65fdd516e1b855d0fe">check_lower_triangular</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a54f45f5cee19ad65fdd516e1b855d0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is lower triangular.  <a href="#a54f45f5cee19ad65fdd516e1b855d0fe"></a><br/></td></tr>
<tr class="separator:a54f45f5cee19ad65fdd516e1b855d0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd9fc9fd09527b5b8adf811d3d5b5e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cd9fc9fd09527b5b8adf811d3d5b5e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5cd9fc9fd09527b5b8adf811d3d5b5e5">check_lower_triangular</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a5cd9fc9fd09527b5b8adf811d3d5b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bd442a2e6c56c40d7b60d0079ac8a7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a55bd442a2e6c56c40d7b60d0079ac8a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a55bd442a2e6c56c40d7b60d0079ac8a7">check_ordered</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a55bd442a2e6c56c40d7b60d0079ac8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is sorted into increasing order.  <a href="#a55bd442a2e6c56c40d7b60d0079ac8a7"></a><br/></td></tr>
<tr class="separator:a55bd442a2e6c56c40d7b60d0079ac8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69935f4ef1aad90e6a48c49ba945efc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69935f4ef1aad90e6a48c49ba945efc2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69935f4ef1aad90e6a48c49ba945efc2">check_ordered</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a69935f4ef1aad90e6a48c49ba945efc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543443cb0c96a44613255c83d593a86"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:aa543443cb0c96a44613255c83d593a86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa543443cb0c96a44613255c83d593a86">check_pos_definite</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:aa543443cb0c96a44613255c83d593a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is positive definite.  <a href="#aa543443cb0c96a44613255c83d593a86"></a><br/></td></tr>
<tr class="separator:aa543443cb0c96a44613255c83d593a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f7f1aacfd755763e5b00af14ff9b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa38f7f1aacfd755763e5b00af14ff9b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa38f7f1aacfd755763e5b00af14ff9b6">check_pos_definite</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:aa38f7f1aacfd755763e5b00af14ff9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7341142ee291b13f1ad04152a37f974f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a7341142ee291b13f1ad04152a37f974f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7341142ee291b13f1ad04152a37f974f">check_pos_semidefinite</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a7341142ee291b13f1ad04152a37f974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is positive definite.  <a href="#a7341142ee291b13f1ad04152a37f974f"></a><br/></td></tr>
<tr class="separator:a7341142ee291b13f1ad04152a37f974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a161786def6581011502056d92c021"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9a161786def6581011502056d92c021"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af9a161786def6581011502056d92c021">check_pos_semidefinite</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:af9a161786def6581011502056d92c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953ca730fb62ef45047f2a73c0f84a88"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a953ca730fb62ef45047f2a73c0f84a88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a953ca730fb62ef45047f2a73c0f84a88">check_positive_ordered</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a953ca730fb62ef45047f2a73c0f84a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector contains only non-negative values and is sorted into increasing order.  <a href="#a953ca730fb62ef45047f2a73c0f84a88"></a><br/></td></tr>
<tr class="separator:a953ca730fb62ef45047f2a73c0f84a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153b3fac80bd9f9739f87cfccb7eb870"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a153b3fac80bd9f9739f87cfccb7eb870"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a153b3fac80bd9f9739f87cfccb7eb870">check_positive_ordered</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a153b3fac80bd9f9739f87cfccb7eb870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbbf2c5799c876b8b5a40a6be59fad4"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_result &gt; </td></tr>
<tr class="memitem:a4cbbf2c5799c876b8b5a40a6be59fad4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4cbbf2c5799c876b8b5a40a6be59fad4">check_simplex</a> (const char *function, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a4cbbf2c5799c876b8b5a40a6be59fad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is simplex.  <a href="#a4cbbf2c5799c876b8b5a40a6be59fad4"></a><br/></td></tr>
<tr class="separator:a4cbbf2c5799c876b8b5a40a6be59fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5371fc49b7503afbe9a49867fc5d075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5371fc49b7503afbe9a49867fc5d075"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac5371fc49b7503afbe9a49867fc5d075">check_simplex</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;theta, const char *name, T *result=0)</td></tr>
<tr class="separator:ac5371fc49b7503afbe9a49867fc5d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa604267d7189b6fde0be2c83f03f60f8"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 , typename T_result &gt; </td></tr>
<tr class="memitem:aa604267d7189b6fde0be2c83f03f60f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa604267d7189b6fde0be2c83f03f60f8">check_size_match</a> (const char *function, T_size1 i, const char *name_i, T_size2 j, const char *name_j, T_result *result)</td></tr>
<tr class="separator:aa604267d7189b6fde0be2c83f03f60f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db9ba4076101c008a4164d1f4f0881d"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a7db9ba4076101c008a4164d1f4f0881d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7db9ba4076101c008a4164d1f4f0881d">check_size_match</a> (const char *function, T_size1 i, const char *name_i, T_size2 j, const char *name_j, T_size1 *result=0)</td></tr>
<tr class="separator:a7db9ba4076101c008a4164d1f4f0881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f953f345a5fc4d4258d65c9fd494d0d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a1f953f345a5fc4d4258d65c9fd494d0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f953f345a5fc4d4258d65c9fd494d0d">check_spsd_matrix</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a1f953f345a5fc4d4258d65c9fd494d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite.  <a href="#a1f953f345a5fc4d4258d65c9fd494d0d"></a><br/></td></tr>
<tr class="separator:a1f953f345a5fc4d4258d65c9fd494d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919b0ac7be6e9129159dcd57b5aaa229"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a919b0ac7be6e9129159dcd57b5aaa229"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a919b0ac7be6e9129159dcd57b5aaa229">check_spsd_matrix</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a919b0ac7be6e9129159dcd57b5aaa229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8e58058a05567645f7589f90f5acaf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:aaa8e58058a05567645f7589f90f5acaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaa8e58058a05567645f7589f90f5acaf">check_square</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:aaa8e58058a05567645f7589f90f5acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is square.  <a href="#aaa8e58058a05567645f7589f90f5acaf"></a><br/></td></tr>
<tr class="separator:aaa8e58058a05567645f7589f90f5acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354049e8dec929a4b054b7e8db06a4fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a354049e8dec929a4b054b7e8db06a4fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a354049e8dec929a4b054b7e8db06a4fb">check_square</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a354049e8dec929a4b054b7e8db06a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d97aebea4cf628724dfd08030284bb2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_result &gt; </td></tr>
<tr class="memitem:a7d97aebea4cf628724dfd08030284bb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7d97aebea4cf628724dfd08030284bb2">check_symmetric</a> (const char *function, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T_result *result)</td></tr>
<tr class="memdesc:a7d97aebea4cf628724dfd08030284bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is symmetric.  <a href="#a7d97aebea4cf628724dfd08030284bb2"></a><br/></td></tr>
<tr class="separator:a7d97aebea4cf628724dfd08030284bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aebef4c723a2963977653559ebd2374"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aebef4c723a2963977653559ebd2374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8aebef4c723a2963977653559ebd2374">check_symmetric</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name, T *result=0)</td></tr>
<tr class="separator:a8aebef4c723a2963977653559ebd2374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab722ab154aebf9a162df8e9bd4e3e42f"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_result &gt; </td></tr>
<tr class="memitem:ab722ab154aebf9a162df8e9bd4e3e42f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab722ab154aebf9a162df8e9bd4e3e42f">check_unit_vector</a> (const char *function, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta, const char *name, T_result *result)</td></tr>
<tr class="memdesc:ab722ab154aebf9a162df8e9bd4e3e42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is unit vector.  <a href="#ab722ab154aebf9a162df8e9bd4e3e42f"></a><br/></td></tr>
<tr class="separator:ab722ab154aebf9a162df8e9bd4e3e42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496b0022b662c358931d1ab0458f60e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7496b0022b662c358931d1ab0458f60e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7496b0022b662c358931d1ab0458f60e">check_unit_vector</a> (const char *function, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;theta, const char *name, T *result=0)</td></tr>
<tr class="separator:a7496b0022b662c358931d1ab0458f60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abcd9b7deac4b6378eae04ee927f498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3abcd9b7deac4b6378eae04ee927f498">validate_non_negative_index</a> (const std::string &amp;var_name, const std::string &amp;expr, int val)</td></tr>
<tr class="separator:a3abcd9b7deac4b6378eae04ee927f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4764556637084eee528b45d8eaa767"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeb4764556637084eee528b45d8eaa767">abs</a> (double x)</td></tr>
<tr class="memdesc:aeb4764556637084eee528b45d8eaa767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return floating-point absolute value.  <a href="#aeb4764556637084eee528b45d8eaa767"></a><br/></td></tr>
<tr class="separator:aeb4764556637084eee528b45d8eaa767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad1c484220022b3abfb79c16d1d7f72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ad1c484220022b3abfb79c16d1d7f72"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6ad1c484220022b3abfb79c16d1d7f72">as_bool</a> (const T x)</td></tr>
<tr class="memdesc:a6ad1c484220022b3abfb79c16d1d7f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <a href="#a6ad1c484220022b3abfb79c16d1d7f72"></a><br/></td></tr>
<tr class="separator:a6ad1c484220022b3abfb79c16d1d7f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b5156aa25d21592dbd3624aae1ea39"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a86b5156aa25d21592dbd3624aae1ea39"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86b5156aa25d21592dbd3624aae1ea39">as_bool&lt; int &gt;</a> (const int x)</td></tr>
<tr class="memdesc:a86b5156aa25d21592dbd3624aae1ea39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer with an equivalent boolean value to specified input.  <a href="#a86b5156aa25d21592dbd3624aae1ea39"></a><br/></td></tr>
<tr class="separator:a86b5156aa25d21592dbd3624aae1ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebfb3835848bd8550192cd5e090d3b5a">bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="separator:aebfb3835848bd8550192cd5e090d3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a645ce13c6454913ec39be807751604dc">bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="separator:a645ce13c6454913ec39be807751604dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add2a043f562537b8cc57bb35780ac5b5">binary_log_loss</a> (const int y, const T y_hat)</td></tr>
<tr class="memdesc:add2a043f562537b8cc57bb35780ac5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log loss function for binary classification with specified reference and response values.  <a href="#add2a043f562537b8cc57bb35780ac5b5"></a><br/></td></tr>
<tr class="separator:add2a043f562537b8cc57bb35780ac5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_n &gt; </td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_N, T_n &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27dad23d38c6d5e74c65e7571c70272e">binomial_coefficient_log</a> (const T_N N, const T_n n)</td></tr>
<tr class="memdesc:a27dad23d38c6d5e74c65e7571c70272e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the binomial coefficient for the specified arguments.  <a href="#a27dad23d38c6d5e74c65e7571c70272e"></a><br/></td></tr>
<tr class="separator:a27dad23d38c6d5e74c65e7571c70272e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae86020a972c6efc6b3407c3cfc30f4a6">dist</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b73319bd8df9dad1d3902997d8e89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd3b73319bd8df9dad1d3902997d8e89">dot</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:afd3b73319bd8df9dad1d3902997d8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a4ef7c701db7984297d153580c8d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a6a4ef7c701db7984297d153580c8d4">dot_self</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a8a6a4ef7c701db7984297d153580c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ef734d7c3b8ebd689012295bf826e94">exp2</a> (const T y)</td></tr>
<tr class="memdesc:a0ef734d7c3b8ebd689012295bf826e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponent base 2 of the specified argument (C99).  <a href="#a0ef734d7c3b8ebd689012295bf826e94"></a><br/></td></tr>
<tr class="separator:a0ef734d7c3b8ebd689012295bf826e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2df2a7019f7f68a915b3edab21921a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac2df2a7019f7f68a915b3edab21921a1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac2df2a7019f7f68a915b3edab21921a1">falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="separator:ac2df2a7019f7f68a915b3edab21921a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7d2db622c0f83134b7f3ebd1eec3c1d6">fdim</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The positive difference function (C99).  <a href="#a7d2db622c0f83134b7f3ebd1eec3c1d6"></a><br/></td></tr>
<tr class="separator:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ac3f1f4f177645d84a1d6480f70d96"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ad8ac3f1f4f177645d84a1d6480f70d96"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2, T3 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad8ac3f1f4f177645d84a1d6480f70d96">fma</a> (const T1 a, const T2 b, const T3 c)</td></tr>
<tr class="memdesc:ad8ac3f1f4f177645d84a1d6480f70d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add operation (C99).  <a href="#ad8ac3f1f4f177645d84a1d6480f70d96"></a><br/></td></tr>
<tr class="separator:ad8ac3f1f4f177645d84a1d6480f70d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed411d626d4ae01a76584c454a83673f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed411d626d4ae01a76584c454a83673f">gamma_p</a> (double x, double a)</td></tr>
<tr class="separator:aed411d626d4ae01a76584c454a83673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0830ba049b81bc98ea9fbcf1eb7b4bd6">gamma_q</a> (double x, double a)</td></tr>
<tr class="separator:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b430ac57e75ba2d55843cd868506e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af7b430ac57e75ba2d55843cd868506e1">ibeta</a> (const double a, const double b, const double x)</td></tr>
<tr class="memdesc:af7b430ac57e75ba2d55843cd868506e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, and x.  <a href="#af7b430ac57e75ba2d55843cd868506e1"></a><br/></td></tr>
<tr class="separator:af7b430ac57e75ba2d55843cd868506e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa732732442d65936275d718b7286cb51"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false &gt; </td></tr>
<tr class="memitem:aa732732442d65936275d718b7286cb51"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_true, T_false &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa732732442d65936275d718b7286cb51">if_else</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:aa732732442d65936275d718b7286cb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second argument if the first argument is true and otherwise return the second argument.  <a href="#aa732732442d65936275d718b7286cb51"></a><br/></td></tr>
<tr class="separator:aa732732442d65936275d718b7286cb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c507cff4b7b473cd86e1d428fb03136">int_step</a> (const T y)</td></tr>
<tr class="memdesc:a8c507cff4b7b473cd86e1d428fb03136"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer step, or Heaviside, function.  <a href="#a8c507cff4b7b473cd86e1d428fb03136"></a><br/></td></tr>
<tr class="separator:a8c507cff4b7b473cd86e1d428fb03136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab64935e0bdac8227bfd9608285d4e699">inv</a> (const T x)</td></tr>
<tr class="separator:ab64935e0bdac8227bfd9608285d4e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a008bf0b6c2ab38d088b0aba5d7b10c8d">inv_cloglog</a> (T x)</td></tr>
<tr class="memdesc:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <a href="#a008bf0b6c2ab38d088b0aba5d7b10c8d"></a><br/></td></tr>
<tr class="separator:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad2c4834fc581f55acf8491ec3f80ecb7">inv_logit</a> (const T a)</td></tr>
<tr class="memdesc:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <a href="#ad2c4834fc581f55acf8491ec3f80ecb7"></a><br/></td></tr>
<tr class="separator:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4b4db5e98585c71cc7c14319f96e0c04">inv_sqrt</a> (const T x)</td></tr>
<tr class="separator:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d2e922aa13e2dfae510fc13d86eaea3">inv_square</a> (const T x)</td></tr>
<tr class="separator:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1edc35cc581dda178263f6a4a4fd1158">inverse_softmax</a> (const Vector &amp;simplex, Vector &amp;y)</td></tr>
<tr class="memdesc:a1edc35cc581dda178263f6a4a4fd1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the inverse softmax of the simplex argument into the second argument.  <a href="#a1edc35cc581dda178263f6a4a4fd1158"></a><br/></td></tr>
<tr class="separator:a1edc35cc581dda178263f6a4a4fd1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40c14c26dc55a985e05695b3ff1eeef2">is_uninitialized</a> (T x)</td></tr>
<tr class="memdesc:a40c14c26dc55a985e05695b3ff1eeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="#a40c14c26dc55a985e05695b3ff1eeef2"></a><br/></td></tr>
<tr class="separator:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ccdb3f505b7db61c510e59e97b947b6">lbeta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a3ccdb3f505b7db61c510e59e97b947b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the beta function applied to the specified arguments.  <a href="#a3ccdb3f505b7db61c510e59e97b947b6"></a><br/></td></tr>
<tr class="separator:a3ccdb3f505b7db61c510e59e97b947b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f46d7f63f5118a32cad11382c0551"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a836f46d7f63f5118a32cad11382c0551">lgamma</a> (double x)</td></tr>
<tr class="separator:a836f46d7f63f5118a32cad11382c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a672486593d10650d0646b513637305"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a672486593d10650d0646b513637305"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3a672486593d10650d0646b513637305">lmgamma</a> (unsigned int k, T x)</td></tr>
<tr class="memdesc:a3a672486593d10650d0646b513637305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument.  <a href="#a3a672486593d10650d0646b513637305"></a><br/></td></tr>
<tr class="separator:a3a672486593d10650d0646b513637305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4f92092fb8a70b31d00898bbbe769612">log1m</a> (T x)</td></tr>
<tr class="memdesc:a4f92092fb8a70b31d00898bbbe769612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the specified value.  <a href="#a4f92092fb8a70b31d00898bbbe769612"></a><br/></td></tr>
<tr class="separator:a4f92092fb8a70b31d00898bbbe769612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ce261caf05bd371c430e82a0e6389a5">log1m_exp</a> (const T a)</td></tr>
<tr class="memdesc:a3ce261caf05bd371c430e82a0e6389a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)).  <a href="#a3ce261caf05bd371c430e82a0e6389a5"></a><br/></td></tr>
<tr class="separator:a3ce261caf05bd371c430e82a0e6389a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac7f71c696a5e0da4daab30e5f3704842">log1m_inv_logit</a> (const T u)</td></tr>
<tr class="memdesc:ac7f71c696a5e0da4daab30e5f3704842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of 1 minus the inverse logit of the specified argument.  <a href="#ac7f71c696a5e0da4daab30e5f3704842"></a><br/></td></tr>
<tr class="separator:ac7f71c696a5e0da4daab30e5f3704842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5166d3c58ad8ce0aedbf104179888b69">log1p</a> (const T x)</td></tr>
<tr class="memdesc:a5166d3c58ad8ce0aedbf104179888b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified value.  <a href="#a5166d3c58ad8ce0aedbf104179888b69"></a><br/></td></tr>
<tr class="separator:a5166d3c58ad8ce0aedbf104179888b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88151def26813dec3e04c4a8b9674091">log1p_exp</a> (const T a)</td></tr>
<tr class="memdesc:a88151def26813dec3e04c4a8b9674091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 plus the exponential of the specified value without overflow.  <a href="#a88151def26813dec3e04c4a8b9674091"></a><br/></td></tr>
<tr class="separator:a88151def26813dec3e04c4a8b9674091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa25e1572bf46e3a6b9ee270f0c7e2c4d">log2</a> (const T a)</td></tr>
<tr class="memdesc:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the argument (C99).  <a href="#aa25e1572bf46e3a6b9ee270f0c7e2c4d"></a><br/></td></tr>
<tr class="separator:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ba3fe3c87293f7c57395007100c79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a947ba3fe3c87293f7c57395007100c79">log2</a> ()</td></tr>
<tr class="memdesc:a947ba3fe3c87293f7c57395007100c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of two.  <a href="#a947ba3fe3c87293f7c57395007100c79"></a><br/></td></tr>
<tr class="separator:a947ba3fe3c87293f7c57395007100c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1dbafd4c2a129415e86f868fc0979a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aac1dbafd4c2a129415e86f868fc0979a"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aac1dbafd4c2a129415e86f868fc0979a">log_diff_exp</a> (const T1 x, const T2 y)</td></tr>
<tr class="memdesc:aac1dbafd4c2a129415e86f868fc0979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2.  <a href="#aac1dbafd4c2a129415e86f868fc0979a"></a><br/></td></tr>
<tr class="separator:aac1dbafd4c2a129415e86f868fc0979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa9cb2f3f6c73b2005d9e9fadbad415bf">log_falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="separator:aa9cb2f3f6c73b2005d9e9fadbad415bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad5be889d1ef4284654a04e400f5371a7">log_inv_logit</a> (const T &amp;u)</td></tr>
<tr class="memdesc:ad5be889d1ef4284654a04e400f5371a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <a href="#ad5be889d1ef4284654a04e400f5371a7"></a><br/></td></tr>
<tr class="separator:ad5be889d1ef4284654a04e400f5371a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf23285d755661c14ca29c3ba935b77d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aaf23285d755661c14ca29c3ba935b77d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaf23285d755661c14ca29c3ba935b77d">log_rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="separator:aaf23285d755661c14ca29c3ba935b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c5f32f7cd1a5690a697f4031df569c4">log_sum_exp</a> (const T2 &amp;a, const T1 &amp;b)</td></tr>
<tr class="memdesc:a3c5f32f7cd1a5690a697f4031df569c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponetials without overflow.  <a href="#a3c5f32f7cd1a5690a697f4031df569c4"></a><br/></td></tr>
<tr class="separator:a3c5f32f7cd1a5690a697f4031df569c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5513861b48f8649938d82883b58170c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5513861b48f8649938d82883b58170c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae5513861b48f8649938d82883b58170c">log_sum_exp</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ae5513861b48f8649938d82883b58170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified sequence of values.  <a href="#ae5513861b48f8649938d82883b58170c"></a><br/></td></tr>
<tr class="separator:ae5513861b48f8649938d82883b58170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adc35bab2db89b3ceda66f11e1fa53ec8">logical_and</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise.  <a href="#adc35bab2db89b3ceda66f11e1fa53ec8"></a><br/></td></tr>
<tr class="separator:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab2213736b55fd6696fa0120fd3fe72e4">logical_eq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab2213736b55fd6696fa0120fd3fe72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is equal to the second.  <a href="#ab2213736b55fd6696fa0120fd3fe72e4"></a><br/></td></tr>
<tr class="separator:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aba86bfd994302061a0260e1202fca777">logical_gt</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:aba86bfd994302061a0260e1202fca777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly greater than the second.  <a href="#aba86bfd994302061a0260e1202fca777"></a><br/></td></tr>
<tr class="separator:aba86bfd994302061a0260e1202fca777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6bb0b8623192207d35e207ea312d8be">logical_gte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ac6bb0b8623192207d35e207ea312d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than or equal to the second.  <a href="#ac6bb0b8623192207d35e207ea312d8be"></a><br/></td></tr>
<tr class="separator:ac6bb0b8623192207d35e207ea312d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0b5bd91412749e10933f304b54aef88f">logical_lt</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:a0b5bd91412749e10933f304b54aef88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly less than the second.  <a href="#a0b5bd91412749e10933f304b54aef88f"></a><br/></td></tr>
<tr class="separator:a0b5bd91412749e10933f304b54aef88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af3649d4c704962c4502cd6220a5e2230">logical_lte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:af3649d4c704962c4502cd6220a5e2230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is less than or equal to the second.  <a href="#af3649d4c704962c4502cd6220a5e2230"></a><br/></td></tr>
<tr class="separator:af3649d4c704962c4502cd6220a5e2230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aad2fc9ce55dfac079d930335beb7e4a8">logical_negation</a> (const T x)</td></tr>
<tr class="memdesc:aad2fc9ce55dfac079d930335beb7e4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical negation function which returns 1 if the input is equal to zero and 0 otherwise.  <a href="#aad2fc9ce55dfac079d930335beb7e4a8"></a><br/></td></tr>
<tr class="separator:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a206eb210d8e7e2c718af25c40de8f9d1">logical_neq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a206eb210d8e7e2c718af25c40de8f9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is unequal to the second.  <a href="#a206eb210d8e7e2c718af25c40de8f9d1"></a><br/></td></tr>
<tr class="separator:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac74007e2d5f55d5ae4a308f535869aee">logical_or</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:ac74007e2d5f55d5ae4a308f535869aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise.  <a href="#ac74007e2d5f55d5ae4a308f535869aee"></a><br/></td></tr>
<tr class="separator:ac74007e2d5f55d5ae4a308f535869aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53342d0c2cd3a6e440c533070054aca3">logit</a> (const T a)</td></tr>
<tr class="memdesc:a53342d0c2cd3a6e440c533070054aca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logit function applied to the argument.  <a href="#a53342d0c2cd3a6e440c533070054aca3"></a><br/></td></tr>
<tr class="separator:a53342d0c2cd3a6e440c533070054aca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6be1d580b3b5cf4b4f57546062352"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a> (const double a, const double b)</td></tr>
<tr class="separator:a86b6be1d580b3b5cf4b4f57546062352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab360c822174f211838f5979760c7e09e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab360c822174f211838f5979760c7e09e">min</a> (const double a, const double b)</td></tr>
<tr class="separator:ab360c822174f211838f5979760c7e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acafecf14b103c7c17da33368d07b1565">modified_bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="separator:acafecf14b103c7c17da33368d07b1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a72ce86f3db5478cad4666c9cf1d05a6e">modified_bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="separator:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_a, T_b &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab530a1792bc901bb6ade34ef3d9ef8b3">multiply_log</a> (const T_a a, const T_b b)</td></tr>
<tr class="memdesc:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs.  <a href="#ab530a1792bc901bb6ade34ef3d9ef8b3"></a><br/></td></tr>
<tr class="separator:ab530a1792bc901bb6ade34ef3d9ef8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66a7e8ebefd11e5801aab51d6ed9c9d8">owens_t</a> (const T1 &amp;h, const T2 &amp;a)</td></tr>
<tr class="memdesc:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#a66a7e8ebefd11e5801aab51d6ed9c9d8"></a><br/></td></tr>
<tr class="separator:a66a7e8ebefd11e5801aab51d6ed9c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac85644bbd92359d699f374adea62c643">Phi</a> (const T x)</td></tr>
<tr class="memdesc:ac85644bbd92359d699f374adea62c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative distribution function.  <a href="#ac85644bbd92359d699f374adea62c643"></a><br/></td></tr>
<tr class="separator:ac85644bbd92359d699f374adea62c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cf4bf2074175fd7bcde43f9f94e4d16">Phi_approx</a> (T x)</td></tr>
<tr class="memdesc:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF.  <a href="#a6cf4bf2074175fd7bcde43f9f94e4d16"></a><br/></td></tr>
<tr class="separator:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c25994a9886374662f280ecba376a42"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3c25994a9886374662f280ecba376a42"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c25994a9886374662f280ecba376a42">rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="separator:a3c25994a9886374662f280ecba376a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb786f14699d69c39cfdd49893a8006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2eb786f14699d69c39cfdd49893a8006">scaled_add</a> (std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y, const double lambda)</td></tr>
<tr class="separator:a2eb786f14699d69c39cfdd49893a8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a056b82f11f784f321bce2c5677089e24">square</a> (const T x)</td></tr>
<tr class="memdesc:a056b82f11f784f321bce2c5677089e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the specified argument.  <a href="#a056b82f11f784f321bce2c5677089e24"></a><br/></td></tr>
<tr class="separator:a056b82f11f784f321bce2c5677089e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fdc5e5ba8e306c2a594e928bfd62ea2">step</a> (const T y)</td></tr>
<tr class="memdesc:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step, or Heaviside, function.  <a href="#a8fdc5e5ba8e306c2a594e928bfd62ea2"></a><br/></td></tr>
<tr class="separator:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e4c5e5b76b18a41b28f646104b3cd46">sub</a> (std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;y, std::vector&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1fe0f002efa49cf9f7c129fe1a1d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adde1fe0f002efa49cf9f7c129fe1a1d0">sum</a> (std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:adde1fe0f002efa49cf9f7c129fe1a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e">value_of</a> (const T x)</td></tr>
<tr class="memdesc:a73087d72fd937f4be66684bd2613ae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="#a73087d72fd937f4be66684bd2613ae6e"></a><br/></td></tr>
<tr class="separator:a73087d72fd937f4be66684bd2613ae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2d7774df98215b7d113075019d74ebbf">value_of&lt; double &gt;</a> (const double x)</td></tr>
<tr class="memdesc:a2d7774df98215b7d113075019d74ebbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="#a2d7774df98215b7d113075019d74ebbf"></a><br/></td></tr>
<tr class="separator:a2d7774df98215b7d113075019d74ebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4b97f71328d3de40de286ec6e3754e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a3d4b97f71328d3de40de286ec6e3754e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d4b97f71328d3de40de286ec6e3754e">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a3d4b97f71328d3de40de286ec6e3754e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrices.  <a href="#a3d4b97f71328d3de40de286ec6e3754e"></a><br/></td></tr>
<tr class="separator:a3d4b97f71328d3de40de286ec6e3754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ade0aeac74c8366b8c210446324a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:aa92ade0aeac74c8366b8c210446324a1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa92ade0aeac74c8366b8c210446324a1">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:aa92ade0aeac74c8366b8c210446324a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrix and specified scalar.  <a href="#aa92ade0aeac74c8366b8c210446324a1"></a><br/></td></tr>
<tr class="separator:aa92ade0aeac74c8366b8c210446324a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cbcb4a48d3284e93afe13093412683"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:ac4cbcb4a48d3284e93afe13093412683"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac4cbcb4a48d3284e93afe13093412683">add</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ac4cbcb4a48d3284e93afe13093412683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalar and specified matrix.  <a href="#ac4cbcb4a48d3284e93afe13093412683"></a><br/></td></tr>
<tr class="separator:ac4cbcb4a48d3284e93afe13093412683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf">assign</a> (LHS &amp;lhs, const RHS &amp;rhs)</td></tr>
<tr class="memdesc:a5f394c15ea3eb97743382631f91801cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5f394c15ea3eb97743382631f91801cf"></a><br/></td></tr>
<tr class="separator:a5f394c15ea3eb97743382631f91801cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5371f0f914e9b79a0700577e5557c0b7">assign</a> (Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;x, const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;y)</td></tr>
<tr class="memdesc:a5371f0f914e9b79a0700577e5557c0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5371f0f914e9b79a0700577e5557c0b7"></a><br/></td></tr>
<tr class="separator:a5371f0f914e9b79a0700577e5557c0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a80c719463c4e3caa03df731e2c2cb9">assign</a> (Eigen::Matrix&lt; LHS, R, C &gt; &amp;x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:a0a80c719463c4e3caa03df731e2c2cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a0a80c719463c4e3caa03df731e2c2cb9"></a><br/></td></tr>
<tr class="separator:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa4af3a90ad3b5ec1507dfc1823fdb8da">assign</a> (Eigen::Block&lt; LHS &gt; x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#aa4af3a90ad3b5ec1507dfc1823fdb8da"></a><br/></td></tr>
<tr class="separator:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2c6dec98c71fd478c2ee16bc274b464d">assign</a> (std::vector&lt; LHS &gt; &amp;x, const std::vector&lt; RHS &gt; &amp;y)</td></tr>
<tr class="memdesc:a2c6dec98c71fd478c2ee16bc274b464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a2c6dec98c71fd478c2ee16bc274b464d"></a><br/></td></tr>
<tr class="separator:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af163dfd071f1cff0297b7418156563a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af163dfd071f1cff0297b7418156563a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af163dfd071f1cff0297b7418156563a8">block</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:af163dfd071f1cff0297b7418156563a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1,j-1).  <a href="#af163dfd071f1cff0297b7418156563a8"></a><br/></td></tr>
<tr class="separator:af163dfd071f1cff0297b7418156563a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220906f5cf5892f9867a4b9bcec08c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1220906f5cf5892f9867a4b9bcec08c9">check_range</a> (size_t <a class="el" href="namespacestan_1_1math.html#a86b6be1d580b3b5cf4b4f57546062352">max</a>, size_t i, const char *msg, size_t idx)</td></tr>
<tr class="separator:a1220906f5cf5892f9867a4b9bcec08c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abbcc91ff24e86fa318fe0f8a9111b4c5">cholesky_decompose</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="#abbcc91ff24e86fa318fe0f8a9111b4c5"></a><br/></td></tr>
<tr class="separator:abbcc91ff24e86fa318fe0f8a9111b4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae497ca37fd7867fd11c4cd095c8aaa71">col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t j)</td></tr>
<tr class="memdesc:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified matrix using start-at-1 indexing.  <a href="#ae497ca37fd7867fd11c4cd095c8aaa71"></a><br/></td></tr>
<tr class="separator:ae497ca37fd7867fd11c4cd095c8aaa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a871bccc233a4dcd764ffece5a3f9a399">cols</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a871bccc233a4dcd764ffece5a3f9a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d03b34aa7329a68f31d1c7bc500c5c8">columns_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6d03b34aa7329a68f31d1c7bc500c5c8"></a><br/></td></tr>
<tr class="separator:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03701ff6420231890468e9881eb9245"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af03701ff6420231890468e9881eb9245"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af03701ff6420231890468e9881eb9245">columns_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:af03701ff6420231890468e9881eb9245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="#af03701ff6420231890468e9881eb9245"></a><br/></td></tr>
<tr class="separator:af03701ff6420231890468e9881eb9245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a62cc3a137ff3220bdd0137a52a4b9714">crossprod</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a62cc3a137ff3220bdd0137a52a4b9714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="#a62cc3a137ff3220bdd0137a52a4b9714"></a><br/></td></tr>
<tr class="separator:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7340f6be8ae1e121c6d854005560fef5">cumulative_sum</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7340f6be8ae1e121c6d854005560fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="#a7340f6be8ae1e121c6d854005560fef5"></a><br/></td></tr>
<tr class="separator:a7340f6be8ae1e121c6d854005560fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab469ac332306aa00947f4a7c5d30b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:affab469ac332306aa00947f4a7c5d30b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#affab469ac332306aa00947f4a7c5d30b">cumulative_sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:affab469ac332306aa00947f4a7c5d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified matrix.  <a href="#affab469ac332306aa00947f4a7c5d30b"></a><br/></td></tr>
<tr class="separator:affab469ac332306aa00947f4a7c5d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab65e9ab0e6f725c7e11068b0be2af84f">determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the specified square matrix.  <a href="#ab65e9ab0e6f725c7e11068b0be2af84f"></a><br/></td></tr>
<tr class="separator:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af970bc3201f476e84259e7ba2d4eb276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af970bc3201f476e84259e7ba2d4eb276"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af970bc3201f476e84259e7ba2d4eb276">diag_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:af970bc3201f476e84259e7ba2d4eb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="#af970bc3201f476e84259e7ba2d4eb276"></a><br/></td></tr>
<tr class="separator:af970bc3201f476e84259e7ba2d4eb276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00896827d3247350178c86c0aed533f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a00896827d3247350178c86c0aed533f6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00896827d3247350178c86c0aed533f6">diag_post_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a00896827d3247350178c86c0aed533f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6159f8ffb5a37c394dff93781622f504"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6159f8ffb5a37c394dff93781622f504"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R2, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6159f8ffb5a37c394dff93781622f504">diag_pre_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a6159f8ffb5a37c394dff93781622f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a877aa9df52c3a3f300a3d214c7bde64a">diagonal</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a877aa9df52c3a3f300a3d214c7bde64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <a href="#a877aa9df52c3a3f300a3d214c7bde64a"></a><br/></td></tr>
<tr class="separator:a877aa9df52c3a3f300a3d214c7bde64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a> (const T &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a2b9073e39033e56eb31344091f0170fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af95a2dcde478c06e3543511821618902">dims</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:af95a2dcde478c06e3543511821618902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a467589eef4220a87d457c8a268a1fd5d">dims</a> (const std::vector&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a467589eef4220a87d457c8a268a1fd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a33777ee768c7032331ca8b92e5323384">dims</a> (const T &amp;x)</td></tr>
<tr class="separator:a33777ee768c7032331ca8b92e5323384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7a051fb294f63774525cb76bfb3fb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a5b7a051fb294f63774525cb76bfb3fb9"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b7a051fb294f63774525cb76bfb3fb9">dist</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a5b7a051fb294f63774525cb76bfb3fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between the specified vectors.  <a href="#a5b7a051fb294f63774525cb76bfb3fb9"></a><br/></td></tr>
<tr class="separator:a5b7a051fb294f63774525cb76bfb3fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a082ee76b34a2ea656d2c8ab9186c1a2b">divide</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix divided by specified scalar.  <a href="#a082ee76b34a2ea656d2c8ab9186c1a2b"></a><br/></td></tr>
<tr class="separator:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8d73851895fb151fdf79e55bf33e98e">dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af8d73851895fb151fdf79e55bf33e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#af8d73851895fb151fdf79e55bf33e98e"></a><br/></td></tr>
<tr class="separator:af8d73851895fb151fdf79e55bf33e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58da447df259e9e092e8fd910b338e1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58da447df259e9e092e8fd910b338e1f">dot_product</a> (const double *v1, const double *v2, size_t <a class="el" href="namespacestan.html#a59c48c2ee48c5a6e8048fa2d6a035445">length</a>)</td></tr>
<tr class="memdesc:a58da447df259e9e092e8fd910b338e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#a58da447df259e9e092e8fd910b338e1f"></a><br/></td></tr>
<tr class="separator:a58da447df259e9e092e8fd910b338e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd93708bf432b3bd3d284958972ede"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7cd93708bf432b3bd3d284958972ede">dot_product</a> (const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab7cd93708bf432b3bd3d284958972ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#ab7cd93708bf432b3bd3d284958972ede"></a><br/></td></tr>
<tr class="separator:ab7cd93708bf432b3bd3d284958972ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac81ab85d390fcb594884773a85fac657">dot_self</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ac81ab85d390fcb594884773a85fac657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vector with itself.  <a href="#ac81ab85d390fcb594884773a85fac657"></a><br/></td></tr>
<tr class="separator:ac81ab85d390fcb594884773a85fac657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa37c65f508af7ad1d0b010aa5c932cbe">eigenvalues_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix in descending order of magnitude.  <a href="#aa37c65f508af7ad1d0b010aa5c932cbe"></a><br/></td></tr>
<tr class="separator:aa37c65f508af7ad1d0b010aa5c932cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4729756e6ed00a35f1e4531444c13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bd4729756e6ed00a35f1e4531444c13"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9bd4729756e6ed00a35f1e4531444c13">eigenvectors_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a9bd4729756e6ed00a35f1e4531444c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9262da41fbf44fefc9a66141a0759d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a3c9262da41fbf44fefc9a66141a0759d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c9262da41fbf44fefc9a66141a0759d">elt_divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a3c9262da41fbf44fefc9a66141a0759d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrices matrices.  <a href="#a3c9262da41fbf44fefc9a66141a0759d"></a><br/></td></tr>
<tr class="separator:a3c9262da41fbf44fefc9a66141a0759d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e2dce5971bba8c059995797e22ba0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a998e2dce5971bba8c059995797e22ba0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a998e2dce5971bba8c059995797e22ba0">elt_multiply</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a998e2dce5971bba8c059995797e22ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified matrices.  <a href="#a998e2dce5971bba8c059995797e22ba0"></a><br/></td></tr>
<tr class="separator:a998e2dce5971bba8c059995797e22ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac38f1fab5fe3e9b45c8c6e78ac3cc749">exp</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise exponentiation of the matrix or vector.  <a href="#ac38f1fab5fe3e9b45c8c6e78ac3cc749"></a><br/></td></tr>
<tr class="separator:ac38f1fab5fe3e9b45c8c6e78ac3cc749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d362e53d3d40b61e68fdd08dc5eb38b">fill</a> (T &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a6d362e53d3d40b61e68fdd08dc5eb38b"></a><br/></td></tr>
<tr class="separator:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename S &gt; </td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73e791042ed648602eed1754679feff4">fill</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a73e791042ed648602eed1754679feff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a73e791042ed648602eed1754679feff4"></a><br/></td></tr>
<tr class="separator:a73e791042ed648602eed1754679feff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7f5d81c4d45f2407096def8810ffe00">fill</a> (std::vector&lt; T &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:aa7f5d81c4d45f2407096def8810ffe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#aa7f5d81c4d45f2407096def8810ffe00"></a><br/></td></tr>
<tr class="separator:aa7f5d81c4d45f2407096def8810ffe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7535c86e2c9ee9d5391a8cc63187317e">get_base1</a> (const std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7535c86e2c9ee9d5391a8cc63187317e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#a7535c86e2c9ee9d5391a8cc63187317e"></a><br/></td></tr>
<tr class="separator:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca7c84b936da0d3422507927cf9a68cc">get_base1</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aca7c84b936da0d3422507927cf9a68cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aca7c84b936da0d3422507927cf9a68cc"></a><br/></td></tr>
<tr class="separator:aca7c84b936da0d3422507927cf9a68cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a714e39ba9fcbbd90c787a51d511c9af1">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a714e39ba9fcbbd90c787a51d511c9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a714e39ba9fcbbd90c787a51d511c9af1"></a><br/></td></tr>
<tr class="separator:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa23b355397df347249da513307fd6667">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aa23b355397df347249da513307fd6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aa23b355397df347249da513307fd6667"></a><br/></td></tr>
<tr class="separator:aa23b355397df347249da513307fd6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25c1fac0445beea55c521c94f360e13e">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a25c1fac0445beea55c521c94f360e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a25c1fac0445beea55c521c94f360e13e"></a><br/></td></tr>
<tr class="separator:a25c1fac0445beea55c521c94f360e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a20a82151947fc8816c5ce5b7bc6d8abd">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a20a82151947fc8816c5ce5b7bc6d8abd"></a><br/></td></tr>
<tr class="separator:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6fb72caff19c8ce19dc6e3c25c79f7b8">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a6fb72caff19c8ce19dc6e3c25c79f7b8"></a><br/></td></tr>
<tr class="separator:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#accc97dd76490d575638ebb22da233a53">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:accc97dd76490d575638ebb22da233a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#accc97dd76490d575638ebb22da233a53"></a><br/></td></tr>
<tr class="separator:accc97dd76490d575638ebb22da233a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72208605f731144cab862feecb456a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae72208605f731144cab862feecb456a2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae72208605f731144cab862feecb456a2">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ae72208605f731144cab862feecb456a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#ae72208605f731144cab862feecb456a2"></a><br/></td></tr>
<tr class="separator:ae72208605f731144cab862feecb456a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51091bb67549e42c241f4e08e7d291d6">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a51091bb67549e42c241f4e08e7d291d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#a51091bb67549e42c241f4e08e7d291d6"></a><br/></td></tr>
<tr class="separator:a51091bb67549e42c241f4e08e7d291d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0dbeed50ff3f8630ea3cd54f9ecb804">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#ab0dbeed50ff3f8630ea3cd54f9ecb804"></a><br/></td></tr>
<tr class="separator:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abf9dcd5236495d3f581b31dd05b9a227">get_base1</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abf9dcd5236495d3f581b31dd05b9a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#abf9dcd5236495d3f581b31dd05b9a227"></a><br/></td></tr>
<tr class="separator:abf9dcd5236495d3f581b31dd05b9a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac54b1427fd9d0765f0200dc9caa830f9">get_base1_lhs</a> (std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ac54b1427fd9d0765f0200dc9caa830f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#ac54b1427fd9d0765f0200dc9caa830f9"></a><br/></td></tr>
<tr class="separator:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d5711f99869d05a6263218f3256e582">get_base1_lhs</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a4d5711f99869d05a6263218f3256e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a4d5711f99869d05a6263218f3256e582"></a><br/></td></tr>
<tr class="separator:a4d5711f99869d05a6263218f3256e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37f3ceaa6197904ef662f1edc8245e1a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a37f3ceaa6197904ef662f1edc8245e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a37f3ceaa6197904ef662f1edc8245e1a"></a><br/></td></tr>
<tr class="separator:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3132eb36eaf861cfbd119b38e0a85a15">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a3132eb36eaf861cfbd119b38e0a85a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a3132eb36eaf861cfbd119b38e0a85a15"></a><br/></td></tr>
<tr class="separator:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afbcc061003aabcaf675f4415adc80c0a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:afbcc061003aabcaf675f4415adc80c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#afbcc061003aabcaf675f4415adc80c0a"></a><br/></td></tr>
<tr class="separator:afbcc061003aabcaf675f4415adc80c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1958245532761be08be7ac9bc781f3a7">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a1958245532761be08be7ac9bc781f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a1958245532761be08be7ac9bc781f3a7"></a><br/></td></tr>
<tr class="separator:a1958245532761be08be7ac9bc781f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aedc7fc712ebe439bec1892c8f69447cd">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aedc7fc712ebe439bec1892c8f69447cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aedc7fc712ebe439bec1892c8f69447cd"></a><br/></td></tr>
<tr class="separator:aedc7fc712ebe439bec1892c8f69447cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a64467731d9abfaf97ea8d541d528142c">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a64467731d9abfaf97ea8d541d528142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a64467731d9abfaf97ea8d541d528142c"></a><br/></td></tr>
<tr class="separator:a64467731d9abfaf97ea8d541d528142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd7246170c1c0cade6c7be73f436e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbdd7246170c1c0cade6c7be73f436e0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abbdd7246170c1c0cade6c7be73f436e0">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abbdd7246170c1c0cade6c7be73f436e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#abbdd7246170c1c0cade6c7be73f436e0"></a><br/></td></tr>
<tr class="separator:abbdd7246170c1c0cade6c7be73f436e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8cb7e6e670cddcdf5527ec92fa3ff37">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#af8cb7e6e670cddcdf5527ec92fa3ff37"></a><br/></td></tr>
<tr class="separator:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffeab694f7588c92dc97b6736e5be7b">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:adffeab694f7588c92dc97b6736e5be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#adffeab694f7588c92dc97b6736e5be7b"></a><br/></td></tr>
<tr class="separator:adffeab694f7588c92dc97b6736e5be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6133d90708e16760b6394c6ca6a305ff">get_base1_lhs</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6133d90708e16760b6394c6ca6a305ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#a6133d90708e16760b6394c6ca6a305ff"></a><br/></td></tr>
<tr class="separator:a6133d90708e16760b6394c6ca6a305ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140b54b11069aed039f67c6dd172256b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a140b54b11069aed039f67c6dd172256b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a140b54b11069aed039f67c6dd172256b">head</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:a140b54b11069aed039f67c6dd172256b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the front of the specified vector.  <a href="#a140b54b11069aed039f67c6dd172256b"></a><br/></td></tr>
<tr class="separator:a140b54b11069aed039f67c6dd172256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7964d83597ea54cd7ba63bee50409f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d7964d83597ea54cd7ba63bee50409f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d7964d83597ea54cd7ba63bee50409f">head</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:a4d7964d83597ea54cd7ba63bee50409f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the front of the specified row vector.  <a href="#a4d7964d83597ea54cd7ba63bee50409f"></a><br/></td></tr>
<tr class="separator:a4d7964d83597ea54cd7ba63bee50409f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e746ba14994b318a0a192a97a0a28db">head</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a5e746ba14994b318a0a192a97a0a28db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the front of the specified standard vector.  <a href="#a5e746ba14994b318a0a192a97a0a28db"></a><br/></td></tr>
<tr class="separator:a5e746ba14994b318a0a192a97a0a28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af81e05dfd6918524dafff10715f21a8d">initialize</a> (T &amp;x, const T &amp;v)</td></tr>
<tr class="separator:af81e05dfd6918524dafff10715f21a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067af584ff2d244d2041c9b13f6d9247"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a067af584ff2d244d2041c9b13f6d9247"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; V &gt;<br class="typebreak"/>
::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a067af584ff2d244d2041c9b13f6d9247">initialize</a> (T &amp;x, V v)</td></tr>
<tr class="separator:a067af584ff2d244d2041c9b13f6d9247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d6d42a356af95988b3a7005b5cf408"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aa2d6d42a356af95988b3a7005b5cf408"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa2d6d42a356af95988b3a7005b5cf408">initialize</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:aa2d6d42a356af95988b3a7005b5cf408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad27706378f77dc22746ad74721d495d4">initialize</a> (std::vector&lt; T &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:ad27706378f77dc22746ad74721d495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461598c914f5634fa5057da7a817803d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a461598c914f5634fa5057da7a817803d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a461598c914f5634fa5057da7a817803d">inverse</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a461598c914f5634fa5057da7a817803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified matrix.  <a href="#a461598c914f5634fa5057da7a817803d"></a><br/></td></tr>
<tr class="separator:a461598c914f5634fa5057da7a817803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989989548db02c34cd6134790bd93478"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a989989548db02c34cd6134790bd93478"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a989989548db02c34cd6134790bd93478">inverse_spd</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a989989548db02c34cd6134790bd93478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified symmetric, pos/neg-definite matrix.  <a href="#a989989548db02c34cd6134790bd93478"></a><br/></td></tr>
<tr class="separator:a989989548db02c34cd6134790bd93478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978022fb9cb20fd35f6e9e89ab3bc871"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a978022fb9cb20fd35f6e9e89ab3bc871"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a978022fb9cb20fd35f6e9e89ab3bc871">mdivide_left_ldlt</a> (const stan::math::LDLT_factor&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a978022fb9cb20fd35f6e9e89ab3bc871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c862e90d97ea5d5552101b65978813"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a68c862e90d97ea5d5552101b65978813"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a68c862e90d97ea5d5552101b65978813">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const stan::math::LDLT_factor&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="separator:a68c862e90d97ea5d5552101b65978813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d77bf4121d56b8491092164d1523ce"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a01d77bf4121d56b8491092164d1523ce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a01d77bf4121d56b8491092164d1523ce">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;b, const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;A)</td></tr>
<tr class="separator:a01d77bf4121d56b8491092164d1523ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d737ee042b8f40e93713cd87fe48b"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a306d737ee042b8f40e93713cd87fe48b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a306d737ee042b8f40e93713cd87fe48b">log_determinant_ldlt</a> (stan::math::LDLT_factor&lt; double, R, C &gt; &amp;A)</td></tr>
<tr class="separator:a306d737ee042b8f40e93713cd87fe48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8b4d4ddbcb7df66d3baf8394318e1e"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:aab8b4d4ddbcb7df66d3baf8394318e1e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab8b4d4ddbcb7df66d3baf8394318e1e">trace_inv_quad_form_ldlt</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;D, const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; double, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:aab8b4d4ddbcb7df66d3baf8394318e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0261f49dc318d8ee553e378325ee3db"><td class="memTemplParams" colspan="2">template&lt;int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:aa0261f49dc318d8ee553e378325ee3db"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa0261f49dc318d8ee553e378325ee3db">trace_inv_quad_form_ldlt</a> (const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; double, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:aa0261f49dc318d8ee553e378325ee3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3e7ce33064686ec2a2591fa5d4227cf">log</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise logarithm of the matrix or vector.  <a href="#ae3e7ce33064686ec2a2591fa5d4227cf"></a><br/></td></tr>
<tr class="separator:ae3e7ce33064686ec2a2591fa5d4227cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca29dad18932e3ca17ac52fd0238b364">log_determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:aca29dad18932e3ca17ac52fd0238b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#aca29dad18932e3ca17ac52fd0238b364"></a><br/></td></tr>
<tr class="separator:aca29dad18932e3ca17ac52fd0238b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae9a296d4414d0193108c70b350a05cfc">log_determinant_spd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae9a296d4414d0193108c70b350a05cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#ae9a296d4414d0193108c70b350a05cfc"></a><br/></td></tr>
<tr class="separator:ae9a296d4414d0193108c70b350a05cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a8c8bb83f9b6c700a725240be33b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a011a8c8bb83f9b6c700a725240be33b5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a011a8c8bb83f9b6c700a725240be33b5">log_softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a011a8c8bb83f9b6c700a725240be33b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the softmax of the specified vector.  <a href="#a011a8c8bb83f9b6c700a725240be33b5"></a><br/></td></tr>
<tr class="separator:a011a8c8bb83f9b6c700a725240be33b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205ce595af6efac8746bd83b2b761da"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a6205ce595af6efac8746bd83b2b761da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6205ce595af6efac8746bd83b2b761da">log_sum_exp</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a6205ce595af6efac8746bd83b2b761da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="#a6205ce595af6efac8746bd83b2b761da"></a><br/></td></tr>
<tr class="separator:a6205ce595af6efac8746bd83b2b761da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#a5da0ef87756d3dbd20ca4ff5a3efa10d"></a><br/></td></tr>
<tr class="separator:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acde414919e0e4dcfa72d565679819091">max</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:acde414919e0e4dcfa72d565679819091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#acde414919e0e4dcfa72d565679819091"></a><br/></td></tr>
<tr class="separator:acde414919e0e4dcfa72d565679819091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3f299773dc20e8305fc16df1be8d029">max</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae3f299773dc20e8305fc16df1be8d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified vector, row vector, or matrix.  <a href="#ae3f299773dc20e8305fc16df1be8d029"></a><br/></td></tr>
<tr class="separator:ae3f299773dc20e8305fc16df1be8d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266758367e8260b2afbfaeea7d5b418"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7266758367e8260b2afbfaeea7d5b418"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7266758367e8260b2afbfaeea7d5b418">mdivide_left</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a7266758367e8260b2afbfaeea7d5b418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a7266758367e8260b2afbfaeea7d5b418"></a><br/></td></tr>
<tr class="separator:a7266758367e8260b2afbfaeea7d5b418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c8c6e72f1cbf2b73008d4fc98de1abe">mdivide_left_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#a0c8c6e72f1cbf2b73008d4fc98de1abe"></a><br/></td></tr>
<tr class="separator:a0c8c6e72f1cbf2b73008d4fc98de1abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9ffa799f8af2cd4941cbd2506bc4573">mdivide_left_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#ac9ffa799f8af2cd4941cbd2506bc4573"></a><br/></td></tr>
<tr class="separator:ac9ffa799f8af2cd4941cbd2506bc4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dbd828faf06c2ef74152367f749ca4"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a58dbd828faf06c2ef74152367f749ca4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58dbd828faf06c2ef74152367f749ca4">mdivide_left_tri</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="memdesc:a58dbd828faf06c2ef74152367f749ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="#a58dbd828faf06c2ef74152367f749ca4"></a><br/></td></tr>
<tr class="separator:a58dbd828faf06c2ef74152367f749ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a199a9357715dff8b9a3bae8cc1bb4aa5">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a199a9357715dff8b9a3bae8cc1bb4aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8391d23da9e29f3420fdb89116e83cd"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:ae8391d23da9e29f3420fdb89116e83cd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae8391d23da9e29f3420fdb89116e83cd">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="separator:ae8391d23da9e29f3420fdb89116e83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5efba9dddcf77889b66c1210ba55cf5f">mdivide_right</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a5efba9dddcf77889b66c1210ba55cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a5efba9dddcf77889b66c1210ba55cf5f"></a><br/></td></tr>
<tr class="separator:a5efba9dddcf77889b66c1210ba55cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d6f32dd8adc4a9ffa28d63b62d4c90f">mdivide_right_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#a5d6f32dd8adc4a9ffa28d63b62d4c90f"></a><br/></td></tr>
<tr class="separator:a5d6f32dd8adc4a9ffa28d63b62d4c90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae158767243e09b91b9ba6cd366e7dab8"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ae158767243e09b91b9ba6cd366e7dab8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae158767243e09b91b9ba6cd366e7dab8">mdivide_right_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:ae158767243e09b91b9ba6cd366e7dab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#ae158767243e09b91b9ba6cd366e7dab8"></a><br/></td></tr>
<tr class="separator:ae158767243e09b91b9ba6cd366e7dab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09f35fbeab4d8ff311ce77d91492e26b">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a09f35fbeab4d8ff311ce77d91492e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A.  <a href="#a09f35fbeab4d8ff311ce77d91492e26b"></a><br/></td></tr>
<tr class="separator:a09f35fbeab4d8ff311ce77d91492e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3443c4ac994b039a7f055c55c5afa8a3">mean</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a3443c4ac994b039a7f055c55c5afa8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified standard vector.  <a href="#a3443c4ac994b039a7f055c55c5afa8a3"></a><br/></td></tr>
<tr class="separator:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8074c0041b93407c473fd26a7c45dc88">mean</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8074c0041b93407c473fd26a7c45dc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8074c0041b93407c473fd26a7c45dc88"></a><br/></td></tr>
<tr class="separator:a8074c0041b93407c473fd26a7c45dc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f076860549f63d55c0e4985dce78099"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f076860549f63d55c0e4985dce78099">min</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a3f076860549f63d55c0e4985dce78099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a3f076860549f63d55c0e4985dce78099"></a><br/></td></tr>
<tr class="separator:a3f076860549f63d55c0e4985dce78099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e9c3a01030d96fd4c8f28e2ed8d3d61">min</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a9e9c3a01030d96fd4c8f28e2ed8d3d61"></a><br/></td></tr>
<tr class="separator:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86f2380e5c54a549e0f74ffd51204d33">min</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a86f2380e5c54a549e0f74ffd51204d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified matrix, vector, or row vector.  <a href="#a86f2380e5c54a549e0f74ffd51204d33"></a><br/></td></tr>
<tr class="separator:a86f2380e5c54a549e0f74ffd51204d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87b343d6dc12982c2b76c453650c0797">minus</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a87b343d6dc12982c2b76c453650c0797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negation of the specified scalar or matrix.  <a href="#a87b343d6dc12982c2b76c453650c0797"></a><br/></td></tr>
<tr class="separator:a87b343d6dc12982c2b76c453650c0797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a919d4a6495c489841df3d0423200b147">multiply</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a919d4a6495c489841df3d0423200b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <a href="#a919d4a6495c489841df3d0423200b147"></a><br/></td></tr>
<tr class="separator:a919d4a6495c489841df3d0423200b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5a2b6dbfb5543b73dac8496091745ec1">multiply</a> (T c, const Eigen::Matrix&lt; double, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a5a2b6dbfb5543b73dac8496091745ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified scalar multiplied by specified matrix.  <a href="#a5a2b6dbfb5543b73dac8496091745ec1"></a><br/></td></tr>
<tr class="separator:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c72cdca253e0230e0dbd19400781b5c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7c72cdca253e0230e0dbd19400781b5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c72cdca253e0230e0dbd19400781b5c">multiply</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a7c72cdca253e0230e0dbd19400781b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="#a7c72cdca253e0230e0dbd19400781b5c"></a><br/></td></tr>
<tr class="separator:a7c72cdca253e0230e0dbd19400781b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplParams" colspan="2">template&lt;int C1, int R2&gt; </td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e67698775aaac248efa49b646ca2a51">multiply</a> (const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a6e67698775aaac248efa49b646ca2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <a href="#a6e67698775aaac248efa49b646ca2a51"></a><br/></td></tr>
<tr class="separator:a6e67698775aaac248efa49b646ca2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c953951f141b35277fe2308777cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c0c953951f141b35277fe2308777cff">multiply_lower_tri_self_transpose</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;L)</td></tr>
<tr class="memdesc:a3c0c953951f141b35277fe2308777cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="#a3c0c953951f141b35277fe2308777cff"></a><br/></td></tr>
<tr class="separator:a3c0c953951f141b35277fe2308777cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1649a895ec6e79097d5645a3f8b8a1e6">prod</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified standard vector.  <a href="#a1649a895ec6e79097d5645a3f8b8a1e6"></a><br/></td></tr>
<tr class="separator:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7082de8742d87f7a0fa0842207341c9">prod</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7082de8742d87f7a0fa0842207341c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified column vector.  <a href="#ad7082de8742d87f7a0fa0842207341c9"></a><br/></td></tr>
<tr class="separator:ad7082de8742d87f7a0fa0842207341c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91458631115a8d1cf29298431f745556"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:a91458631115a8d1cf29298431f745556"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a91458631115a8d1cf29298431f745556">promote_common</a> (const F &amp;u)</td></tr>
<tr class="separator:a91458631115a8d1cf29298431f745556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376cbe31002df6a319da4caaaeb8598c"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a376cbe31002df6a319da4caaaeb8598c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a376cbe31002df6a319da4caaaeb8598c">quad_form</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a376cbe31002df6a319da4caaaeb8598c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute B^T A B.  <a href="#a376cbe31002df6a319da4caaaeb8598c"></a><br/></td></tr>
<tr class="separator:a376cbe31002df6a319da4caaaeb8598c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0213e916c2185844b48eea25312e86"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB&gt; </td></tr>
<tr class="memitem:a0e0213e916c2185844b48eea25312e86"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e0213e916c2185844b48eea25312e86">quad_form</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a0e0213e916c2185844b48eea25312e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc753af413f715d82b992aae8b10fde"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a2cc753af413f715d82b992aae8b10fde"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2cc753af413f715d82b992aae8b10fde">quad_form_sym</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a2cc753af413f715d82b992aae8b10fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9355d4e6239f0bb06e0b8d2302f37af4"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB&gt; </td></tr>
<tr class="memitem:a9355d4e6239f0bb06e0b8d2302f37af4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9355d4e6239f0bb06e0b8d2302f37af4">quad_form_sym</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a9355d4e6239f0bb06e0b8d2302f37af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1baa9539e0a8d4ea50aa16b73d736d93">rank</a> (const std::vector&lt; T &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a1baa9539e0a8d4ea50aa16b73d736d93"></a><br/></td></tr>
<tr class="separator:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a808d3133624cd36ac410ba872ea653c2">rank</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a808d3133624cd36ac410ba872ea653c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a808d3133624cd36ac410ba872ea653c2"></a><br/></td></tr>
<tr class="separator:a808d3133624cd36ac410ba872ea653c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8abf3ffa6d67a158348134225c9d3090">resize</a> (T &amp;x, std::vector&lt; size_t &gt; <a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a>)</td></tr>
<tr class="memdesc:a8abf3ffa6d67a158348134225c9d3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices.  <a href="#a8abf3ffa6d67a158348134225c9d3090"></a><br/></td></tr>
<tr class="separator:a8abf3ffa6d67a158348134225c9d3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab540ec1825d8a36cf690a3f061d544bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab540ec1825d8a36cf690a3f061d544bb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab540ec1825d8a36cf690a3f061d544bb">row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i)</td></tr>
<tr class="memdesc:ab540ec1825d8a36cf690a3f061d544bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified matrix, using start-at-1 indexing.  <a href="#ab540ec1825d8a36cf690a3f061d544bb"></a><br/></td></tr>
<tr class="separator:ab540ec1825d8a36cf690a3f061d544bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adb157990709e17068a450238d0a579fb">rows</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:adb157990709e17068a450238d0a579fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e1fb33918f8c4e61cc7709905db012c">rows_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6e1fb33918f8c4e61cc7709905db012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6e1fb33918f8c4e61cc7709905db012c"></a><br/></td></tr>
<tr class="separator:a6e1fb33918f8c4e61cc7709905db012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7b071fe169e76df6dc2a49c85ec28b2f">rows_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="#a7b071fe169e76df6dc2a49c85ec28b2f"></a><br/></td></tr>
<tr class="separator:a7b071fe169e76df6dc2a49c85ec28b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34fd02fe795ea38c98f4a02befed309f">sd</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a34fd02fe795ea38c98f4a02befed309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified column vector.  <a href="#a34fd02fe795ea38c98f4a02befed309f"></a><br/></td></tr>
<tr class="separator:a34fd02fe795ea38c98f4a02befed309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e1cb72c1528f0ff383033c642341147">sd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8e1cb72c1528f0ff383033c642341147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8e1cb72c1528f0ff383033c642341147"></a><br/></td></tr>
<tr class="separator:a8e1cb72c1528f0ff383033c642341147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e828d606f1a1c8faf42e6d901089543"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e828d606f1a1c8faf42e6d901089543"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4e828d606f1a1c8faf42e6d901089543">segment</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="memdesc:a4e828d606f1a1c8faf42e6d901089543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector.  <a href="#a4e828d606f1a1c8faf42e6d901089543"></a><br/></td></tr>
<tr class="separator:a4e828d606f1a1c8faf42e6d901089543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad2c340addebdc88ac086b0e1fac2c1b7">segment</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="separator:ad2c340addebdc88ac086b0e1fac2c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a721232b5c8e7c068a120719255f5fb0c">segment</a> (const std::vector&lt; T &gt; &amp;sv, size_t i, size_t n)</td></tr>
<tr class="separator:a721232b5c8e7c068a120719255f5fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a204f15e3685b2c610ca2c0c80a3005d5">singular_values</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a204f15e3685b2c610ca2c0c80a3005d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the singular values of the specified matrix in decreasing order of magnitude.  <a href="#a204f15e3685b2c610ca2c0c80a3005d5"></a><br/></td></tr>
<tr class="separator:a204f15e3685b2c610ca2c0c80a3005d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa1f9966aade9c4515d33d3ffa7305462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724679c01caa9ae44c146fe8019ddcf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a724679c01caa9ae44c146fe8019ddcf6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6">softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a724679c01caa9ae44c146fe8019ddcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <a href="#a724679c01caa9ae44c146fe8019ddcf6"></a><br/></td></tr>
<tr class="separator:a724679c01caa9ae44c146fe8019ddcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a80f5418b16ea26e9bc6d2a8f9b764897">sort_asc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order.  <a href="#a80f5418b16ea26e9bc6d2a8f9b764897"></a><br/></td></tr>
<tr class="separator:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0b2712eab9b95535c0589455ed11cfc">sort_desc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:ab0b2712eab9b95535c0589455ed11cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order.  <a href="#ab0b2712eab9b95535c0589455ed11cfc"></a><br/></td></tr>
<tr class="separator:ab0b2712eab9b95535c0589455ed11cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aea0d013ec0a699e61dd74f32aa722fa0">sort_asc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:aea0d013ec0a699e61dd74f32aa722fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in ascending order.  <a href="#aea0d013ec0a699e61dd74f32aa722fa0"></a><br/></td></tr>
<tr class="separator:aea0d013ec0a699e61dd74f32aa722fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a13ae8cd1155e8c4c684efb4405a1e277">sort_desc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:a13ae8cd1155e8c4c684efb4405a1e277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in descending order.  <a href="#a13ae8cd1155e8c4c684efb4405a1e277"></a><br/></td></tr>
<tr class="separator:a13ae8cd1155e8c4c684efb4405a1e277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa870be227ae57e703770592d7d5d3a22"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa870be227ae57e703770592d7d5d3a22"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa870be227ae57e703770592d7d5d3a22">squared_dist</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:aa870be227ae57e703770592d7d5d3a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between the specified vectors.  <a href="#aa870be227ae57e703770592d7d5d3a22"></a><br/></td></tr>
<tr class="separator:aa870be227ae57e703770592d7d5d3a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c14b7fd70050f03a07fdf73a1df06d2">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37cb2d874adcc950cb0439af044f549f">stan_print</a> (std::ostream *o, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a37cb2d874adcc950cb0439af044f549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae94f7170ee85d4b353f55e3a044d2345">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="separator:ae94f7170ee85d4b353f55e3a044d2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9c9057d71cf2795d0042f665c0f89c1">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffa61a0521d0c07b8c4cd7ccbbb4aca">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63cf32e07d51c4ebfe042dd452eeae14">sub_col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:a63cf32e07d51c4ebfe042dd452eeae14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x 1 subcolumn starting at (i-1,j-1).  <a href="#a63cf32e07d51c4ebfe042dd452eeae14"></a><br/></td></tr>
<tr class="separator:a63cf32e07d51c4ebfe042dd452eeae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ea780efd8d0282dbf069f0776d727b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1ea780efd8d0282dbf069f0776d727b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1ea780efd8d0282dbf069f0776d727b">sub_row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:aa1ea780efd8d0282dbf069f0776d727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x nrows subrow starting at (i-1,j-1).  <a href="#aa1ea780efd8d0282dbf069f0776d727b"></a><br/></td></tr>
<tr class="separator:aa1ea780efd8d0282dbf069f0776d727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a90c28e884c638ed67fa0c81ffc01e2d3">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second specified matrix from the first specified matrix.  <a href="#a90c28e884c638ed67fa0c81ffc01e2d3"></a><br/></td></tr>
<tr class="separator:a90c28e884c638ed67fa0c81ffc01e2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36726c055970205db893867a77e9d0a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a36726c055970205db893867a77e9d0a7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a36726c055970205db893867a77e9d0a7">subtract</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a36726c055970205db893867a77e9d0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776789f307db599fddcda6a68c480557"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a776789f307db599fddcda6a68c480557"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a776789f307db599fddcda6a68c480557">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="separator:a776789f307db599fddcda6a68c480557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1efee0b4f8879a114af50b7e9802745c">sum</a> (const std::vector&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1efee0b4f8879a114af50b7e9802745c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the values in the specified standard vector.  <a href="#a1efee0b4f8879a114af50b7e9802745c"></a><br/></td></tr>
<tr class="separator:a1efee0b4f8879a114af50b7e9802745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44c32c2d7e895378feb11c99091765ad">sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:a44c32c2d7e895378feb11c99091765ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified column vector.  <a href="#a44c32c2d7e895378feb11c99091765ad"></a><br/></td></tr>
<tr class="separator:a44c32c2d7e895378feb11c99091765ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2770a97397fc738125d70420393fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5b2770a97397fc738125d70420393fb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac5b2770a97397fc738125d70420393fb">tail</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:ac5b2770a97397fc738125d70420393fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the back of the specified vector.  <a href="#ac5b2770a97397fc738125d70420393fb"></a><br/></td></tr>
<tr class="separator:ac5b2770a97397fc738125d70420393fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7ae4ee69ace75bb2fb216247ab8272ec">tail</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the back of the specified row vector.  <a href="#a7ae4ee69ace75bb2fb216247ab8272ec"></a><br/></td></tr>
<tr class="separator:a7ae4ee69ace75bb2fb216247ab8272ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9956cf78180c6340f61667e797cf7055">tail</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="separator:a9956cf78180c6340f61667e797cf7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b07b3f7d18cdb710806c5793a83d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16b07b3f7d18cdb710806c5793a83d31">tcrossprod</a> (const <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a16b07b3f7d18cdb710806c5793a83d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="#a16b07b3f7d18cdb710806c5793a83d31"></a><br/></td></tr>
<tr class="separator:a16b07b3f7d18cdb710806c5793a83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2576c9799bbb676b1b2d930be8032b8c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int R2&gt; </td></tr>
<tr class="memitem:a2576c9799bbb676b1b2d930be8032b8c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2576c9799bbb676b1b2d930be8032b8c">to_vector</a> (const Eigen::Matrix&lt; T, R1, R2 &gt; &amp;m)</td></tr>
<tr class="separator:a2576c9799bbb676b1b2d930be8032b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7001fd7e0296d5dae6ab0a88e1a28547">trace</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <a href="#a7001fd7e0296d5dae6ab0a88e1a28547"></a><br/></td></tr>
<tr class="separator:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplParams" colspan="2">template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09d402800ee27ba77d03dc3ec365d22e">trace_gen_quad_form</a> (const Eigen::Matrix&lt; double, RD, CD &gt; &amp;D, const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a09d402800ee27ba77d03dc3ec365d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(D B^T A B).  <a href="#a09d402800ee27ba77d03dc3ec365d22e"></a><br/></td></tr>
<tr class="separator:a09d402800ee27ba77d03dc3ec365d22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a097af33142548fd565d1dab2233fa3e5">trace_quad_form</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a097af33142548fd565d1dab2233fa3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <a href="#a097af33142548fd565d1dab2233fa3e5"></a><br/></td></tr>
<tr class="separator:a097af33142548fd565d1dab2233fa3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db6bf273b69e20dc12e0c348b928296"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a9db6bf273b69e20dc12e0c348b928296"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9db6bf273b69e20dc12e0c348b928296">transpose</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a9db6bf273b69e20dc12e0c348b928296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0908a541f73f2d206d9bc0d41c487a4d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a0908a541f73f2d206d9bc0d41c487a4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0908a541f73f2d206d9bc0d41c487a4d">validate_column_index</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m, size_t j, const char *msg)</td></tr>
<tr class="separator:a0908a541f73f2d206d9bc0d41c487a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954f9705a277937f1a4e39f85c226304"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a954f9705a277937f1a4e39f85c226304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a954f9705a277937f1a4e39f85c226304">validate_greater</a> (const T1 &amp;x, const T2 &amp;y, const char *x_name, const char *y_name, const char *fun_name)</td></tr>
<tr class="separator:a954f9705a277937f1a4e39f85c226304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a2d6e5f828a2dc08ccba7dab2ba02"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a153a2d6e5f828a2dc08ccba7dab2ba02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a153a2d6e5f828a2dc08ccba7dab2ba02">validate_greater_or_equal</a> (const T1 &amp;x, const T2 &amp;y, const char *x_name, const char *y_name, const char *fun_name)</td></tr>
<tr class="separator:a153a2d6e5f828a2dc08ccba7dab2ba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c8dde0b08965817c862676d5b8aa3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a849c8dde0b08965817c862676d5b8aa3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a849c8dde0b08965817c862676d5b8aa3">validate_less</a> (const T1 &amp;x, const T2 &amp;y, const char *x_name, const char *y_name, const char *fun_name)</td></tr>
<tr class="separator:a849c8dde0b08965817c862676d5b8aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5968c67a61a65e3fe2a434d9ffb7bf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3f5968c67a61a65e3fe2a434d9ffb7bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f5968c67a61a65e3fe2a434d9ffb7bf">validate_less_or_equal</a> (const T1 &amp;x, const T2 &amp;y, const char *x_name, const char *y_name, const char *fun_name)</td></tr>
<tr class="separator:a3f5968c67a61a65e3fe2a434d9ffb7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2cb320ad093bb28e503258b3681826"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a6c2cb320ad093bb28e503258b3681826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6c2cb320ad093bb28e503258b3681826">validate_matching_dims</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;x1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:a6c2cb320ad093bb28e503258b3681826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53597362a6c7c1158057959fcac292e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad53597362a6c7c1158057959fcac292e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad53597362a6c7c1158057959fcac292e">validate_matching_sizes</a> (const std::vector&lt; T1 &gt; &amp;x1, const std::vector&lt; T2 &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:ad53597362a6c7c1158057959fcac292e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ec7da4239a007943fc013e07cba3aa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a41ec7da4239a007943fc013e07cba3aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a41ec7da4239a007943fc013e07cba3aa">validate_matching_sizes</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;x1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:a41ec7da4239a007943fc013e07cba3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263171956617573c8cd3c1d18fd6ceb3"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a263171956617573c8cd3c1d18fd6ceb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a263171956617573c8cd3c1d18fd6ceb3">validate_matching_sizes</a> (const Eigen::Block&lt; Derived &gt; &amp;x1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:a263171956617573c8cd3c1d18fd6ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8129ae89cd2dbb265cb12b92f8e04422"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename Derived &gt; </td></tr>
<tr class="memitem:a8129ae89cd2dbb265cb12b92f8e04422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8129ae89cd2dbb265cb12b92f8e04422">validate_matching_sizes</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;x1, const Eigen::Block&lt; Derived &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:a8129ae89cd2dbb265cb12b92f8e04422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd4c08b7da0d68132fa34cb400ea42f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:affd4c08b7da0d68132fa34cb400ea42f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#affd4c08b7da0d68132fa34cb400ea42f">validate_matching_sizes</a> (const Eigen::Block&lt; Derived1 &gt; &amp;x1, const Eigen::Block&lt; Derived2 &gt; &amp;x2, const char *msg)</td></tr>
<tr class="separator:affd4c08b7da0d68132fa34cb400ea42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8623dd71addc9eb308adbd79650173"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2f8623dd71addc9eb308adbd79650173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2f8623dd71addc9eb308adbd79650173">validate_multiplicable</a> (const T1 &amp;x1, const T2 &amp;x2, const char *msg)</td></tr>
<tr class="separator:a2f8623dd71addc9eb308adbd79650173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ad50f7ce663f08887cc98f00325102"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4ad50f7ce663f08887cc98f00325102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab4ad50f7ce663f08887cc98f00325102">validate_nonzero_size</a> (const T &amp;x, const char *msg)</td></tr>
<tr class="separator:ab4ad50f7ce663f08887cc98f00325102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eabaf81a12e1ba52dc95991f3c7cec"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a89eabaf81a12e1ba52dc95991f3c7cec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a89eabaf81a12e1ba52dc95991f3c7cec">validate_row_index</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m, size_t i, const char *msg)</td></tr>
<tr class="separator:a89eabaf81a12e1ba52dc95991f3c7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2967cc986a918329c7e226aa97d35"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a80e2967cc986a918329c7e226aa97d35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a80e2967cc986a918329c7e226aa97d35">validate_square</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, const char *msg)</td></tr>
<tr class="separator:a80e2967cc986a918329c7e226aa97d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bef2aad224049eb13f5de732d60805"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8bef2aad224049eb13f5de732d60805"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa8bef2aad224049eb13f5de732d60805">validate_std_vector_index</a> (const std::vector&lt; T &gt; &amp;sv, size_t j, const char *msg)</td></tr>
<tr class="separator:aa8bef2aad224049eb13f5de732d60805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7c964f96b6454223b9204f463ad674"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a3e7c964f96b6454223b9204f463ad674"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e7c964f96b6454223b9204f463ad674">validate_symmetric</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, const char *msg)</td></tr>
<tr class="separator:a3e7c964f96b6454223b9204f463ad674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b9b83e5ca3d865f9dcf26d57a69fe"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a883b9b83e5ca3d865f9dcf26d57a69fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a883b9b83e5ca3d865f9dcf26d57a69fe">validate_vector</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, const char *msg)</td></tr>
<tr class="separator:a883b9b83e5ca3d865f9dcf26d57a69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa433ac2fc47bbd40a6d87f62574dff85">variance</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa433ac2fc47bbd40a6d87f62574dff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector.  <a href="#aa433ac2fc47bbd40a6d87f62574dff85"></a><br/></td></tr>
<tr class="separator:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f055da8754c2215aac70d7787692f54">variance</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a1f055da8754c2215aac70d7787692f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector.  <a href="#a1f055da8754c2215aac70d7787692f54"></a><br/></td></tr>
<tr class="separator:a1f055da8754c2215aac70d7787692f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad3d78d2735a35451f02bcd2f4da24886">rep_array</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:ad3d78d2735a35451f02bcd2f4da24886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8edf0b7ec2ad24b1fda26a8d58513106">rep_array</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; std::vector&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53054db4cfa6672654fbaedafbdae242">rep_array</a> (const T &amp;x, int k, int m, int n)</td></tr>
<tr class="separator:a53054db4cfa6672654fbaedafbdae242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31fd1c6f1cd56836b049489009d2221"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad31fd1c6f1cd56836b049489009d2221"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad31fd1c6f1cd56836b049489009d2221">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:ad31fd1c6f1cd56836b049489009d2221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79febbfc52e2118819bb0eb77fbea561"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79febbfc52e2118819bb0eb77fbea561"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79febbfc52e2118819bb0eb77fbea561">rep_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, int n)</td></tr>
<tr class="separator:a79febbfc52e2118819bb0eb77fbea561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa70f063ee9a5790fbed08ba8ae07c52e">rep_matrix</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, int m)</td></tr>
<tr class="separator:aa70f063ee9a5790fbed08ba8ae07c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9d77ddf6ad38a102ebd6f5e433c3e6c">rep_row_vector</a> (const T &amp;x, int m)</td></tr>
<tr class="separator:ac9d77ddf6ad38a102ebd6f5e433c3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b132ea41ccfdb7b0ca4897cbb64649a">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a2b132ea41ccfdb7b0ca4897cbb64649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fcab47a4a1c557ed22ce8c9dfa4690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa5fcab47a4a1c557ed22ce8c9dfa4690">validate_non_negative_rep</a> (int n, const std::string &amp;fun)</td></tr>
<tr class="memdesc:aa5fcab47a4a1c557ed22ce8c9dfa4690"><td class="mdescLeft">&#160;</td><td class="mdescRight">If argument is negative, throw a domain error indicating the function with the specified name.  <a href="#aa5fcab47a4a1c557ed22ce8c9dfa4690"></a><br/></td></tr>
<tr class="separator:aa5fcab47a4a1c557ed22ce8c9dfa4690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582d3c65ec66505882d2d1b740887ae8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a582d3c65ec66505882d2d1b740887ae8">F32</a> (double a, double b, double c, double d, double <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, double z, double precision=1e-6)</td></tr>
<tr class="separator:a582d3c65ec66505882d2d1b740887ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db199c237a3b502dccc197db9dfcd7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8db199c237a3b502dccc197db9dfcd7d">gradF32</a> (double *g, double a, double b, double c, double d, double <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, double z, double precision=1e-6)</td></tr>
<tr class="separator:a8db199c237a3b502dccc197db9dfcd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aed6cfebd1e7a926130982018cfefe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a71aed6cfebd1e7a926130982018cfefe">grad2F1</a> (double &amp;gradA, double &amp;gradC, double a, double b, double c, double z, double precision=1e-6)</td></tr>
<tr class="separator:a71aed6cfebd1e7a926130982018cfefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e61bf2a2523eac620649be1b836f6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e61bf2a2523eac620649be1b836f6af">gradIncBeta</a> (double &amp;g1, double &amp;g2, double a, double b, double z)</td></tr>
<tr class="separator:a6e61bf2a2523eac620649be1b836f6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748e297c3c711bde9cd125cdc873dc8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a748e297c3c711bde9cd125cdc873dc8d">gradRegIncBeta</a> (double &amp;g1, double &amp;g2, double a, double b, double z, double digammaA, double digammaB, double digammaSum, double betaAB)</td></tr>
<tr class="separator:a748e297c3c711bde9cd125cdc873dc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55877c24977357ef441acc0b37f6b337"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a55877c24977357ef441acc0b37f6b337">gradRegIncGamma</a> (double a, double z, double g, double dig, double precision=1e-6)</td></tr>
<tr class="separator:a55877c24977357ef441acc0b37f6b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a66f94e47c6dc073bbd3929903b4431fe"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66f94e47c6dc073bbd3929903b4431fe">E</a> = boost::math::constants::e&lt;double&gt;()</td></tr>
<tr class="memdesc:a66f94e47c6dc073bbd3929903b4431fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_103.png"/>.  <a href="#a66f94e47c6dc073bbd3929903b4431fe"></a><br/></td></tr>
<tr class="separator:a66f94e47c6dc073bbd3929903b4431fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a> = std::sqrt(2.0)</td></tr>
<tr class="memdesc:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_104.png"/>.  <a href="#a491d6e40aaa2a3e205ea6708dc3c75dd"></a><br/></td></tr>
<tr class="separator:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e346d5a812af988f8de4a5948c88"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5491e346d5a812af988f8de4a5948c88">INV_SQRT_2</a> = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td></tr>
<tr class="memdesc:a5491e346d5a812af988f8de4a5948c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_105.png"/>.  <a href="#a5491e346d5a812af988f8de4a5948c88"></a><br/></td></tr>
<tr class="separator:a5491e346d5a812af988f8de4a5948c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43fb48f0a7f26bc60c1dfb572283b149">LOG_2</a> = std::log(2.0)</td></tr>
<tr class="memdesc:a43fb48f0a7f26bc60c1dfb572283b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_106.png"/>.  <a href="#a43fb48f0a7f26bc60c1dfb572283b149"></a><br/></td></tr>
<tr class="separator:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773773e2db53015eb48ab1730816fb5"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab773773e2db53015eb48ab1730816fb5">LOG_10</a> = std::log(10.0)</td></tr>
<tr class="memdesc:ab773773e2db53015eb48ab1730816fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_107.png"/>.  <a href="#ab773773e2db53015eb48ab1730816fb5"></a><br/></td></tr>
<tr class="separator:ab773773e2db53015eb48ab1730816fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7f2ac8ebf3095e9934715bb34f0669b3">INFTY</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <a href="#a7f2ac8ebf3095e9934715bb34f0669b3"></a><br/></td></tr>
<tr class="separator:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa37d0f67f02e0a0b5797ed9f4df56bfb">NEGATIVE_INFTY</a> = - std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <a href="#aa37d0f67f02e0a0b5797ed9f4df56bfb"></a><br/></td></tr>
<tr class="separator:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf147700a2e38335abc618b2c913b8a"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cf147700a2e38335abc618b2c913b8a">NOT_A_NUMBER</a> = std::numeric_limits&lt;double&gt;::quiet_NaN()</td></tr>
<tr class="memdesc:a9cf147700a2e38335abc618b2c913b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Quiet) not-a-number value.  <a href="#a9cf147700a2e38335abc618b2c913b8a"></a><br/></td></tr>
<tr class="separator:a9cf147700a2e38335abc618b2c913b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ffd625c2083751d7ccabb7dbe39cbe0">EPSILON</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest positive value.  <a href="#a5ffd625c2083751d7ccabb7dbe39cbe0"></a><br/></td></tr>
<tr class="separator:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcea3a9752d079c9f972040b873b704"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1dcea3a9752d079c9f972040b873b704">NEGATIVE_EPSILON</a> = - std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a1dcea3a9752d079c9f972040b873b704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest negative value (i.e., smallest absolute value).  <a href="#a1dcea3a9752d079c9f972040b873b704"></a><br/></td></tr>
<tr class="separator:a1dcea3a9752d079c9f972040b873b704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177764626d2378e0d7bdfb26aac187b6"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a177764626d2378e0d7bdfb26aac187b6">LOG_PI_OVER_FOUR</a> = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td></tr>
<tr class="separator:a177764626d2378e0d7bdfb26aac187b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935530f53a026ebb80fcd9006059e9c8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a> = 2.0 / std::sqrt(boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a935530f53a026ebb80fcd9006059e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a344504ea0c1f4f956c85ea8027a07ba9">NEG_TWO_OVER_SQRT_PI</a> = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td></tr>
<tr class="separator:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d54686aa26009d0e9101be42afd877"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44d54686aa26009d0e9101be42afd877">INV_SQRT_TWO_PI</a> = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a44d54686aa26009d0e9101be42afd877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece739c5a2672028f0c7848045b89f08"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aece739c5a2672028f0c7848045b89f08">CONSTRAINT_TOLERANCE</a> = 1E-8</td></tr>
<tr class="memdesc:aece739c5a2672028f0c7848045b89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance for checking arithmetic bounds In rank and in simplexes.  <a href="#aece739c5a2672028f0c7848045b89f08"></a><br/></td></tr>
<tr class="separator:aece739c5a2672028f0c7848045b89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrices and templated mathematical functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac1a24821b475ee296830ebac12f70460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">stan::math::matrix_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for matrix of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac105e584e4ed2d24a5c3a40df4d94697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,1,Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac105e584e4ed2d24a5c3a40df4d94697">stan::math::row_vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (row) vector of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00031">31</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa29284c242450c2000920599105e4eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt;::Index <a class="el" href="namespacestan_1_1math.html#aa29284c242450c2000920599105e4eb0">stan::math::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00010">10</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c7ab54df86be3a3d61e58623c210d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double,Eigen::Dynamic,1&gt; <a class="el" href="namespacestan_1_1math.html#a0c7ab54df86be3a3d61e58623c210d86">stan::math::vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (column) vector of double values. </p>

<p>Definition at line <a class="el" href="math_2matrix_2typedefs_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aeb4764556637084eee528b45d8eaa767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return floating-point absolute value. </p>
<p>Delegates to <code>fabs(double)</code> rather than <code>std::abs(int)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of scalar </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2abs_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2abs_8hpp_source.html">abs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d4b97f71328d3de40de286ec6e3754e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrices. </p>
<p>The two matrices must have the same dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m1 and m2 do not have the same dimensions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00027">27</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa92ade0aeac74c8366b8c210446324a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrix and specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix plus the scalar. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00049">49</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4cbcb4a48d3284e93afe13093412683"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R,C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified scalar and specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar plus the matrix. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00070">70</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad1c484220022b3abfb79c16d1d7f72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::as_bool </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the argument is unequal to zero and 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if argument is equal to zero and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2as__bool_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2functions_2as__bool_8hpp_source.html">as_bool.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86b5156aa25d21592dbd3624aae1ea39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacestan_1_1math.html#a6ad1c484220022b3abfb79c16d1d7f72">stan::math::as_bool</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an integer with an equivalent boolean value to specified input. </p>
<p>For integers, this reduces to the identity function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2as__bool_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2functions_2as__bool_8hpp_source.html">as_bool.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f394c15ea3eb97743382631f91801cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHS &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> function is overloaded. This instance will match arguments where the right-hand side is assignable to the left and they are not both <code>std::vector</code> or <code>Eigen::Matrix</code> types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00039">39</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5371f0f914e9b79a0700577e5557c0b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types, but whose shapes are not compatible. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R1</td><td>Row shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row shape of right-hand side matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column shape of right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00065">65</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a80c719463c4e3caa03df731e2c2cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape of both mtarices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00096">96</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4af3a90ad3b5ec1507dfc1823fdb8da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Block&lt; LHS &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shape of the right-hand side matrix is specified in the row and column shape template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of matrix block elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape for right-hand side matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape for right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side block view of matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00123">123</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c6dec98c71fd478c2ee16bc274b464d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>std::vector</code>, and will call <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable.">assign()</a></code> element-by element.</p>
<p>For example, a <code>std::vector&lt;int&gt;</code> can be assigned to a <code>std::vector&lt;double&gt;</code> using this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side vector elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side vector. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00153">153</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebfb3835848bd8550192cd5e090d3b5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2bessel__first__kind_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2bessel__first__kind_8hpp_source.html">bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a645ce13c6454913ec39be807751604dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2bessel__second__kind_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2bessel__second__kind_8hpp_source.html">bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add2a043f562537b8cc57bb35780ac5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::binary_log_loss </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log loss function for binary classification with specified reference and response values. </p>
<p>The log loss function for prediction <img class="formulaInl" alt="$\hat{y} \in [0, 1]$" src="form_108.png"/> given outcome <img class="formulaInl" alt="$y \in \{ 0, 1 \}$" src="form_109.png"/> is</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(1,\hat{y}) = -\log \hat{y} $" src="form_110.png"/>, and</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(0,\hat{y}) = -\log (1 - \hat{y}) $" src="form_111.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Reference value in { 0 , 1 }. </td></tr>
    <tr><td class="paramname">y_hat</td><td>Response value in [0,1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log loss for response given reference value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2binary__log__loss_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2functions_2binary__log__loss_8hpp_source.html">binary_log_loss.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27dad23d38c6d5e74c65e7571c70272e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_N , typename T_n &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_N, T_n&gt;::type stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const T_N&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_n&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the binomial coefficient for the specified arguments. </p>
<p>The binomial coefficient, <img class="formulaInl" alt="${N \choose n}$" src="form_112.png"/>, read "N choose n", is defined for <img class="formulaInl" alt="$0 \leq n \leq N$" src="form_113.png"/> by</p>
<p><img class="formulaInl" alt="${N \choose n} = \frac{N!}{n! (N-n)!}$" src="form_114.png"/>.</p>
<p>This function uses Gamma functions to define the log and generalize the arguments to continuous N and n.</p>
<p><img class="formulaInl" alt="$ \log {N \choose n} = \log \ \Gamma(N+1) - \log \Gamma(n+1) - \log \Gamma(N-n+1)$" src="form_115.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>total number of objects. </td></tr>
    <tr><td class="paramname">n</td><td>number of objects chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log (N choose n). </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2binomial__coefficient__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="math_2functions_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af163dfd071f1cff0297b7418156563a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::block </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x ncols submatrix starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row </td></tr>
    <tr><td class="paramname">j</td><td>Starting column </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="block_8hpp_source.html#l00023">23</a> of file <a class="el" href="block_8hpp_source.html">block.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a244fb67601cb568b79137450f934047b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_bounded </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__bounded_8hpp_source.html#l00068">68</a> of file <a class="el" href="check__bounded_8hpp_source.html">check_bounded.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e00f0db84045333d946bb2a49b924ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_bounded </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__bounded_8hpp_source.html#l00079">79</a> of file <a class="el" href="check__bounded_8hpp_source.html">check_bounded.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea62b7ae38dc4b6a84bfe90f72b1fc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor. </p>
<p>A Cholesky factor is a lower triangular matrix whose diagonal elements are all positive. Note that Cholesky factors need not be square, but require at least as many rows M as columns N (i.e., M &gt;= N).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor </td></tr>
    <tr><td class="paramname">T_result</td><td>Type of result. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab78172933a2bd63bdd511f062564a505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00051">51</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63e498bfd9699c99b57b207e2869023a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor (lower triangular, positive diagonal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of function. </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">result</td><td>Pointer into which to write result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor </td></tr>
    <tr><td class="paramname">T_result</td><td>Type of result. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00071">71</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1bba6a9591ff4834950d8819d17ec105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00078">78</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8987da44a92a90edb79fd84fd39e39d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__consistent__size_8hpp_source.html#l00011">11</a> of file <a class="el" href="check__consistent__size_8hpp_source.html">check_consistent_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0e0ad1687b604c6f0667a12922a2545"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00012">12</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a4c9f7aec5e75731b7e3d0c33a758b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00025">25</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1244db32f5cb1447091b8f7965fe09d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00040">40</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19892bf98f113034430413117fddd012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid correlation matrix. </p>
<p>A valid correlation matrix is symmetric, has a unit diagonal (all 1 values), and has all values between -1 and 1 (inclussive).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified matrix is a valid correlation matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__corr__matrix_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__corr__matrix_8hpp_source.html">check_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad32dc573d6046854e39913596554961b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__corr__matrix_8hpp_source.html#l00062">62</a> of file <a class="el" href="check__corr__matrix_8hpp_source.html">check_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90326b7bfecdcd28d2555c001ca7cf0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid covariance matrix. </p>
<p>A valid covariance matrix must be square, symmetric, and positive definite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid covariance matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf9d505abaaf8ae26ad366f51d71fbd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00048">48</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea06d3b49639cdd7f4eee1a9e21d01a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_covar , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid covariance matrix. </p>
<p>A valid covariance matrix must be symmetric and positive definite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">Sigma</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid covariance matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00070">70</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac60a94eb57a3b80ccdb54d75a38d5aa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00085">85</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6feab878b8ff447121df2e6a9461680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variable y is finite. </p>

<p>Definition at line <a class="el" href="check__finite_8hpp_source.html#l00049">49</a> of file <a class="el" href="check__finite_8hpp_source.html">check_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46c87d5d26732e2860ae58d00f4fdff2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__finite_8hpp_source.html#l00058">58</a> of file <a class="el" href="check__finite_8hpp_source.html">check_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aada3014caf18d49104f7d63d0d6ea15e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__greater_8hpp_source.html#l00056">56</a> of file <a class="el" href="check__greater_8hpp_source.html">check_greater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf1c4b2de4ed60a01fe919a0b3655fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__greater_8hpp_source.html#l00065">65</a> of file <a class="el" href="check__greater_8hpp_source.html">check_greater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbb58d3f6d9657f8488bc74a6db0a056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__greater__or__equal_8hpp_source.html#l00056">56</a> of file <a class="el" href="check__greater__or__equal_8hpp_source.html">check_greater_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe66408d89f69a9d59b13d7c3d73423b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__greater__or__equal_8hpp_source.html#l00065">65</a> of file <a class="el" href="check__greater__or__equal_8hpp_source.html">check_greater_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7187754b7dfb0727664c3bed40ccf7b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__less_8hpp_source.html#l00055">55</a> of file <a class="el" href="check__less_8hpp_source.html">check_less.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a359cf57677ad750cbe12441ba34df391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__less_8hpp_source.html#l00064">64</a> of file <a class="el" href="check__less_8hpp_source.html">check_less.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5a1e6a543017c50d64bcdd9d53bd83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__less__or__equal_8hpp_source.html#l00050">50</a> of file <a class="el" href="check__less__or__equal_8hpp_source.html">check_less_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adaaa5ed482610e1a8c0477cdd60e8033"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__less__or__equal_8hpp_source.html#l00059">59</a> of file <a class="el" href="check__less__or__equal_8hpp_source.html">check_less_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54f45f5cee19ad65fdd516e1b855d0fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is lower triangular. </p>
<p>A matrix x is not lower triangular if there is a non-zero entry x[m,n] with m &lt; n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is symmetric. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__lower__triangular_8hpp_source.html#l00026">26</a> of file <a class="el" href="check__lower__triangular_8hpp_source.html">check_lower_triangular.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd9fc9fd09527b5b8adf811d3d5b5e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__lower__triangular_8hpp_source.html#l00046">46</a> of file <a class="el" href="check__lower__triangular_8hpp_source.html">check_lower_triangular.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68e2e1e4423183dabe9e5cdad6bee6c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonnegative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__nonnegative_8hpp_source.html#l00046">46</a> of file <a class="el" href="check__nonnegative_8hpp_source.html">check_nonnegative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88d0fc72c0c2a6612f355cd48ddffab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonnegative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__nonnegative_8hpp_source.html#l00054">54</a> of file <a class="el" href="check__nonnegative_8hpp_source.html">check_nonnegative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee36bc9bba89bed1d1568d20046cd3da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_not_nan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variable y is nan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of function being invoked. </td></tr>
    <tr><td class="paramname">y</td><td>Reference to variable being tested. </td></tr>
    <tr><td class="paramname">name</td><td>Name of variable being tested. </td></tr>
    <tr><td class="paramname">result</td><td>Pointer to resulting value after test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of variable being tested. </td></tr>
    <tr><td class="paramname">T_result</td><td>Type of result returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__not__nan_8hpp_source.html#l00054">54</a> of file <a class="el" href="check__not__nan_8hpp_source.html">check_not_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d490dd2ffa3a5775cfd4f5347111505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_not_nan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__not__nan_8hpp_source.html#l00064">64</a> of file <a class="el" href="check__not__nan_8hpp_source.html">check_not_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55bd442a2e6c56c40d7b60d0079ac8a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is sorted into increasing order. </p>
<p>There may be duplicate values. Otherwise, raise a domain error according to the specified policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Vector to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector has positive, ordered values. </dd></dl>

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00025">25</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69935f4ef1aad90e6a48c49ba945efc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00050">50</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa543443cb0c96a44613255c83d593a86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_definite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is positive definite. </p>
<p>NOTE: symmetry is NOT checked by this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive definite. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2error__handling_2matrix_2check__pos__definite_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2error__handling_2matrix_2check__pos__definite_8hpp_source.html">check_pos_definite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa38f7f1aacfd755763e5b00af14ff9b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_definite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2error__handling_2matrix_2check__pos__definite_8hpp_source.html#l00055">55</a> of file <a class="el" href="math_2error__handling_2matrix_2check__pos__definite_8hpp_source.html">check_pos_definite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7341142ee291b13f1ad04152a37f974f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is positive definite. </p>
<p>NOTE: symmetry is NOT checked by this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive semi-definite. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__pos__semidefinite_8hpp_source.html#l00026">26</a> of file <a class="el" href="check__pos__semidefinite_8hpp_source.html">check_pos_semidefinite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9a161786def6581011502056d92c021"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__pos__semidefinite_8hpp_source.html#l00053">53</a> of file <a class="el" href="check__pos__semidefinite_8hpp_source.html">check_pos_semidefinite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a573ec8402d9e6928596057ee179a96a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__positive_8hpp_source.html#l00048">48</a> of file <a class="el" href="check__positive_8hpp_source.html">check_positive.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac07e0ff96981b93a266298e6c9343395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__positive_8hpp_source.html#l00056">56</a> of file <a class="el" href="check__positive_8hpp_source.html">check_positive.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a953ca730fb62ef45047f2a73c0f84a88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector contains only non-negative values and is sorted into increasing order. </p>
<p>There may be duplicate values. Otherwise, raise a domain error according to the specified policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Vector to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector has positive, ordered values. </dd></dl>

<p>Definition at line <a class="el" href="check__positive__ordered_8hpp_source.html#l00025">25</a> of file <a class="el" href="check__positive__ordered_8hpp_source.html">check_positive_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a153b3fac80bd9f9739f87cfccb7eb870"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__positive__ordered_8hpp_source.html#l00059">59</a> of file <a class="el" href="check__positive__ordered_8hpp_source.html">check_positive_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1220906f5cf5892f9867a4b9bcec08c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4cbbf2c5799c876b8b5a40a6be59fad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob , typename T_result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_simplex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is simplex. </p>
<p>To be a simplex, all values must be greater than or equal to 0 and the values must sum to 1.</p>
<p>The test that the values sum to 1 is done to within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a simplex. </dd></dl>

<p>Definition at line <a class="el" href="check__simplex_8hpp_source.html#l00027">27</a> of file <a class="el" href="check__simplex_8hpp_source.html">check_simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5371fc49b7503afbe9a49867fc5d075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_simplex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__simplex_8hpp_source.html#l00067">67</a> of file <a class="el" href="check__simplex_8hpp_source.html">check_simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa604267d7189b6fde0be2c83f03f60f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00013">13</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7db9ba4076101c008a4164d1f4f0881d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1 *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00034">34</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f953f345a5fc4d4258d65c9fd494d0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_spsd_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square, symmetric, and positive semi-definite. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__spsd__matrix_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__spsd__matrix_8hpp_source.html">check_spsd_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919b0ac7be6e9129159dcd57b5aaa229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_spsd_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__spsd__matrix_8hpp_source.html#l00045">45</a> of file <a class="el" href="check__spsd__matrix_8hpp_source.html">check_spsd_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa8e58058a05567645f7589f90f5acaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_square </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__square_8hpp_source.html#l00026">26</a> of file <a class="el" href="check__square_8hpp_source.html">check_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a354049e8dec929a4b054b7e8db06a4fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_square </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__square_8hpp_source.html#l00039">39</a> of file <a class="el" href="check__square_8hpp_source.html">check_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d97aebea4cf628724dfd08030284bb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is symmetric. </p>
<p>NOTE: squareness is not checked by this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is symmetric. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__symmetric_8hpp_source.html#l00026">26</a> of file <a class="el" href="check__symmetric_8hpp_source.html">check_symmetric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8aebef4c723a2963977653559ebd2374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__symmetric_8hpp_source.html#l00055">55</a> of file <a class="el" href="check__symmetric_8hpp_source.html">check_symmetric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab722ab154aebf9a162df8e9bd4e3e42f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob , typename T_result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_unit_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is unit vector. </p>
<p>The test that the values sum to 1 is done to within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td></td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test. </td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a unit vector. </dd></dl>

<p>Definition at line <a class="el" href="check__unit__vector_8hpp_source.html#l00025">25</a> of file <a class="el" href="check__unit__vector_8hpp_source.html">check_unit_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7496b0022b662c358931d1ab0458f60e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_unit_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__unit__vector_8hpp_source.html#l00052">52</a> of file <a class="el" href="check__unit__vector_8hpp_source.html">check_unit_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbcc91ff24e86fa318fe0f8a9111b4c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. </p>
<p>The return value <img class="formulaInl" alt="$L$" src="form_135.png"/> will be a lower-traingular matrix such that the original matrix <img class="formulaInl" alt="$A$" src="form_136.png"/> is given by </p>
<p><img class="formulaInl" alt="$A = L \times L^T$" src="form_137.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Symmetrix matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square root of matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not a symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cholesky__decompose_8hpp_source.html#l00022">22</a> of file <a class="el" href="cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae497ca37fd7867fd11c4cd095c8aaa71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified column of the specified matrix using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.col(i - 1)</code> and assigning the resulting template expression to a column vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">j</td><td>Column index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified column of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="col_8hpp_source.html#l00024">24</a> of file <a class="el" href="col_8hpp_source.html">col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a871bccc233a4dcd764ffece5a3f9a399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::cols </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cols_8hpp_source.html#l00012">12</a> of file <a class="el" href="cols_8hpp_source.html">cols.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d03b34aa7329a68f31d1c7bc500c5c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2columns__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af03701ff6420231890468e9881eb9245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,C&gt; stan::math::columns_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each column of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2columns__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2columns__dot__self_8hpp_source.html">columns_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62cc3a137ff3220bdd0137a52a4b9714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::crossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of pre-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of M times M </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2crossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2crossprod_8hpp_source.html">crossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7340f6be8ae1e121c6d854005560fef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified vector. </p>
<p>The cumulative sum of a vector of values </p>
<div class="fragment"><div class="line"> is the</div>
<div class="line"></div>
<div class="line">@code x[0], x[1] + x[2], ..., x[1] + ,..., + x[x.size()-1] </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00023">23</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affab469ac332306aa00947f4a7c5d30b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified matrix. </p>
<p>The cumulative sum is of the same type as the input and has values defined by</p>
<div class="fragment"><div class="line">x(0), x(1) + x(2), ..., x(1) + ,..., + x(x.size()-1) </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00049">49</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab65e9ab0e6f725c7e11068b0be2af84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af970bc3201f476e84259e7ba2d4eb276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::diag_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a square diagonal matrix with the specified vector of coefficients as the diagonal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal matrix with vector as diagonal values. </dd></dl>

<p>Definition at line <a class="el" href="diag__matrix_8hpp_source.html#l00018">18</a> of file <a class="el" href="diag__matrix_8hpp_source.html">diag_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00896827d3247350178c86c0aed533f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1, C1&gt; stan::math::diag_post_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__post__multiply_8hpp_source.html#l00013">13</a> of file <a class="el" href="diag__post__multiply_8hpp_source.html">diag_post_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6159f8ffb5a37c394dff93781622f504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R2, C2&gt; stan::math::diag_pre_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__pre__multiply_8hpp_source.html#l00013">13</a> of file <a class="el" href="diag__pre__multiply_8hpp_source.html">diag_pre_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a877aa9df52c3a3f300a3d214c7bde64a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::diagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of the diagonal elements of the specified matrix. </p>
<p>The matrix is not required to be square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="diagonal_8hpp_source.html#l00018">18</a> of file <a class="el" href="diagonal_8hpp_source.html">diagonal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b9073e39033e56eb31344091f0170fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00013">13</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af95a2dcde478c06e3543511821618902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00018">18</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a467589eef4220a87d457c8a268a1fd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00025">25</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33777ee768c7032331ca8b92e5323384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00034">34</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae86020a972c6efc6b3407c3cfc30f4a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functions_2dist_8hpp_source.html#l00011">11</a> of file <a class="el" href="functions_2dist_8hpp_source.html">dist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b7a051fb294f63774525cb76bfb3fb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T1&gt;::type stan::math::dist </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2dist_8hpp_source.html#l00023">23</a> of file <a class="el" href="matrix_2dist_8hpp_source.html">dist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a082ee76b34a2ea656d2c8ab9186c1a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix divided by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix divided by scalar. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2divide_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2matrix_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5af45491b0f1852295f1c7ec0730294c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result , typename T_msg2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::dom_err </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_msg2&#160;</td>
          <td class="paramname"><em>error_msg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dom__err_8hpp_source.html#l00025">25</a> of file <a class="el" href="dom__err_8hpp_source.html">dom_err.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5114bd4a8397e21dd60cc596d24022fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_result , typename T_msg2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::dom_err_vec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_msg2&#160;</td>
          <td class="paramname"><em>error_msg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_result *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dom__err__vec_8hpp_source.html#l00015">15</a> of file <a class="el" href="dom__err__vec_8hpp_source.html">dom_err_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd3b73319bd8df9dad1d3902997d8e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dot_8hpp_source.html#l00011">11</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8d73851895fb151fdf79e55bf33e98e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58da447df259e9e092e8fd910b338e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
    <tr><td class="paramname">length</td><td>Length of both arrays. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00035">35</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cd93708bf432b3bd3d284958972ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the vectors are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__product_8hpp_source.html#l00048">48</a> of file <a class="el" href="math_2matrix_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a6a4ef7c701db7984297d153580c8d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2dot__self_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac81ab85d390fcb594884773a85fac657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vector with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>number of rows or <code>Eigen::Dynamic</code> for dynamic </td></tr>
    <tr><td class="paramname">C</td><td>number of rows or <code>Eigen::Dyanmic</code> for dynamic </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If v is not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2dot__self_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b650a0131d41167ef4837ecc7d02be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::e </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base of the natural logarithm. </p>
<dl class="section return"><dt>Returns</dt><dd>Base of natural logarithm. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00086">86</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa37c65f508af7ad1d0b010aa5c932cbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::eigenvalues_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the eigenvalues of the specified symmetric matrix in descending order of magnitude. </p>
<p>This function is more efficient than the general eigenvalues function for symmetric matrices. </p>
<p>See <code>eigen_decompose()</code> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of matrix. </dd></dl>

<p>Definition at line <a class="el" href="eigenvalues__sym_8hpp_source.html#l00022">22</a> of file <a class="el" href="eigenvalues__sym_8hpp_source.html">eigenvalues_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bd4729756e6ed00a35f1e4531444c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::eigenvectors_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="eigenvectors__sym_8hpp_source.html#l00013">13</a> of file <a class="el" href="eigenvectors__sym_8hpp_source.html">eigenvectors_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c9262da41fbf44fefc9a66141a0759d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified matrices matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00025">25</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a998e2dce5971bba8c059995797e22ba0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::elt_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise multiplication of the specified matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise product of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="elt__multiply_8hpp_source.html">elt_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac38f1fab5fe3e9b45c8c6e78ac3cc749"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Rows,Cols&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise exponentiation of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i,j) = exp(m(i,j)) </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2exp_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef734d7c3b8ebd689012295bf826e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponent base 2 of the specified argument (C99). </p>
<p>The exponent base 2 function is defined by</p>
<p><code>exp2(y) = pow(2.0,y)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exponent base 2 of value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2exp2_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2exp2_8hpp_source.html">exp2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a582d3c65ec66505882d2d1b740887ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::F32 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00013">13</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2df2a7019f7f68a915b3edab21921a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2falling__factorial_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d2db622c0f83134b7f3ebd1eec3c1d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The positive difference function (C99). </p>
<p>The function is defined by</p>
<p><code>fdim(a,b) = (a &gt; b) ? (a - b) : 0.0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns min(a - b, 0.0). </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2fdim_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2functions_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d362e53d3d40b61e68fdd08dc5eb38b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>This base case simply assigns the value to the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of reference container. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00022">22</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73e791042ed648602eed1754679feff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>The specified matrix is filled by element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar for matrix container. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00039">39</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f5d81c4d45f2407096def8810ffe00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>Each container in the specified standard vector is filled recursively by calling <code>fill</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of container in vector. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00055">55</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8ac3f1f4f177645d84a1d6480f70d96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2,T3&gt;::type stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add operation (C99). </p>
<p>The function is defined by</p>
<p><code>fma(a,b,c) = (a * b) + c</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
    <tr><td class="paramname">c</td><td>Third value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the first two values plust the third. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2fma_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed411d626d4ae01a76584c454a83673f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2gamma__p_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0830ba049b81bc98ea9fbcf1eb7b4bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2gamma__q_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7535c86e2c9ee9d5391a8cc63187317e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca7c84b936da0d3422507927cf9a68cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00052">52</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a714e39ba9fcbbd90c787a51d511c9af1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00079">79</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa23b355397df347249da513307fd6667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00108">108</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25c1fac0445beea55c521c94f360e13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00139">139</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20a82151947fc8816c5ce5b7bc6d8abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00172">172</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fb72caff19c8ce19dc6e3c25c79f7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00208">208</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accc97dd76490d575638ebb22da233a53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00246">246</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae72208605f731144cab862feecb456a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00284">284</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51091bb67549e42c241f4e08e7d291d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00310">310</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0dbeed50ff3f8630ea3cd54f9ecb804"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00336">336</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf9dcd5236495d3f581b31dd05b9a227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00360">360</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac54b1427fd9d0765f0200dc9caa830f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5711f99869d05a6263218f3256e582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00052">52</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37f3ceaa6197904ef662f1edc8245e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00079">79</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3132eb36eaf861cfbd119b38e0a85a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00108">108</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbcc061003aabcaf675f4415adc80c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00139">139</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1958245532761be08be7ac9bc781f3a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00172">172</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedc7fc712ebe439bec1892c8f69447cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00208">208</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64467731d9abfaf97ea8d541d528142c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00246">246</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbdd7246170c1c0cade6c7be73f436e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; &gt; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00285">285</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8cb7e6e670cddcdf5527ec92fa3ff37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00311">311</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffeab694f7588c92dc97b6736e5be7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00337">337</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6133d90708e16760b6394c6ca6a305ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00362">362</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71aed6cfebd1e7a926130982018cfefe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad2F1 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>gradA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>gradC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00101">101</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8db199c237a3b502dccc197db9dfcd7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradF32 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00049">49</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e61bf2a2523eac620649be1b836f6af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradIncBeta </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00139">139</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a748e297c3c711bde9cd125cdc873dc8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradRegIncBeta </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>digammaA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>digammaB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>digammaSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>betaAB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00160">160</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55877c24977357ef441acc0b37f6b337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gradRegIncGamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="internal__math_8hpp_source.html#l00177">177</a> of file <a class="el" href="internal__math_8hpp_source.html">internal_math.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a140b54b11069aed039f67c6dd172256b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the front of the specified vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector input </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of v </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00025">25</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d7964d83597ea54cd7ba63bee50409f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the front of the specified row vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return row vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of rv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00043">43</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e746ba14994b318a0a192a97a0a28db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the specified number of elements as a standard vector from the front of the specified standard vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>Standard vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of sv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00059">59</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b430ac57e75ba2d55843cd868506e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::ibeta </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normalized incomplete beta function of a, b, and x. </p>
<p>Used to compute the cumulative density function for the beta distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">b</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">x</td><td>Random variate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized incomplete beta function. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2ibeta_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2functions_2ibeta_8hpp_source.html">ibeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa732732442d65936275d718b7286cb51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_true , typename T_false &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_true,T_false&gt;::type stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_true&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_false&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the second argument if the first argument is true and otherwise return the second argument. </p>
<p>This is just a convenience method to provide a function with the same behavior as the built-in ternary operator. In general, this function behaves as if defined by</p>
<p><code>if_else(c,y1,y0) = c ? y1 : y0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition value. </td></tr>
    <tr><td class="paramname">y_true</td><td>Value to return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Value to return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2if__else_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af81e05dfd6918524dafff10715f21a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00016">16</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a067af584ff2d244d2041c9b13f6d9247"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;V&gt;::value, void&gt; stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00022">22</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d6d42a356af95988b3a7005b5cf408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00026">26</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad27706378f77dc22746ad74721d495d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00031">31</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c507cff4b7b473cd86e1d428fb03136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int stan::math::int_step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer step, or Heaviside, function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if value is greater than 0 and 0 otherwise </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar argument type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="int__step_8hpp_source.html#l00014">14</a> of file <a class="el" href="int__step_8hpp_source.html">int_step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab64935e0bdac8227bfd9608285d4e699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv_8hpp_source.html">inv.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a008bf0b6c2ab38d088b0aba5d7b10c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_cloglog </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse complementary log-log function. </p>
<p>The function is defined by</p>
<p><code>inv_cloglog(x) = 1 - exp(-exp(x))</code>.</p>
<p>This function can be used to implement the inverse link function for complementary-log-log regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse complementary log-log of the argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2inv__cloglog_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2functions_2inv__cloglog_8hpp_source.html">inv_cloglog.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c4834fc581f55acf8491ec3f80ecb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse logit function applied to the argument. </p>
<p>The inverse logit function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{logit}^{-1}(x) = \frac{1}{1 + \exp(-x)}$" src="form_116.png"/>.</p>
<p>This function can be used to implement the inverse link function for logistic regression.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#a53342d0c2cd3a6e440c533070054aca3" title="Returns the logit function applied to the argument.">stan::math::logit</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse logit of argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2inv__logit_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2functions_2inv__logit_8hpp_source.html">inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4db5e98585c71cc7c14319f96e0c04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_sqrt </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv__sqrt_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv__sqrt_8hpp_source.html">inv_sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d2e922aa13e2dfae510fc13d86eaea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2inv__square_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2functions_2inv__square_8hpp_source.html">inv_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a461598c914f5634fa5057da7a817803d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2inverse_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2inverse_8hpp_source.html">inverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1edc35cc581dda178263f6a4a4fd1158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::inverse_softmax </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>simplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the inverse softmax of the simplex argument into the second argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6" title="Return the softmax of the specified vector.">stan::math::softmax</a></code> for the inverse function and a definition of the relation.</p>
<p>The inverse softmax function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{inverse\_softmax}(x)[i] = \log x[i]$" src="form_117.png"/>.</p>
<p>This function defines the inverse of <code><a class="el" href="namespacestan_1_1math.html#a724679c01caa9ae44c146fe8019ddcf6" title="Return the softmax of the specified vector.">stan::math::softmax</a></code> up to a scaling factor.</p>
<p>Because of the definition, values of 0.0 in the simplex are converted to negative infinity, and values of 1.0 are converted to 0.0.</p>
<p>There is no check that the input vector is a valid simplex vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>Simplex vector input. </td></tr>
    <tr><td class="paramname">y</td><td>Vector into which the inverse softmax is written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size of the input and output vectors differ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inverse__softmax_8hpp_source.html#l00034">34</a> of file <a class="el" href="inverse__softmax_8hpp_source.html">inverse_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a989989548db02c34cd6134790bd93478"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::inverse_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified symmetric, pos/neg-definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="inverse__spd_8hpp_source.html#l00019">19</a> of file <a class="el" href="inverse__spd_8hpp_source.html">inverse_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40c14c26dc55a985e05695b3ff1eeef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_uninitialized </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the specified variable is uninitialized. </p>
<p>Arithmetic types are always initialized by definition (the value is not specified).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is uninitialized. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2is__uninitialized_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2functions_2is__uninitialized_8hpp_source.html">is_uninitialized.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ccdb3f505b7db61c510e59e97b947b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the beta function applied to the specified arguments. </p>
<p>The beta function is defined for <img class="formulaInl" alt="$a > 0$" src="form_118.png"/> and <img class="formulaInl" alt="$b > 0$" src="form_119.png"/> by</p>
<p><img class="formulaInl" alt="$\mbox{B}(a,b) = \frac{\Gamma(a) \Gamma(b)}{\Gamma(a+b)}$" src="form_120.png"/>.</p>
<p>This function returns its log,</p>
<p><img class="formulaInl" alt="$\log \mbox{B}(a,b) = \log \Gamma(a) + \log \Gamma(b) - \log \Gamma(a+b)$" src="form_121.png"/>.</p>
<p>See <a class="el" href="namespacestan_1_1agrad.html#acb8b7366b1ecbe633d2c96f1c8dc62b8">boost::math::lgamma()</a> for the double-based and <a class="el" href="namespacestan_1_1agrad.html" title="Function gradients via reverse-mode automatic differentiation.">stan::agrad</a> for the variable-based log Gamma function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value </td></tr>
    <tr><td class="paramname">b</td><td>Second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log of the beta function applied to the two values. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first value. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2lbeta_8hpp_source.html#l00034">34</a> of file <a class="el" href="math_2functions_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a836f46d7f63f5118a32cad11382c0551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::lgamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2lgamma_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2lgamma_8hpp_source.html">lgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a672486593d10650d0646b513637305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::lmgamma </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument. </p>
<p>The multivariate gamma function <img class="formulaInl" alt="$\Gamma_k(x)$" src="form_122.png"/> for dimensionality <img class="formulaInl" alt="$k$" src="form_123.png"/> and argument <img class="formulaInl" alt="$x$" src="form_124.png"/> is defined by</p>
<p><img class="formulaInl" alt="$\Gamma_k(x) = \pi^{k(k-1)/4} \, \prod_{j=1}^k \Gamma(x + (1 - j)/2)$" src="form_125.png"/>,</p>
<p>where <img class="formulaInl" alt="$\Gamma()$" src="form_126.png"/> is the gamma function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of the multivariate gamma function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2lmgamma_8hpp_source.html#l00030">30</a> of file <a class="el" href="math_2functions_2lmgamma_8hpp_source.html">lmgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e7ce33064686ec2a2591fa5d4227cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Rows,Cols&gt; stan::math::log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise logarithm of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i,j) = log(m(i,j)) </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21f4f7c092e2bc9a089885628b86c004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of ten. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of ten. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00105">105</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f92092fb8a70b31d00898bbbe769612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one minus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one minus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1m_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2functions_2log1m_8hpp_source.html">log1m.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce261caf05bd371c430e82a0e6389a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)). </p>
<p>This function is only defined for x&lt;0 </p>

<p>Definition at line <a class="el" href="math_2functions_2log1m__exp_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2functions_2log1m__exp_8hpp_source.html">log1m_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f71c696a5e0da4daab30e5f3704842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of 1 minus the inverse logit of the specified argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of 1 minus the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1m__inv__logit_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2log1m__inv__logit_8hpp_source.html">log1m_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5166d3c58ad8ce0aedbf104179888b69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one plus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one plus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log1p_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2functions_2log1p_8hpp_source.html">log1p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88151def26813dec3e04c4a8b9674091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 plus the exponential of the specified value without overflow. </p>
<p>This function is related to other special functions by:</p>
<p><code>log1p_exp(x) </code></p>
<p><code> = log1p(exp(a))</code></p>
<p><code> = log(1 + exp(x))</code></p>
<p><code> = log_sum_exp(0,x)</code>. </p>

<p>Definition at line <a class="el" href="math_2functions_2log1p__exp_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2functions_2log1p__exp_8hpp_source.html">log1p_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa25e1572bf46e3a6b9ee270f0c7e2c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base 2 logarithm of the argument (C99). </p>
<p>The function is defined by:</p>
<p><code>log2(a) = log(a) / std::log(2.0)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base 2 logarithm of the value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log2_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a947ba3fe3c87293f7c57395007100c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of two. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log2_8hpp_source.html#l00035">35</a> of file <a class="el" href="math_2functions_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca29dad18932e3ca17ac52fd0238b364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2log__determinant_8hpp_source.html">log_determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a306d737ee042b8f40e93713cd87fe48b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_determinant_ldlt </td>
          <td>(</td>
          <td class="paramtype">stan::math::LDLT_factor&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00100">100</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a296d4414d0193108c70b350a05cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__determinant__spd_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2matrix_2log__determinant__spd_8hpp_source.html">log_determinant_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac1dbafd4c2a129415e86f868fc0979a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2. </p>
<p>This function is only defined for x&lt;0 </p>

<p>Definition at line <a class="el" href="math_2functions_2log__diff__exp_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2functions_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9cb2f3f6c73b2005d9e9fadbad415bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2log__falling__factorial_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5be889d1ef4284654a04e400f5371a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of the inverse logit of the specified argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log__inv__logit_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2functions_2log__inv__logit_8hpp_source.html">log_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf23285d755661c14ca29c3ba935b77d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2log__rising__factorial_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a011a8c8bb83f9b6c700a725240be33b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the softmax of the specified vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__softmax_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2matrix_2log__softmax_8hpp_source.html">log_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5f32f7cd1a5690a697f4031df569c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log sum of exponetials without overflow. </p>
<p><img class="formulaInl" alt="$\log (\exp(a) + \exp(b)) = m + \log(\exp(a-m) + \exp(b-m))$" src="form_127.png"/>,</p>
<p>where <img class="formulaInl" alt="$m = max(a,b)$" src="form_128.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6205ce595af6efac8746bd83b2b761da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified matrix of values. </p>
<p>The matrix may be a full matrix, a vector, or a row vector.</p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_129.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2log__sum__exp_8hpp_source.html#l00029">29</a> of file <a class="el" href="math_2matrix_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5513861b48f8649938d82883b58170c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified sequence of values. </p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_129.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html#l00044">44</a> of file <a class="el" href="math_2functions_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc35bab2db89b3ceda66f11e1fa53ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_and </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 &amp;&amp; x2 != 0</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both x1 and x2 are not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__and_8hpp_source.html#l00021">21</a> of file <a class="el" href="logical__and_8hpp_source.html">logical_and.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2213736b55fd6696fa0120fd3fe72e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_eq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is equal to the second. </p>
<p>Equivalent to <code>x1 == x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 == x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__eq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__eq_8hpp_source.html">logical_eq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba86bfd994302061a0260e1202fca777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gt </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly greater than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gt_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gt_8hpp_source.html">logical_gt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6bb0b8623192207d35e207ea312d8be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is greater than or equal to the second. </p>
<p>Equivalent to <code>x1 &gt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gte_8hpp_source.html">logical_gte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b5bd91412749e10933f304b54aef88f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lt </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly less than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lt_8hpp_source.html#l00020">20</a> of file <a class="el" href="logical__lt_8hpp_source.html">logical_lt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3649d4c704962c4502cd6220a5e2230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is less than or equal to the second. </p>
<p>Equivalent to <code>x1 &lt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__lte_8hpp_source.html">logical_lte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad2fc9ce55dfac079d930335beb7e4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_negation </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical negation function which returns 1 if the input is equal to zero and 0 otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if input is equal to zero. </dd></dl>

<p>Definition at line <a class="el" href="logical__negation_8hpp_source.html#l00017">17</a> of file <a class="el" href="logical__negation_8hpp_source.html">logical_negation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a206eb210d8e7e2c718af25c40de8f9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_neq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is unequal to the second. </p>
<p>Equivalent to <code>x1 != x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 != x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__neq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__neq_8hpp_source.html">logical_neq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac74007e2d5f55d5ae4a308f535869aee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_or </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 || x2 != 0</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if either x1 or x2 is not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__or_8hpp_source.html#l00020">20</a> of file <a class="el" href="logical__or_8hpp_source.html">logical_or.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53342d0c2cd3a6e440c533070054aca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logit function applied to the argument. </p>
<p>The logit function is defined as for <img class="formulaInl" alt="$x \in [0,1]$" src="form_130.png"/> by returning the log odds of <img class="formulaInl" alt="$x$" src="form_124.png"/> treated as a probability,</p>
<p><img class="formulaInl" alt="$\mbox{logit}(x) = \log \left( \frac{x}{1 - x} \right)$" src="form_131.png"/>.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#ad2c4834fc581f55acf8491ec3f80ecb7" title="Returns the inverse logit function applied to the argument.">stan::math::inv_logit</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logit of the argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2logit_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2logit_8hpp_source.html">logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a173839dddd0a8ac8afa710b9e3d5008a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::machine_precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference between 1.0 and the next value representable. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum positive number. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00142">142</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86b6be1d580b3b5cf4b4f57546062352"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functions_2max_8hpp_source.html#l00007">7</a> of file <a class="el" href="functions_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5da0ef87756d3dbd20ca4ff5a3efa10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the size of the vector is zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00019">19</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde414919e0e4dcfa72d565679819091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00037">37</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f299773dc20e8305fc16df1be8d029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="matrix_2max_8hpp_source.html#l00054">54</a> of file <a class="el" href="matrix_2max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7266758367e8260b2afbfaeea7d5b418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a978022fb9cb20fd35f6e9e89ab3bc871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R1,C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const stan::math::LDLT_factor&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00072">72</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c8c6e72f1cbf2b73008d4fc98de1abe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__spd_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9ffa799f8af2cd4941cbd2506bc4573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1,C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58dbd828faf06c2ef74152367f749ca4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R1,C1&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular and b=I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 . </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html#l00047">47</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a199a9357715dff8b9a3bae8cc1bb4aa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R1,C2&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html#l00015">15</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8391d23da9e29f3420fdb89116e83cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R1,C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html#l00029">29</a> of file <a class="el" href="math_2matrix_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5efba9dddcf77889b66c1210ba55cf5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__right_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68c862e90d97ea5d5552101b65978813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stan::math::LDLT_factor&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00082">82</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01d77bf4121d56b8491092164d1523ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R1,C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00091">91</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6f32dd8adc4a9ffa28d63b62d4c90f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__spd_8hpp_source.html#l00026">26</a> of file <a class="el" href="mdivide__right__spd_8hpp_source.html">mdivide_right_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae158767243e09b91b9ba6cd366e7dab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__tri_8hpp_source.html#l00028">28</a> of file <a class="el" href="mdivide__right__tri_8hpp_source.html">mdivide_right_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09f35fbeab4d8ff311ce77d91492e26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type,R1,C2&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b * tri(A)^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2mdivide__right__tri__low_8hpp_source.html#l00024">24</a> of file <a class="el" href="math_2matrix_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3443c4ac994b039a7f055c55c5afa8a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00023">23</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8074c0041b93407c473fd26a7c45dc88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00040">40</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab360c822174f211838f5979760c7e09e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="functions_2min_8hpp_source.html#l00007">7</a> of file <a class="el" href="functions_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f076860549f63d55c0e4985dce78099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00018">18</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e9c3a01030d96fd4c8f28e2ed8d3d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00036">36</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86f2380e5c54a549e0f74ffd51204d33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified matrix, vector, or row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix, vector, or row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="matrix_2min_8hpp_source.html#l00053">53</a> of file <a class="el" href="matrix_2min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87b343d6dc12982c2b76c453650c0797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::minus </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negation of the specified scalar or matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negation of subtrahend. </dd></dl>

<p>Definition at line <a class="el" href="minus_8hpp_source.html#l00016">16</a> of file <a class="el" href="minus_8hpp_source.html">minus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acafecf14b103c7c17da33368d07b1565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2modified__bessel__first__kind_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2modified__bessel__first__kind_8hpp_source.html">modified_bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72ce86f3db5478cad4666c9cf1d05a6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2modified__bessel__second__kind_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2modified__bessel__second__kind_8hpp_source.html">modified_bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919d4a6495c489841df3d0423200b147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix multiplied by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of matrix and scalar. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a2b6dbfb5543b73dac8496091745ec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified scalar multiplied by specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalar and matrix. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00045">45</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c72cdca253e0230e0dbd19400781b5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,R1,C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of the specified matrices. </p>
<p>The number of columns in the first matrix must be the same as the number of rows in the second matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the first and second matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the number of columns of m1 does not match the number of rows of m2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00061">61</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e67698775aaac248efa49b646ca2a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the scalar product of the specified row vector and specified column vector. </p>
<p>The return is the same as the dot product. The two vectors must be the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector. </td></tr>
    <tr><td class="paramname">v</td><td>Column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar result of multiplying row vector by column vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rv and v are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply_8hpp_source.html#l00078">78</a> of file <a class="el" href="math_2matrix_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab530a1792bc901bb6ade34ef3d9ef8b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a , typename T_b &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_a,T_b&gt;::type stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const T_a&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_b&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs. </p>
<p><img class="formulaInl" alt="$ a * \log b $" src="form_132.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a * log(b) </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2multiply__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0c953951f141b35277fe2308777cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::multiply_lower_tri_self_transpose </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower triangular values in L times their own transpose. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the input matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2multiply__lower__tri__self__transpose_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2multiply__lower__tri__self__transpose_8hpp_source.html">multiply_lower_tri_self_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34bffe91b7a24cb29bd69cb60814c39e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::negative_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Negative infinity. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00123">123</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a381493bccc58bd993d797a2a5458c486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::not_a_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (quiet) not-a-number. </p>
<dl class="section return"><dt>Returns</dt><dd>Quiet not-a-number. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00132">132</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66a7e8ebefd11e5801aab51d6ed9c9d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>First argument </td></tr>
    <tr><td class="paramname">a</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2owens__t_8hpp_source.html#l00025">25</a> of file <a class="el" href="math_2functions_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac85644bbd92359d699f374adea62c643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit normal cumulative distribution function. </p>
<p>The return value for a specified input is the probability that a random unit normal variate is less than or equal to the specified value, defined by</p>
<p><img class="formulaInl" alt="$\Phi(x) = \int_{-\infty}^x \mbox{\sf Norm}(x|0,1) \ dx$" src="form_133.png"/></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2phi_8hpp_source.html#l00028">28</a> of file <a class="el" href="math_2functions_2phi_8hpp_source.html">Phi.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf4bf2074175fd7bcde43f9f94e4d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi_approx </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximation of the unit normal CDF. </p>
<p><a href="http://www.jiem.org/index.php/jiem/article/download/60/27">http://www.jiem.org/index.php/jiem/article/download/60/27</a></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2_phi__approx_8hpp_source.html#l00023">23</a> of file <a class="el" href="math_2functions_2_phi__approx_8hpp_source.html">Phi_approx.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ffd66726e0532160e16e6b48d6f428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::pi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of pi. </p>
<dl class="section return"><dt>Returns</dt><dd>Pi. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00077">77</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34675a70d3df614d88d33ddbdd49b49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::positive_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Positive infinity. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00114">114</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1649a895ec6e79097d5645a3f8b8a1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00017">17</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7082de8742d87f7a0fa0842207341c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00032">32</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91458631115a8d1cf29298431f745556"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt;T1,T2&gt;::type stan::math::promote_common </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="promote__common_8hpp_source.html#l00014">14</a> of file <a class="el" href="promote__common_8hpp_source.html">promote_common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376cbe31002df6a319da4caaaeb8598c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,CB,CB&gt; stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute B^T A B. </p>

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00018">18</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e0213e916c2185844b48eea25312e86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00028">28</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cc753af413f715d82b992aae8b10fde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double,CB,CB&gt; stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00038">38</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9355d4e6239f0bb06e0b8d2302f37af4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2quad__form_8hpp_source.html#l00050">50</a> of file <a class="el" href="math_2matrix_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1baa9539e0a8d4ea50aa16b73d736d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00018">18</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a808d3133624cd36ac410ba872ea653c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00036">36</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d78d2735a35451f02bcd2f4da24886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00014">14</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8edf0b7ec2ad24b1fda26a8d58513106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00021">21</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53054db4cfa6672654fbaedafbdae242"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00030">30</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad31fd1c6f1cd56836b049489009d2221"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79febbfc52e2118819bb0eb77fbea561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00025">25</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa70f063ee9a5790fbed08ba8ae07c52e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00034">34</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9d77ddf6ad38a102ebd6f5e433c3e6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, 1,Eigen::Dynamic&gt; stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__row__vector_8hpp_source.html#l00015">15</a> of file <a class="el" href="rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b132ea41ccfdb7b0ca4897cbb64649a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic,1&gt; stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__vector_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8abf3ffa6d67a158348134225c9d3090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::resize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Array-like object to resize. </td></tr>
    <tr><td class="paramname">dims</td><td>New dimensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object being resized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="resize_8hpp_source.html#l00063">63</a> of file <a class="el" href="resize_8hpp_source.html">resize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c25994a9886374662f280ecba376a42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1,T2&gt;::type stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2rising__factorial_8hpp_source.html#l00011">11</a> of file <a class="el" href="math_2functions_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab540ec1825d8a36cf690a3f061d544bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified row of the specified matrix, using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.row(i - 1)</code> and assigning the resulting template expression to a row vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar value type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">i</td><td>Row index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified row of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="row_8hpp_source.html#l00025">25</a> of file <a class="el" href="row_8hpp_source.html">row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb157990709e17068a450238d0a579fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rows_8hpp_source.html#l00012">12</a> of file <a class="el" href="rows_8hpp_source.html">rows.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1fb33918f8c4e61cc7709905db012c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2rows__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2matrix_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b071fe169e76df6dc2a49c85ec28b2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,1&gt; stan::math::rows_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each row of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2rows__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="math_2matrix_2rows__dot__self_8hpp_source.html">rows_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb786f14699d69c39cfdd49893a8006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::scaled_add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__add_8hpp_source.html#l00011">11</a> of file <a class="el" href="scaled__add_8hpp_source.html">scaled_add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34fd02fe795ea38c98f4a02befed309f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="sd_8hpp_source.html#l00022">22</a> of file <a class="el" href="sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1cb72c1528f0ff383033c642341147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance. </dd></dl>

<p>Definition at line <a class="el" href="sd_8hpp_source.html#l00037">37</a> of file <a class="el" href="sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e828d606f1a1c8faf42e6d901089543"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector. </p>

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00020">20</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c340addebdc88ac086b0e1fac2c1b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00030">30</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a721232b5c8e7c068a120719255f5fb0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00040">40</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a204f15e3685b2c610ca2c0c80a3005d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::singular_values </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of the singular values of the specified matrix in decreasing order of magnitude. </p>
<p>See the documentation for <code>svd()</code> for information on the signular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="singular__values_8hpp_source.html#l00019">19</a> of file <a class="el" href="singular__values_8hpp_source.html">singular_values.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f9966aade9c4515d33d3ffa7305462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size_8hpp_source.html#l00011">11</a> of file <a class="el" href="size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a724679c01caa9ae44c146fe8019ddcf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the softmax of the specified vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2softmax_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2matrix_2softmax_8hpp_source.html">softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80f5418b16ea26e9bc6d2a8f9b764897"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea0d013ec0a699e61dd74f32aa722fa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00046">46</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b2712eab9b95535c0589455ed11cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00033">33</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13ae8cd1155e8c4c684efb4405a1e277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,R,C&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sort_8hpp_source.html#l00059">59</a> of file <a class="el" href="math_2matrix_2sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1369f60a09e3af4933096de3a54ac28c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sqrt2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Square root of two. </dd></dl>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00095">95</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a056b82f11f784f321bce2c5677089e24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the specified argument. </p>
<p><img class="formulaInl" alt="$\mbox{square}(x) = x^2$" src="form_134.png"/>.</p>
<p>The implementation of <code>square(x)</code> is just <code>x * x</code>. Given this, this method is mainly useful in cases where <code>x</code> is not a simple primitive type, particularly when it is an auto-dif type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input to square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square of input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2functions_2square_8hpp_source.html#l00022">22</a> of file <a class="el" href="math_2functions_2square_8hpp_source.html">square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa870be227ae57e703770592d7d5d3a22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::squared_dist </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2squared__dist_8hpp_source.html#l00021">21</a> of file <a class="el" href="math_2matrix_2squared__dist_8hpp_source.html">squared_dist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c14b7fd70050f03a07fdf73a1df06d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00012">12</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37cb2d874adcc950cb0439af044f549f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae94f7170ee85d4b353f55e3a044d2345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00027">27</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9c9057d71cf2795d0042f665c0f89c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00037">37</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffa61a0521d0c07b8c4cd7ccbbb4aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2stan__print_8hpp_source.html#l00047">47</a> of file <a class="el" href="math_2matrix_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fdc5e5ba8e306c2a594e928bfd62ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The step, or Heaviside, function. </p>
<p>The function is defined by</p>
<p><code>step(y) = (y &lt; 0.0) ? 0 : 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Scalar argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the specified argument is greater than or equal to 0.0, and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2step_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2functions_2step_8hpp_source.html">step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4c5e5b76b18a41b28f646104b3cd46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::sub </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sub_8hpp_source.html#l00010">10</a> of file <a class="el" href="sub_8hpp_source.html">sub.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63cf32e07d51c4ebfe042dd452eeae14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::sub_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x 1 subcolumn starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__col_8hpp_source.html#l00022">22</a> of file <a class="el" href="sub__col_8hpp_source.html">sub_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1ea780efd8d0282dbf069f0776d727b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::sub_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 1 x nrows subrow starting at (i-1,j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__row_8hpp_source.html#l00023">23</a> of file <a class="el" href="sub__row_8hpp_source.html">sub_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90c28e884c638ed67fa0c81ffc01e2d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of subtracting the second specified matrix from the first specified matrix. </p>
<p>The return scalar type is the promotion of the input types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Difference between first matrix and second matrix. </dd></dl>

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00027">27</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36726c055970205db893867a77e9d0a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00040">40</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a776789f307db599fddcda6a68c480557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1,T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00052">52</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adde1fe0f002efa49cf9f7c129fe1a1d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2functions_2sum_8hpp_source.html#l00010">10</a> of file <a class="el" href="math_2functions_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1efee0b4f8879a114af50b7e9802745c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the values in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of elements. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements summed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="math_2matrix_2sum_8hpp_source.html#l00019">19</a> of file <a class="el" href="math_2matrix_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44c32c2d7e895378feb11c99091765ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the coefficients of the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2sum_8hpp_source.html#l00034">34</a> of file <a class="el" href="math_2matrix_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5b2770a97397fc738125d70420393fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the back of the specified vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00020">20</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ae4ee69ace75bb2fb216247ab8272ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,1,Eigen::Dynamic&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the back of the specified row vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00035">35</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9956cf78180c6340f61667e797cf7055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00043">43</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b07b3f7d18cdb710806c5793a83d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#ac1a24821b475ee296830ebac12f70460">matrix_d</a> stan::math::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of post-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M times its transpose. </dd></dl>

<p>Definition at line <a class="el" href="math_2matrix_2tcrossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2tcrossprod_8hpp_source.html">tcrossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2576c9799bbb676b1b2d930be8032b8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,Eigen::Dynamic,1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, R2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__vector_8hpp_source.html#l00012">12</a> of file <a class="el" href="to__vector_8hpp_source.html">to_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7001fd7e0296d5dae6ab0a88e1a28547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trace of the specified matrix. </p>
<p>The trace is defined as the sum of the elements on the diagonal. The matrix is not required to be square. Returns 0 if matrix is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="trace_8hpp_source.html#l00019">19</a> of file <a class="el" href="trace_8hpp_source.html">trace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d402800ee27ba77d03dc3ec365d22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_gen_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RD, CD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(D B^T A B). </p>

<p>Definition at line <a class="el" href="math_2matrix_2trace__gen__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2trace__gen__quad__form_8hpp_source.html">trace_gen_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab8b4d4ddbcb7df66d3baf8394318e1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00111">111</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0261f49dc318d8ee553e378325ee3db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const stan::math::LDLT_factor&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2matrix_2ldlt_8hpp_source.html#l00129">129</a> of file <a class="el" href="math_2matrix_2ldlt_8hpp_source.html">ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a097af33142548fd565d1dab2233fa3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(B^T A B). </p>

<p>Definition at line <a class="el" href="math_2matrix_2trace__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="math_2matrix_2trace__quad__form_8hpp_source.html">trace_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9db6bf273b69e20dc12e0c348b928296"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T,C,R&gt; stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="transpose_8hpp_source.html#l00012">12</a> of file <a class="el" href="transpose_8hpp_source.html">transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0908a541f73f2d206d9bc0d41c487a4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_column_index </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__column__index_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__column__index_8hpp_source.html">validate_column_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a954f9705a277937f1a4e39f85c226304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_greater </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>y_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__greater_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__greater_8hpp_source.html">validate_greater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a153a2d6e5f828a2dc08ccba7dab2ba02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_greater_or_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>y_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__greater__or__equal_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__greater__or__equal_8hpp_source.html">validate_greater_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a849c8dde0b08965817c862676d5b8aa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_less </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>y_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__less_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__less_8hpp_source.html">validate_less.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f5968c67a61a65e3fe2a434d9ffb7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_less_or_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>x_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>y_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__less__or__equal_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__less__or__equal_8hpp_source.html">validate_less_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c2cb320ad093bb28e503258b3681826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_dims </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__dims_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__matching__dims_8hpp_source.html">validate_matching_dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad53597362a6c7c1158057959fcac292e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__sizes_8hpp_source.html#l00013">13</a> of file <a class="el" href="validate__matching__sizes_8hpp_source.html">validate_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41ec7da4239a007943fc013e07cba3aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__sizes_8hpp_source.html#l00026">26</a> of file <a class="el" href="validate__matching__sizes_8hpp_source.html">validate_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a263171956617573c8cd3c1d18fd6ceb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Block&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__sizes_8hpp_source.html#l00041">41</a> of file <a class="el" href="validate__matching__sizes_8hpp_source.html">validate_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8129ae89cd2dbb265cb12b92f8e04422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Block&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__sizes_8hpp_source.html#l00056">56</a> of file <a class="el" href="validate__matching__sizes_8hpp_source.html">validate_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affd4c08b7da0d68132fa34cb400ea42f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Block&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Block&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__matching__sizes_8hpp_source.html#l00071">71</a> of file <a class="el" href="validate__matching__sizes_8hpp_source.html">validate_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f8623dd71addc9eb308adbd79650173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_multiplicable </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__multiplicable_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__multiplicable_8hpp_source.html">validate_multiplicable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3abcd9b7deac4b6378eae04ee927f498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_non_negative_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__non__negative__index_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__non__negative__index_8hpp_source.html">validate_non_negative_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5fcab47a4a1c557ed22ce8c9dfa4690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_non_negative_rep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If argument is negative, throw a domain error indicating the function with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Integer to test for non-negativity. </td></tr>
    <tr><td class="paramname">fun</td><td>Name of function in which test is being done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If integer is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="validate__non__negative__rep_8hpp_source.html#l00020">20</a> of file <a class="el" href="validate__non__negative__rep_8hpp_source.html">validate_non_negative_rep.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ad50f7ce663f08887cc98f00325102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_nonzero_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__nonzero__size_8hpp_source.html#l00011">11</a> of file <a class="el" href="validate__nonzero__size_8hpp_source.html">validate_nonzero_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89eabaf81a12e1ba52dc95991f3c7cec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_row_index </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__row__index_8hpp_source.html#l00013">13</a> of file <a class="el" href="validate__row__index_8hpp_source.html">validate_row_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80e2967cc986a918329c7e226aa97d35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_square </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__square_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__square_8hpp_source.html">validate_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8bef2aad224049eb13f5de732d60805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_std_vector_index </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__std__vector__index_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__std__vector__index_8hpp_source.html">validate_std_vector_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e7c964f96b6454223b9204f463ad674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_symmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__symmetric_8hpp_source.html#l00013">13</a> of file <a class="el" href="validate__symmetric_8hpp_source.html">validate_symmetric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a883b9b83e5ca3d865f9dcf26d57a69fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_vector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__vector_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__vector_8hpp_source.html">validate_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73087d72fd937f4be66684bd2613ae6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified scalar argument converted to a double value. </p>
<p>This function is meant to cover the primitive types. For types requiring pass-by-reference, this template function should be specialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar to convert to double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar cast to a double. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2functions_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d7774df98215b7d113075019d74ebbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e">stan::math::value_of</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value.">value_of(T)</a></code> for a polymorphic implementation using static casts.</p>
<p>This inline pass-through no-op should be compiled away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified value. </dd></dl>

<p>Definition at line <a class="el" href="math_2functions_2value__of_8hpp_source.html#l00036">36</a> of file <a class="el" href="math_2functions_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa433ac2fc47bbd40a6d87f62574dff85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="variance_8hpp_source.html#l00023">23</a> of file <a class="el" href="variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f055da8754c2215aac70d7787692f54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="variance_8hpp_source.html#l00045">45</a> of file <a class="el" href="variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aece739c5a2672028f0c7848045b89f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::CONSTRAINT_TOLERANCE = 1E-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tolerance for checking arithmetic bounds In rank and in simplexes. </p>
<p>The default value is <code>1E-8</code>. </p>

<p>Definition at line <a class="el" href="constraint__tolerance_8hpp_source.html#l00011">11</a> of file <a class="el" href="constraint__tolerance_8hpp_source.html">constraint_tolerance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66f94e47c6dc073bbd3929903b4431fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::E = boost::math::constants::e&lt;double&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_103.png"/>. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00014">14</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ffd625c2083751d7ccabb7dbe39cbe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::EPSILON = std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smallest positive value. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00058">58</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f2ac8ebf3095e9934715bb34f0669b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INFTY = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Positive infinity. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00043">43</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5491e346d5a812af988f8de4a5948c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_2 = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_105.png"/>. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00026">26</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44d54686aa26009d0e9101be42afd877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_TWO_PI = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00150">150</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab773773e2db53015eb48ab1730816fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_10 = std::log(10.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_107.png"/>. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00038">38</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43fb48f0a7f26bc60c1dfb572283b149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_2 = std::log(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_106.png"/>. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00032">32</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a177764626d2378e0d7bdfb26aac187b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_PI_OVER_FOUR = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00070">70</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a344504ea0c1f4f956c85ea8027a07ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_TWO_OVER_SQRT_PI = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00148">148</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dcea3a9752d079c9f972040b873b704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_EPSILON = - std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Largest negative value (i.e., smallest absolute value). </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00063">63</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa37d0f67f02e0a0b5797ed9f4df56bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_INFTY = - std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negative infinity. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00048">48</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf147700a2e38335abc618b2c913b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NOT_A_NUMBER = std::numeric_limits&lt;double&gt;::quiet_NaN()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Quiet) not-a-number value. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00053">53</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a491d6e40aaa2a3e205ea6708dc3c75dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::SQRT_2 = std::sqrt(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_104.png"/>. </p>

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00020">20</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a935530f53a026ebb80fcd9006059e9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::TWO_OVER_SQRT_PI = 2.0 / std::sqrt(boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="math_2constants_8hpp_source.html#l00146">146</a> of file <a class="el" href="math_2constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2013,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
